{"meta":{"title":"nearby.ren","subtitle":null,"description":"nearby, 移动开发, 用户体验, 设计, Java, JavaWeb, Go","author":"阿荣","url":"http://b.nearby.ren"},"pages":[{"title":"2016","date":"2016-12-31T10:53:55.000Z","updated":"2017-01-04T09:16:38.000Z","comments":true,"path":"2016.html","permalink":"http://b.nearby.ren/2016.html","excerpt":"","text":"妥协生活妥协工作妥协感情我得到了什么，又失去了什么。"},{"title":"","date":"2021-10-20T12:39:04.750Z","updated":"2021-10-20T12:39:04.750Z","comments":true,"path":"naerby.html","permalink":"http://b.nearby.ren/naerby.html","excerpt":"","text":"test 01 哈哈哈 test 02 Default to Home md在线编辑器 (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-97835230-3', 'auto'); ga('send', '测试网页跳转');"},{"title":"about","date":"2015-03-14T13:17:05.000Z","updated":"2019-03-29T14:08:52.083Z","comments":false,"path":"about/index.html","permalink":"http://b.nearby.ren/about/index.html","excerpt":"","text":"姓名xxx xxxx xxxx | xxx@xxx | xxx | xxx 个人经历20xx/xx—20xx/xxcodeKK2 | Android工作描述：带领移动团队负责 xx，取得了什么成绩 20xx/xx—20xx/xxcodeKK2 | Android工作描述：负责 xx 产品，取得了什么成绩 2012/9—2015/6恩施职业技术学院 | 计算机应用专业 | 专科专业排名：x/xxx GPA： 专业技能x 年团队管理经验，x 年开发经验，x 年移动开发经验开源 xx 项目，用于 xx，多少 Star，多少 Contributors博客主要分享 xx xx熟悉 Android 应用框架设计，熟悉 Android 高性能编程及调优熟悉xx 技术点，xx 技术点，xx 技术点 项目经验 20xx/xx—至今 | codeKK2 公司 | XX 项目项目简介：职责： 20xx/xx—20xx/xx | codeKK2 公司 | XX 项目项目简介：职责： 20xx/xx—20xx/xx | codeKK2 公司 | XX 项目项目简介：职责： 20xx/xx—20xx/xx | codeKK1 公司 | XX 项目项目简介：职责： 20xx/xx—20xx/xx | codeKK1 公司 | XX 项目项目简介：职责： 在校经历XX大赛 XX 奖XX 系统设计、开发XXX 奖学金"},{"title":"categories","date":"2016-08-25T08:35:04.000Z","updated":"2018-03-13T02:57:32.729Z","comments":false,"path":"categories/index.html","permalink":"http://b.nearby.ren/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-11-19T15:13:36.178Z","updated":"2016-11-22T07:03:58.147Z","comments":true,"path":"css/personal-style.css","permalink":"http://b.nearby.ren/css/personal-style.css","excerpt":"","text":"@font-face { font-family: \"Meiryo\"; src: url(\"/fonts/Meiryo.eot\"); /* IE9 */ src: url(\"/fonts/Meiryo.eot?#iefix\") format(\"embedded-opentype\"), /* IE6-IE8 */ url(\"/fonts/Meiryo.woff\") format(\"woff\"), /* chrome, firefox */ url(\"/fonts/Meiryo.ttf\") format(\"truetype\"), /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */ url(\"/fonts/Meiryo.svg#Meiryo\") format(\"svg\"); /* iOS 4.1- */ font-style: normal; font-weight: normal; } html.page-home body{ /* position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-image: url('/images/bg.JPG'); background-color: transparent; background-size: cover; background-position: center center; background-repeat: no-repeat;*/ background: linear-gradient( #1abc9c, transparent), linear-gradient( 90deg, skyblue, transparent), linear-gradient( -90deg, coral, transparent); background-blend-mode: screen; /*background: linear-gradient(to left, #5f2c82, #49a09d);*/ }"},{"title":"link","date":"2016-08-25T08:33:32.000Z","updated":"2016-11-22T07:03:58.147Z","comments":false,"path":"link/index.html","permalink":"http://b.nearby.ren/link/index.html","excerpt":"","text":""},{"title":"project","date":"2016-08-25T08:34:41.000Z","updated":"2016-11-22T07:03:58.147Z","comments":false,"path":"project/index.html","permalink":"http://b.nearby.ren/project/index.html","excerpt":"","text":""},{"title":"nearby","date":"2016-08-26T03:39:28.000Z","updated":"2016-11-22T07:03:58.147Z","comments":true,"path":"nearby/index.html","permalink":"http://b.nearby.ren/nearby/index.html","excerpt":"","text":""},{"title":"search","date":"2016-08-25T08:35:04.000Z","updated":"2016-11-22T07:03:58.147Z","comments":false,"path":"search/index.html","permalink":"http://b.nearby.ren/search/index.html","excerpt":"","text":""},{"title":"Tags","date":"2020-11-19T15:13:36.198Z","updated":"2016-12-21T09:09:35.691Z","comments":true,"path":"tags/index.html","permalink":"http://b.nearby.ren/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"mac flutter 支持多个版本配置","slug":"mac flutter 支持多个版本配置","date":"2021-05-31T01:47:42.000Z","updated":"2021-10-03T02:23:48.453Z","comments":true,"path":"2021/05/31/mac flutter 支持多个版本配置/","link":"","permalink":"http://b.nearby.ren/2021/05/31/mac flutter 支持多个版本配置/","excerpt":"","text":"首先从官方下载需要的版本https://flutter.dev/docs/development/tools/sdk/releases?tab=macos#macos1.将下载的放在自己存放的目录 例如我的如下 2.配置Flutter环境变量 终端打开 执行 open ~/.bash_profile 打开bash_profile文件 将文件中的：export PATH=/xx/xx/flutter/bin:$PATH [xx代表你的文件目录] 改成需要配置的flutter版本地址：export PATH=/xx/xx/flutter1.20.0/bin:$PATH 然后执行：source ~/.bash_profile 最后检测flutter是否设置成功：flutter doctor 此处红框位置Flutter (Channel stable, 1.20.0, on macOS 11.4 20F71, locale zh-Hans-CN）此处是bash_profile配置好的版本的话代表版本安装成功。 3.打开 Android studio 配置flutter版本和dart版本 4.执行pubspec.yaml 的package get 更新一下库，若不报错，即更新完成至此，flutter更新完成。若想使用低版本，把以上地址都改回去，然后package get一下即可。","categories":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"},{"name":"flutter","slug":"flutter","permalink":"http://b.nearby.ren/tags/flutter/"}]},{"title":"kotlin Android day","slug":"kotlin Android  day","date":"2021-04-25T03:13:18.000Z","updated":"2022-02-22T14:32:37.502Z","comments":true,"path":"2021/04/25/kotlin Android  day/","link":"","permalink":"http://b.nearby.ren/2021/04/25/kotlin Android  day/","excerpt":"","text":"kotlin 匿名 与 具名 函数使用1234567891011121314151617fun main() &#123; //匿名函数 showInfo(&quot;lr&quot;, &quot;男&quot;, 29) &#123; println(&quot;$it&quot;) &#125; //具名函数 showInfo(&quot;lr&quot;, &quot;男&quot;, 29, ::showResultImpl)&#125;fun showResultImpl(result: String) &#123; println(result)&#125;inline fun showInfo(name: String, sex: String, age: Int, showResult: (String) -&gt; Unit) &#123; val str = &quot;显示信息 name = $&#123;name&#125; , sex = $&#123;sex&#125; , age = $&#123;age&#125;&quot; showResult(str)&#125; Java的实现方式1234567891011121314151617181920212223242526272829303132333435363738public class ClassTest &#123; public static void main(String[] args) &#123; //匿名实现方式 showInfo(&quot;lr&quot;, &quot;男&quot;, 29, new ShowResult() &#123; @Override public void show(String text) &#123; System.out.println(text); &#125; &#125;); //具体实现方式 ShowResultImpl showResult = new ShowResultImpl(); showInfo(&quot;lr&quot;, &quot;男&quot;, 29, showResult); &#125; static class ShowResultImpl implements ShowResult &#123; @Override public void show(String text) &#123; System.out.println(text); &#125; &#125; public static void showInfo(String name, String sex, int age, ShowResult showResult) &#123; String value = &quot;显示信息 name = &quot; + name + &quot; , sex = &quot; + sex + &quot; , age = &quot; + age; showResult.show(value); &#125; interface ShowResult &#123; void show(String text); &#125;&#125; 【?】 安全调用操作符12345678var lr : String? = &quot; I&apos;m wang &quot;lr = nulllr?.capitalize()// lr是可空类型 可能是null 想要使用lr 必须给出补救措施lr?.capitalize()// lr是可空类型 如果真的是null ?.后面的函数不执行，就不会引起空指针异常 【if】 安全调用操作符12345678910var lr: String? = &quot; I&apos;m wang &quot;lr = nullif (lr != null) &#123; val r = lr.capitalize()&#125; else &#123; println(lr)&#125; 【?:】 空合并操作符号12345678910var lr: String? = &quot; I&apos;m wang &quot;lr = null//空合并操作符println(lr ?: &quot;I&apos;m wang &quot;)//如果lr等于null 就会执行?:后面的区域//let函数 + 空合并操作符println(lr ?.let&#123; &quot;[$it]&quot; &#125; ?: &quot;I&apos;m wang&quot;)//如果lr等于null 则不会执行.let&#123;&#125;函数 会执行?:后面的区域 【!!】 非空断言操作符123456789var lr : String? = nulllr = &quot; I&apos;m wang &quot;//lr是可空类型 可能是null 想要使用lr 必须给出补救措施val r = lr!!.capitalize()// !!断言 不管lr是不是null 都执行，这个和java一样//如果百分百保证lr是有值，那么才可以使用断言!! 【let】 安全调用123456789101112var lr: String? = nulllr = &quot; I&apos;m wang &quot;//lr是可空类型 如果真的是null ?.后面的函数不执行，就不会引起空指针异常lr?.let &#123; it == lr //如果能够执行这里 it一定不为null if (lr.isBlank()) &#123; &quot;Default&quot; &#125; else &#123; it &#125;&#125; 【substring】截取字符串1234567891011val subStr = &quot;I&apos;m lr&quot;val indexOf = subStr.indexOf(&apos; &apos;)println(subStr.substring(0, indexOf))println(subStr.substring(0 until indexOf))//输出如下I&apos;mI&apos;mProcess finished with exit code 0 【split】分割字符串1234567891011121314151617val splitStr = &quot;I&apos;m,lr,wang,kotlin&quot;//splist 自动类型推断成 list = List&lt;String&gt;val splist = splitStr.split(&quot;,&quot;)println(&quot;分割后的list里面的元素有 $&#123;splist&#125;&quot;)//C++ 解构 kt解构val (v1, v2, v3, v4) = splistprintln(&quot;解构四个只读变量值是 $&#123;v1&#125;, $&#123;v2&#125;, $&#123;v3&#125;, $&#123;v4&#125;&quot;)//输出如下分割后的list里面的元素有 [I&apos;m, lr, wang, kotlin]解构四个只读变量值是 I&apos;m, lr, wang, kotlinProcess finished with exit code 0Process finished with exit code 0 【replace】字符串完成加解密123456789101112131415161718192021222324252627282930313233343536val sourcePwd = &quot;ABCDEFGHIJKL&quot; println(&quot;加密前处理 字符串 $&#123;sourcePwd&#125;&quot;) val r = sourcePwd.replace(Regex(&quot;[ACEGI]&quot;)) &#123; it.value when (it.value) &#123; //处理每一个字符 &quot;A&quot; -&gt; &quot;1&quot; &quot;C&quot; -&gt; &quot;2&quot; &quot;E&quot; -&gt; &quot;3&quot; &quot;G&quot; -&gt; &quot;4&quot; &quot;I&quot; -&gt; &quot;5&quot; else -&gt; it.value //返回原始字符 &#125; &#125; println(&quot;加密后处理 字符串 $&#123;r&#125;&quot;) val r1 = r.replace(Regex(&quot;[12345]&quot;)) &#123; it.value when (it.value) &#123; //处理每一个字符 &quot;1&quot; -&gt; &quot;A&quot; &quot;2&quot; -&gt; &quot;C&quot; &quot;3&quot; -&gt; &quot;E&quot; &quot;4&quot; -&gt; &quot;G&quot; &quot;5&quot; -&gt; &quot;I&quot; else -&gt; it.value //返回原始字符 &#125; &#125; println(&quot;解密后处理 字符串 $&#123;r1&#125;&quot;)加密前处理 字符串 ABCDEFGHIJKL加密后处理 字符串 1B2D3F4H5JKL解密后处理 字符串 ABCDEFGHIJKLProcess finished with exit code 0 【== ===】比较操作// == 值 内容比较 相当于java的equals// === 引用的比较 【apply】内置函数.apply返回的是自己本身 大部分的匿名函数都会返回it 而apply是持有this == 自己本身 【let】内置函数.let 匿名函数末尾行则作为返回值 let特点 返回类型: 根据函数末尾行返回的变化而变化 let方式 + 空合并操作符 对值判null，并返回1234567891011fun loginApp(acc: String, pwd: String): Boolean &#123; if (checkText(acc, &quot;请输入账户&quot;) == &quot;-1&quot;) return false if (checkText(pwd, &quot;请输入密码&quot;) == &quot;-1&quot;) return false return true&#125;fun checkText(text: String, hint: String): String &#123; return text?.let &#123; &quot;-1&quot; &#125; ?: hint&#125; 【run】内置函数.run 根据函数末尾行返回的变化而变化 而run是持有this == 自己本身 12345678910111213141516171819202122232425//输出&quot;请输入的信息必须是中文&quot; .run(::isChinese) .run(::isHint) .run(::println)//取得返回值var str: String = &quot;请输入的信息必须是中文&quot; .run(::isChinese) .run(::isHint) .run(::isRuHint)fun isChinese(text: String): Boolean &#123; val reg = &quot;[\\\\u4e00-\\\\u9fa5]&quot;.toRegex() return reg.containsMatchIn(text)&#125;fun isNumber(bol: Boolean): String &#123; return if (bol) &quot;-1&quot; else &quot;请输入的信息必须是中文&quot;&#125;fun isRuHint(str: String): String &#123; return &quot;[$str]&quot;&#125; 主构造函数规范化写法1234567891011121314151617181920// _xxx都是 临时输入类型不能直接引用 需要临时变量接收class PersonInfo(_name: String, _age: String, _job: String) &#123; private var name = _name private set(value) &#123; field = value &#125; private var age = _age private set(value) &#123; field = value &#125; private var job = _job private set(value) &#123; field = value &#125; fun show() &#123; println(&quot;$name ,$age , $job,&quot;) &#125;&#125; 主构造函数里得属性1234567// var name 就相当于 private var name = _name 的写法 得简洁写法class PersonInfo(var name: String, var age: String, var job: String) &#123; fun show() &#123; println(&quot;$name ,$age , $job,&quot;) &#125;&#125; 次构造函数12345678910111213141516171819class PersonInfo(name: String) &#123; constructor(name: String, age: String) : this(name) &#123; println(&quot;2个参数的次构造函数 name:$name ,sex:$age&quot;) &#125; constructor(name: String, age: String, job: String) : this(name) &#123; println(&quot;3个参数的次构造函数 name:$name ,sex:$age ,job:$job&quot;) &#125;&#125; val lr = PersonInfo(&quot;lr&quot;) PersonInfo(&quot;lr&quot;, &quot;16&quot;) PersonInfo(&quot;lr&quot;, &quot;16&quot;, &quot;A股&quot;)//输出2个参数的次构造函数 name:lr ,sex:163个参数的次构造函数 name:lr ,sex:16 ,job:A股 构造函数默认参数初始化1234567891011121314151617181920212223class PersonInfo(_name: String, _age: String, _job: String) &#123; //此次与Java对比 不是Java的static&#123;&#125; //是相当于Java的&#123;&#125;代 码块 init &#123; //1 println(&quot;主构造函数被调用了...&quot;) &#125; constructor(nickName: String) : this(nickName, &quot;19&quot;, &quot;A&quot;) &#123; println(&quot;次构造函数被调用了...&quot;)//2 &#125;&#125; PersonInfo(&quot;lr&quot;, &quot;1&quot;, &quot;job&quot;) println(&quot;...&quot;) PersonInfo(&quot;io&quot;)//答应你打印顺序为主构造函数被调用了......主构造函数被调用了...次构造函数被调用了... 函数执行顺序1234567891011121314151617181920212223//第一步生成val job: Stringclass PersonInfo(_name: String, _age: String, val _job: String) &#123; //第二步:生成val job val job = _job //此次与Java对比 不是Java的static&#123;&#125; //是相当于Java的&#123;&#125;代 码块 init &#123; //1 val jobValue = _job //第三步:生成jobValue细节 println(&quot;主构造函数被调用了...$jobValue&quot;) &#125; //次构造函数 constructor(nickName: String) : this(nickName, &quot;19&quot;, &quot;A&quot;) &#123; //第四步: 生成次构造的细节 println(&quot;次构造函数被调用了...&quot;)//2 &#125;&#125;二三步骤是并行的 成员与init是同时生成的//细节 因为 val job = _job 在init前之前所以就会先生成，再到init。 延迟初始化lateinit学习12345678910111213141516171819202122232425262728293031323334class LateinitClass &#123; lateinit var job: String fun request() &#123; job = &quot;编程&quot; &#125; fun showResponseResult() &#123; //处理技巧 if (::job.isInitialized) println(&quot;showResponseResult $job&quot;) else println(&quot;你都没有初始化加载 &quot;) //输出 println(&quot;showResponseResult $job&quot;) &#125;&#125;//执行就会报错var lc = LateinitClass()lc.showResponseResult()//正确方式var lc = LateinitClass()lc.request()lc.showResponseResult()Exception in thread &quot;main&quot; kotlin.UninitializedPropertyAccessException: lateinit property job has not been initialized at test.kotlin.LateinitClass.showResponseResult(ktFunction.kt:128) at test.kotlin.KtFunctionKt.main(ktFunction.kt:115) at test.kotlin.KtFunctionKt.main(ktFunction.kt) 因为你还没初始化 lateinit var job: String 就开始使用了。 惰性初始化 by lazay123456789101112131415161718192021222324class ByLazyClass &#123; val dataBaseData1 = readSQLServerDatabase()//01 val dataBaseData by lazy &#123; readSQLServerDatabase() &#125; private fun readSQLServerDatabase() &#123; println(&quot;开始启动操作......&quot;) println(&quot;加载读取操作......&quot;) println(&quot;加载读取操作......&quot;) println(&quot;加载读取操作......&quot;) println(&quot;加载读取操作......&quot;) println(&quot;加载读取操作......&quot;) println(&quot;结束所有操作......&quot;) &#125;&#125;//构建时候不会加载var bylazy = ByLazyClass() //此次构建得时候会执行 01处代码//开始使用才会加载bylazy.dataBaseData 初始化常见陷阱问题1234567891011121314//问题一class TextClass(_info: String) &#123; //如下会报错 因为kotlin会严格按顺序执行下来的。 // variable cannot be initialized before declaration //声明前不能初始化变量 init &#123; number = number.times(9) &#125; private var number = 9&#125; 12345678910111213141516171819202122232425262728//问题二class TextClass() &#123; private val info: String //01 init &#123; //02 getInfoMethod() info = &quot;DerryOk&quot; &#125; fun getInfoMethod() &#123; //03 println(&quot;info:$&#123;info[0]&#125;&quot;) &#125;&#125;//执行会报错 因为 TextClass()时候就会执行 02块 然后info还没被初始化就引用就会报错TextClass().getInfoMethod()Exception in thread &quot;main&quot; java.lang.NullPointerException at test.kotlin.TextClass.getInfoMethod(ktFunction.kt:134) at test.kotlin.TextClass.&lt;init&gt;(ktFunction.kt:129) at test.kotlin.KtFunctionKt.main(ktFunction.kt:120) at test.kotlin.KtFunctionKt.main(ktFunction.kt) 123456789101112131415161718192021//问题三class TextClass(_info: String) &#123; val content: String = getInfoMethod() //01 private val info = _info //02 private fun getInfoMethod() = info //03&#125;println(&quot;内容的长度：$&#123;TextClass(&quot;test&quot;).content.length&#125;&quot;)//执行就会报错Exception in thread &quot;main&quot; java.lang.NullPointerException at test.kotlin.KtFunctionKt.main(ktFunction.kt:118) at test.kotlin.KtFunctionKt.main(ktFunction.kt)//因为调用.content时候会执行 03 再执行 02 这时候info还未被初始化。解决方法就是将 02 与 01 顺序调换 kotlin的 继承12345678910111213141516171819202122//Kt所有的类，默认是final修饰的，不能被继承 与Java相反//通过关键字 open:移除final修饰open class PersonInfo(private val name: String) &#123; fun showName() = &quot;父类 的姓名是 $name&quot; open fun outInfo() = println(showName())&#125;class Student(private val subName: String) : PersonInfo(subName) &#123; private fun showName() = &quot;子类 的姓名是 $subName&quot; override fun outInfo() = println(showName())&#125;//返回父类的引用 调用则返回是子类实现 因为重写了方法val personInfo: PersonInfo = Student(&quot;lr&quot;)personInfo.outInfo() kotlin类型转换 【 is + as 】123456789101112131415161718192021222324252627282930313233343536373839//Kt所有的类，默认是final修饰的，不能被继承 与Java相反//通过关键字 open:移除final修饰open class PersonInfo(private val name: String) &#123; fun showName1() = &quot;父类 的姓名是 $name&quot; open fun outInfo() = println(showName1())&#125;class Student(private val subName: String) : PersonInfo(subName) &#123; private fun showName() = &quot;子类 的姓名是 $subName&quot; override fun outInfo() = println(showName())&#125;val personInfo: PersonInfo = Student(&quot;lr&quot;)personInfo.outInfo()if(personInfo is Student)&#123; (personInfo as Student).outInfo()&#125;if (personInfo is Student) &#123; (personInfo as Student).outInfo()&#125;if (personInfo is PersonInfo) &#123; println ((personInfo as PersonInfo).showName1())&#125;//输出子类 的姓名是 lr父类 的姓名是 lr","categories":[{"name":"kotlin","slug":"kotlin","permalink":"http://b.nearby.ren/categories/kotlin/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"http://b.nearby.ren/tags/kotlin/"}]},{"title":"adorid仅有一个设备，如何做好屏幕适配","slug":"Android gradle依赖冲突解决办法","date":"2020-11-05T04:20:11.000Z","updated":"2022-04-30T04:42:15.935Z","comments":true,"path":"2020/11/05/Android gradle依赖冲突解决办法/","link":"","permalink":"http://b.nearby.ren/2020/11/05/Android gradle依赖冲突解决办法/","excerpt":"","text":"1.出现的冲突 2.解决方法（解决方法都跟第三部分依赖树有很大关系，建议结合起来看啦）方法一 1234configurations.all &#123; //强制使用某个版本的依赖，若需强制多个依赖，可以逗号分割， resolutionStrategy.force &apos;com.android.support:support-annotations:26.1.0&apos;&#125; 方法二 12345678910configurations.all &#123; resolutionStrategy.eachDependency &#123; DependencyResolveDetails details -&gt; def requested = details.requested if (requested.group == &apos;com.android.support&apos;) &#123; if (!requested.name.startsWith(&quot;multidex&quot;)) &#123; details.useVersion &apos;26.1.0&apos; &#125; &#125; &#125;&#125; 方法三 123456androidTestImplementation (&apos;com.android.support.test:runner:1.0.2&apos;)&#123; exclude group:&apos;com.android.support&apos;,module: &apos;support-annotations&apos; &#125; androidTestImplementation (&apos;com.android.support.test.espresso:espresso-core:3.0.2&apos;)&#123; exclude group:&apos;com.android.support&apos;,module: &apos;support-annotations&apos; &#125; 3.查看依赖的依赖列表（依赖树）1gradlew -q app:dependencies 可以看到appcompat-v7和runner中都有依赖support-annotations,可以看到冲突存在的位置是26.1.0–&gt;27.1.1 还有一种更简单的方法可以看到冲突所在，在module下的gradle.buildd下添加如下代码，但缺点就是不知道具体它是哪个上层依赖引起的，可以结合起来在 Terminal 打印的日志中直接搜索，可快速定位到冲突所在，毕竟依赖树打印出来是一大串的 12345configurations.all &#123; resolutionStrategy &#123; failOnVersionConflict() &#125;&#125; 4.什么情况下会产生依赖冲突？如果通过相同的方式引入不同版本的依赖库，默认会选择最新版本，不同的方式引入则会产生依赖冲突。引入的方式有：通过jar/aar、maven（不同的compile也算不同方式，如cmpile和androidTestCompile两者引入的方式不同）具体可看：android studio 关于gradle依赖管理的一些知识 了解Android支持库 各种导入方式","categories":[{"name":"gradle","slug":"gradle","permalink":"http://b.nearby.ren/categories/gradle/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"},{"name":"gradle","slug":"gradle","permalink":"http://b.nearby.ren/tags/gradle/"}]},{"title":"深入详解Apk编译打包流程","slug":"深入详解Apk编译打包流程","date":"2020-09-11T04:13:18.000Z","updated":"2021-10-22T13:28:56.546Z","comments":true,"path":"2020/09/11/深入详解Apk编译打包流程/","link":"","permalink":"http://b.nearby.ren/2020/09/11/深入详解Apk编译打包流程/","excerpt":"","text":"apk的编译流程1、apk文件. apk是Android Package的缩写；. 解压apk文件后包含AndroidManifest.xml、assets目录、classes.dex(还可能有 classes2.dex,classes3.dex…classesN.dex)、lib目录、META-INF目录、res目录和resources.arsc；. classes.dex 是.dex文件；. resources.arsc是resources resources文件；. AndroidManifest.xml是AndroidManifest.xml文件；. res是uncompiled resources；. META-INF是签名文件夹； 2、打包流程 打包中需要的工具. aapt：Android资源打包工具，${ANDROID_SDK_HOME}/platform-tools/appt. aidl：Android接口描述语言转化为.java文件的工具，${ANDROID_SDK_HOME}/platform-tools/aidl. javac：Java Compiler，${JDK_HOME}/javac或/usr/bin/javac. dex：转化.class文件为Davik VM能识别的.dex文件，${ANDROID_SDK_HOME}/platform-tools/dx. apkbuilder：生成apk包，${ANDROID_SDK_HOME}/tools/opkbuilder. jarsigner：.jar文件的签名工具，${JDK_HOME}/jarsigner或/usr/bin/jarsigner. zipalign：字节码对齐工具，${ANDROID_SDK_HOME}/tools/zipalign 2.1打包资源文件，生成R.java文件使用aapt来打包res资源文件，生成R.java、resources.arsc和res文件（二进制 &amp; 非二进制如res/raw和pic保持原样）； res目录. animator：这类资源以XML文件保存在res/animator目录下，用来描述属性动画；. anim：这类资源以XML文件保存在res/anim目录下，用来描述补间动画；. color：这类资源以XML文件保存在res/color目录下，用描述对象颜色状态选择子；. drawable：这类资源以XML或者Bitmap文件保存在res/drawable目录下，用来描述可绘制对象。例如，我们可以在里面放置一些图片（.png, .9.png, .jpg, .gif），来作为程序界面视图的背景图；. layout：这类资源以XML文件保存在res/layout目录下，用来描述应用程序界面布局；. menu：这类资源以XML文件保存在res/menu目录下，用来描述应用程序菜单；. raw：这类资源以任意格式的文件保存在res/raw目录下，它们和assets类资源一样，都是原装不动地打包在apk文件中的，不过它们会被赋予资源ID，这样我们就可以在程序中通过ID来访问它们。例如，假设在res/raw目录下有一个名称. . 为filename的文件，并且它在编译的过程，被赋予的资源ID为R.raw.filename，那么就可以使用以下代码来访问它：. Resources res = getResources();. InputStream is = res .openRawResource(R.raw.filename);. values：这类资源以XML文件保存在res/values目录下，用来描述一些简单值，例如，数组、颜色、尺寸、字符串和样式值等，一般来说，这六种不同的值分别保存在名称为arrays.xml、colors.xml、dimens.xml、strings.xml. 和styles.xml文件中；. xml：这类资源以XML文件保存在res/xml目录下，一般就是用来描述应用程序的配置信息； resources.arsc文件. resources.arsc这个文件记录了所有的应用程序资源目录的信息，包括每一个资源名称、类型、值、ID以及所配置的维度信息；. 我们可以将这个resources.arsc文件想象成是一个资源索引表，这个资源索引表在给定资源ID和设备配置信息的情况下，能够在应用程序的资源目录中快速地找到最匹配的资源； R.java文件. R.java文件，里面拥有很多个静态内部类，比如layout，string等；. 每当有这种资源添加时，就在R.java文件中添加一条静态内部类里的静态常量类成员，且所有成员都是int类型； 2.2处理AIDL文件，生成对应的.java文件. AIDL （Android Interface Definition Language）， Android接口定义语言，Android提供的IPC （Inter Process Communication，进程间通信）的一种独特实现；. 这个阶段处理.aidl文件，生成对应的Java接口文件； 2.3编译Java文件，生成对应的.class文件. 编译工程源码，生成相应的class文件。处理文件包括src、R.java、AIDL生成的 java 文件，库jar文件；. 调用了javac编译工程的src目录下所有的java源文件，生成的class文件位于工程的bin\\classess目录下； 2.4把.class文件转化成Davik VM支持的.dex文件. 转换所有的class文件，生成classes.dex文件。处理文件就是上一步生成的 .class 文件；. 使用dx工具将java字节码转换为dalvik字节码、压缩常量池、消除冗余信息等；. 通过dex命令，将.class文件和第三方库中的.class文件处理生成classes.dex； 2.5打包生成未签名的.apk文件将classes.dex、resources.arsc、res文件夹(res/raw资源被原装不动地打包进APK之外，其它的资源都会被编译或者处理)、Other Resources(assets文件夹)、AndroidManifest.xml打包成apk文件；注意： res/raw和assets的相同点：两者目录下的文件在打包后会原封不动的保存在apk包中，不会被编译成二进制； res/raw和assets的不同点：. res/raw中的文件会被映射到R.java文件中，访问的时候直接使用资源ID即R.id.filename；assets文件夹下的文件不会被映射到R.java中，访问的时候需要AssetManager类；. res/raw不可以有目录结构，而assets则可以有目录结构，也就是assets目录下可以再建立文件夹； 2.6对未签名.apk文件进行签名. android的应用程序需要签名才能在android设备上安装，签名apk文件有两种情况:. 在调试应用程序时，也就是我们通常称为的debug模式的签名，平时开发的时候，在编译调试程序时会自己使用一个debug.keystore对apk进行签名；. 正式发布时对应用程序打包进行签名，这种情况下需要提供一个符合android开发文档中要求的签名文件。这种签名也是分两种： JDK中提供的jarsigner工具签名 、android源码中提供的signapk工具； 2.7对签名后的.apk文件进行对齐处理. release mode 下使用 aipalign进行align，即对签名后的apk进行对齐处理；. Zipalign是一个android平台上整理APK文件的工具，它对apk中未压缩的数据进行4字节对齐，对齐后就可以使用mmap函数读取文件，可以像读取内存一样对普通文件进行操作。如果没有4字节对齐，就必须显式的读取，这样比较缓慢并且会耗费额外的内存；. 在 Android SDK 中包含一个名为 “zipalign” 的工具，它能够对打包后的 app 进行优化。 其位于 SDK 的 build-tools 目录下；","categories":[{"name":"Android","slug":"Android","permalink":"http://b.nearby.ren/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://b.nearby.ren/tags/Android/"}]},{"title":"android 网络优化","slug":"android 网络优化","date":"2020-03-31T01:12:23.000Z","updated":"2021-10-03T02:39:34.670Z","comments":true,"path":"2020/03/31/android 网络优化/","link":"","permalink":"http://b.nearby.ren/2020/03/31/android 网络优化/","excerpt":"","text":"前言随着移动网络的不断升级，客户端的网络传输由3G进化到Wifi、4G，且Wifi场景越来越多。虽然网络环境在变好，但也对网络的应用提出了更高的要求，会发现很多大厂都十分重视网络指标，如果技术人员不加以控制，在弱网、体验、包括服务器带宽、流浪方面都会造成不同程度的损失。 网络指标流量网络第一个影响的app指标当然是流量，在手机设置界面可以清楚查看到每个 app 耗费的流量，极端情况下会造成用户卸载。 电量频繁的网络请求和网络时常是引发电量的主要原因，每次发送请求都会激活电信号，同样耗电也会对用户产生恶略的影响，甚至卸载。 用户体验一些网络框架会优化处理内部线程池，但线程池毕竟有限，网络请求过多或请求数据包体大，就会造成网络阻塞，也就是一些用户所谓的卡顿，在弱网方面可能表现更差，所以网络框架的好坏直接影响着整个app的用户体验。 安全网络安全同样是网络优化中十分重要的一部分，怎样防止被第三方窃听/篡改或冒充，防止运营商劫持，同时又不影响性能，没有安全体系的网络架构同样会对服务端或者客户端造成直接或间接的影响。 网络监控Network MonitorNetwork Monitor Android Studio自带的网络监测工具，可以看出时间段之内的网络请求数量及访问速率。 Charles 抓包工具本人更习惯于使用 charles 进行网络监控，这可以查看更多的数据指标，查看请求request、response 更加直观。 网络优化本人觉得网络优化主要从以下几个方面入手： 1.请求速度2.链接成功率3.流量消耗4.安全策略 网络请求过程：1.DNS 解析，请求DNS服务器，获取IP地址2.建立连接，包括 tcp 三次握手、安全协议3.发送和接收数据，解码数据 优化DNS解析1.DNS解析在网路错误中占比较高，使用IP直连方式替代DNS服务器解析，可以减少域名解析几百毫秒的时间消耗。 连接池复用keep-alive HTTP 协议里有个 keep-alive，HTTP1.1默认开启，一定程度上缓解了每次请求都要进行TCP三次握手建立连接的耗时。原理是请求完成后不立即释放连接，而是放入连接池中，若这时有另一个请求要发出，请求的域名和端口是一样的，就直接拿出连接池中的连接进行发送和接收数据，少了建立连接的耗时。 数据压缩目前比较成熟的方案未 GZIP 压缩，正常情况下压缩率均值能打包 30-50之间，可以极大的提升传输速度和节省流量，必要是可以使用 Protocol Buffer 替换 JSON 。 弱网优化弱网优化，在弱网时要是制定合适的超时时间，控制网络并发，合并打包请求，调优TCP参数，使用TCP优化算法。对服务端的TCP协议参数进行调优，以及开启各种优化算法，使得适合业务特性和移动端网络环境，包括RTO初始值，混合慢启动，TLP，F-RTO等。针对弱网的这些细致优化暂未成为标准，开源网络库 mars 有实现可以借鉴，若有需要可以使用。 网络安全1.采用 Https 双向认证2.参数加密校验，防窃听/篡改或冒充3.加密秘钥保护，采用 so 方式进行秘钥提取","categories":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"},{"name":"性能优化","slug":"性能优化","permalink":"http://b.nearby.ren/tags/性能优化/"}]},{"title":"View绘制主要要讲什么","slug":"View绘制主要要讲什么","date":"2019-12-30T03:50:25.000Z","updated":"2021-08-23T22:51:18.391Z","comments":true,"path":"2019/12/30/View绘制主要要讲什么/","link":"","permalink":"http://b.nearby.ren/2019/12/30/View绘制主要要讲什么/","excerpt":"","text":"View的绘制流程是程序开发的必备知识，也是面试经常会问到知识 View绘制如下图 简单回答就是 measure，layout，draw 分别对应测量，布局，绘制三个过程。涉及到更深的知识就会引申到Handler，同步屏障，View 的事件传递，甚至 activity 的启动过程。 什么是 ViewRootImpl相比 Viewgroup 和 View，ViewRootImpl 可能更为陌生，实际开发中我们基本用不到它。那么 从结构上来看，ViewRootImpl 和 ViewGroup 其实是一种东西 1234public final class ViewRootImpl implements ViewParent, View.AttachInfo.Callbacks, ThreadedRenderer.DrawCallbacks &#123;&#125;public abstract class ViewGroup extends View implements ViewParent, ViewManager &#123;&#125; 它们都继承了 ViewParent。ViewParent 是一个接口，定义了一些父 View 的基本行为，比如 requestlayout，getparent 等。不同的是，ViewRootImpl 并不会像 ViewGroup 一样被真正绘制在屏幕上。在 activity 中，它是专门用来绘制 DecorView 的，核心方法是 setView “activity，window，View 三者之间的关系是什么？” 如图所示，window 是 activity 里的一个实例变量，本质是一个接口，唯一的实现类是 PhoneWindow。 activity 的 setContentView 方法实际上是就是交给 phonewindow 去做的。window 和 View 的关系可以类比为显示器和显示的内容。 每个 activity 都有一个“显示器” window，“显示的内容”就是 DecorView。这个“显示器”定义了一些方法来决定如何显示内容。比如 setTitleColor setTitle 是设置导航栏的颜色和 title , setAllowReturnTransitionOverlap 设置进/出场动画等等。 所以 window 是 activity 的一个成员变量，window 和 View 是“显示器”和“显示内容”的关系。 这就是他们的关系 在整个 activity 的生命周期中，setContentView 是在 onCreate 中调用的，它实现了对资源文件的解析，完成了 xml 文件到 View 的转化。那么 View 真正开始绘制是在哪个生命周期呢？ 答案是 onResume 结束后 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224@Override public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward, String reason) &#123; // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); mSomeActivitiesChanged = true; // 1. 执行Activity的onResume方法 final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason); if (r == null) &#123; // We didn&apos;t actually resume the activity, so skipping any follow-up actions. return; &#125; if (mActivitiesToBeDestroyed.containsKey(token)) &#123; // Although the activity is resumed, it is going to be destroyed. So the following // UI operations are unnecessary and also prevents exception because its token may // be gone that window manager cannot recognize it. All necessary cleanup actions // performed below will be done while handling destruction. return; &#125; final Activity a = r.activity; if (localLOGV) &#123; Slog.v(TAG, &quot;Resume &quot; + r + &quot; started activity: &quot; + a.mStartedActivity + &quot;, hideForNow: &quot; + r.hideForNow + &quot;, finished: &quot; + a.mFinished); &#125; final int forwardBit = isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0; // If the window hasn&apos;t yet been added to the window manager, // and this guy didn&apos;t finish itself or start another activity, // then go ahead and add the window. boolean willBeVisible = !a.mStartedActivity; if (!willBeVisible) &#123; try &#123; willBeVisible = ActivityTaskManager.getService().willActivityBeVisible( a.getActivityToken()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; // 2. 获取window r.window = r.activity.getWindow(); // 3. 获取DecorView View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); // 4.获取Activity的WindowManager ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (r.mPreserveWindow) &#123; a.mWindowAdded = true; r.mPreserveWindow = false; // Normally the ViewRoot sets up callbacks with the Activity // in addView-&gt;ViewRootImpl#setView. If we are instead reusing // the decor view we have to notify the view root that the // callbacks may have changed. ViewRootImpl impl = decor.getViewRootImpl(); if (impl != null) &#123; impl.notifyChildRebuilt(); &#125; &#125; if (a.mVisibleFromClient) &#123; if (!a.mWindowAdded) &#123; a.mWindowAdded = true; // 5.调用WindowManager的addView方法 wm.addView(decor, l); &#125; else &#123; // The activity will get a callback for this &#123;@link LayoutParams&#125; change // earlier. However, at that time the decor will not be set (this is set // in this method), so no action will be taken. This call ensures the // callback occurs with the decor set. a.onWindowAttributesChanged(l); &#125; &#125; // If the window has already been added, but during resume // we started another activity, then don&apos;t yet make the // window visible. &#125; else if (!willBeVisible) &#123; if (localLOGV) Slog.v(TAG, &quot;Launch &quot; + r + &quot; mStartedActivity set&quot;); r.hideForNow = true; &#125; // Get rid of anything left hanging around. cleanUpPendingRemoveWindows(r, false /* force */); // The window is now visible if it has been added, we are not // simply finishing, and we are not starting another activity. if (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) &#123; if (r.newConfig != null) &#123; performConfigurationChangedForActivity(r, r.newConfig); if (DEBUG_CONFIGURATION) &#123; Slog.v(TAG, &quot;Resuming activity &quot; + r.activityInfo.name + &quot; with newConfig &quot; + r.activity.mCurrentConfig); &#125; r.newConfig = null; &#125; if (localLOGV) Slog.v(TAG, &quot;Resuming &quot; + r + &quot; with isForward=&quot; + isForward); ViewRootImpl impl = r.window.getDecorView().getViewRootImpl(); WindowManager.LayoutParams l = impl != null ? impl.mWindowAttributes : r.window.getAttributes(); if ((l.softInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != forwardBit) &#123; l.softInputMode = (l.softInputMode &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)) | forwardBit; if (r.activity.mVisibleFromClient) &#123; ViewManager wm = a.getWindowManager(); View decor = r.window.getDecorView(); wm.updateViewLayout(decor, l); &#125; &#125; r.activity.mVisibleFromServer = true; mNumVisibleActivities++; if (r.activity.mVisibleFromClient) &#123; r.activity.makeVisible(); &#125; &#125; r.nextIdle = mNewActivities; mNewActivities = r; if (localLOGV) Slog.v(TAG, &quot;Scheduling idle handler for &quot; + r); Looper.myQueue().addIdleHandler(new Idler()); &#125; public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow, int userId) &#123; if (view == null) &#123; throw new IllegalArgumentException(&quot;view must not be null&quot;); &#125; if (display == null) &#123; throw new IllegalArgumentException(&quot;display must not be null&quot;); &#125; if (!(params instanceof WindowManager.LayoutParams)) &#123; throw new IllegalArgumentException(&quot;Params must be WindowManager.LayoutParams&quot;); &#125; final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; if (parentWindow != null) &#123; parentWindow.adjustLayoutParamsForSubWindow(wparams); &#125; else &#123; // If there&apos;s no parent, then hardware acceleration for this view is // set from the application&apos;s hardware acceleration setting. final Context context = view.getContext(); if (context != null &amp;&amp; (context.getApplicationInfo().flags &amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != 0) &#123; wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED; &#125; &#125; ViewRootImpl root; View panelParentView = null; synchronized (mLock) &#123; // Start watching for system property changes. if (mSystemPropertyUpdater == null) &#123; mSystemPropertyUpdater = new Runnable() &#123; @Override public void run() &#123; synchronized (mLock) &#123; for (int i = mRoots.size() - 1; i &gt;= 0; --i) &#123; mRoots.get(i).loadSystemProperties(); &#125; &#125; &#125; &#125;; SystemProperties.addChangeCallback(mSystemPropertyUpdater); &#125; int index = findViewLocked(view, false); if (index &gt;= 0) &#123; if (mDyingViews.contains(view)) &#123; // Don&apos;t wait for MSG_DIE to make it&apos;s way through root&apos;s queue. mRoots.get(index).doDie(); &#125; else &#123; throw new IllegalStateException(&quot;View &quot; + view + &quot; has already been added to the window manager.&quot;); &#125; // The previous removeView() had not completed executing. Now it has. &#125; // If this is a panel window, then find the window it is being // attached to for future reference. if (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp; wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123; final int count = mViews.size(); for (int i = 0; i &lt; count; i++) &#123; if (mRoots.get(i).mWindow.asBinder() == wparams.token) &#123; panelParentView = mViews.get(i); &#125; &#125; &#125; root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); // do this last because it fires off messages to start doing things try &#123; // 6.调用viewRootImpl的setView方法 root.setView(view, wparams, panelParentView, userId); &#125; catch (RuntimeException e) &#123; // BadTokenException or InvalidDisplayException, clean up. if (index &gt;= 0) &#123; removeViewLocked(index, true); &#125; throw e; &#125; &#125; &#125; 从源码中可以看到，onResume 之后，ActivityThread 通过调用 activity 中 windowmanager 的 addView 方法，将 decorView 传入到 ViewRootImpl 的 setView 方法中，通过 setView 来完成 View 的绘制。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//接收的参数ViewRootImpl#setView 这里入参是DecorViewpublic void setView(View view, WindowManager.LayoutParams attrs, View panelParentView, int userId) &#123; .... // Schedule the first layout -before- adding to the window // manager, to make sure we do the relayout before receiving // any other events from the system. //检查绘制的的线程是不是创建View的线程 绘制View requestLayout(); ....@Overridepublic void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123; //线程检查 checkThread(); mLayoutRequested = true; //开始绘制 scheduleTraversals(); &#125;&#125;@UnsupportedAppUsagevoid scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; mTraversalScheduled = true; //获取内存屏障 mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); //执行绘制任务 mTraversalBarrier mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); &#125;&#125;void doTraversal() &#123; if (mTraversalScheduled) &#123; mTraversalScheduled = false; //移除内存屏障 mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); if (mProfile) &#123; Debug.startMethodTracing(&quot;ViewAncestor&quot;); &#125; //开始绘制 依次调用performMeasure performLayout performDraw performTraversals(); if (mProfile) &#123; Debug.stopMethodTracing(); mProfile = false; &#125; &#125;&#125; 简单来说 setView 做了三件事 检查绘制的线程是不是创建 View 的线程。这里可以引申出一个问题，View 的绘制必须在主线程吗？ 通过内存屏障保证绘制 View 的任务是最优先的 调用 performTraversals 完成 measure，layout，draw 的绘制 看到这里，ViewRootImpl 的绘制基本就完成了。其实这也是面试官希望听到的内容。考察的是面试者对 View 绘制体系的理解。 后续 ViewGroup 和 View 的绘制其实是 performTraversals 对整个 ViewTree 的绘制。他们的关系可以用下面这张图表示 那为什么我在 onCreate 中调用 View.post 方法可以得到 View 的宽高呢?1234567891011public boolean post(Runnable action) &#123; final AttachInfo attachInfo = mAttachInfo; if (attachInfo != null) &#123; return attachInfo.mHandler.post(action); &#125; // Postpone the runnable until we know on which thread it needs to run. // Assume that the runnable will be successfully placed after attach. getRunQueue().post(action); return true;&#125; View.post 会判断当前 View 是否已经被添加到 window 上。如果添加了则立即执行 runnable，如果没有被添加则先放到一个队列中存储起来，等添加到 window 上时再执行。 而 View 被测量完成后才会 attachToWindow。所以当 post 的 runnable 执行时，View 已经绘制完成了。 MeasureSpec 的理解 说说什么是 MeasureSpec？为什么测量宽高要用它作为参数呢？ View 的大小不仅仅取决于自身的宽高，还取决于父 View 的大小和测量模式。一个 200200 的父 View 是不可能容纳一个 300300 的子 View 的，父 View 的 wrap_content 和 match_content 也会影响子 View 的大小。 所以 View 的 measure 函数其实应该有 4 个参数：父 View 的宽，父 View 的高，宽的测量模式，高的测量模式。 Android 这里用了一个巧妙的设计，用一个 Int 值来表示宽/高的测量模式和大小。一个 int 有 32 位，前 2 位表示测量 MODE，后 30 位表示 SIZE。 为什么要用 2 位表示 MODE 呢？因为 MODE 只有 3 种呀，UNSPECIFIED，EXACTLY，AT_MOST 。 使用这个 View 时宽高传入 wrap_content，结果会怎么样？ 当我们自定义一个 View 时，如果继承的是 View，measure 方法走的就是 View 默认的逻辑 123456789101112131415161718192021protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125;public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; 所以当我们自定义 View 时，如果没有对 MODE 做处理，设置 wrap_content 和 match_content 结果其实是一样的，View 的宽高都是取父 View 的宽高。 invaliate 和 requestlayout 方法的区别? ViewRootImpl 作为顶级 View 负责 View 的绘制。所以简单来说，requestlayout 和 invaliate 最终都会向上回溯调用到 ViewRootImpl 的 postTranversals 方法来绘制 View。 不同的是 requestlayout 会绘制 View 的 measure，layout 和 draw 过程。invaliate 因为只添加了绘制 draw 的标志位，只会绘制 draw 过程。 实现一下 findViewbyid 的过程? 123456789101112131415View findViewById(int id)&#123; if(mId == id)return this; if(mVIew instanceof ViewGroup)&#123; int childrenCount = getChildrenCount(); for(int i = 0; i&lt;childrenCount;i++)&#123; View v = getchildAt(i)&#123; v = v.findViewById(id); if(v !=null)&#123; return v; &#125; &#125; &#125; &#125; return null;&#125;","categories":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"}]},{"title":"粘性事件的EventBus","slug":"粘性事件的EventBus","date":"2019-12-21T09:22:18.000Z","updated":"2021-10-21T13:24:12.592Z","comments":true,"path":"2019/12/21/粘性事件的EventBus/","link":"","permalink":"http://b.nearby.ren/2019/12/21/粘性事件的EventBus/","excerpt":"","text":"下午赶去公司解决了电台业务首次语音搜台后(用到服务,但只出一个独立的Activity,主界面并没有打开)不能听歌识曲的问题. 排查到最后,去识别的消息确实是发出去了,但是却没有收到,没有收到消息当然不会响应.最后,消息是通过EventBus.getDefault.post(xx)发出的,一定是发送和接收出现问题. 推测该问题是由于主界面还未创建,用于接收的EventBus还未注册,即发布者发了消息,但订阅者还未产生(一般消息的处理逻辑是先注册订阅,后接收),这样没有收到消息当然无法响应操作. 了解到,EventBus是支持发送黏性事件的。 粘性事件?何为黏性事件呢？简单讲，就是在发送事件之后再订阅该事件也能收到该事件。Android中就有这样的实例，也就是Sticky Broadcast，即粘性广播。正常情况下如果发送者发送了某个广播，而接收者在这个广播发送后才注册自己的Receiver，这时接收者便无法接收到 刚才的广播，为此Android引入了StickyBroadcast，在广播发送结束后会保存刚刚发送的广播（Intent），这样当接收者注册完 Receiver后就可以接收到刚才已经发布的广播。这就使得我们可以预先处理一些事件，让有消费者时再把这些事件投递给消费者. EventBus也提供了这样的功能，有所不同是EventBus会存储所有的Sticky事件，如果某个事件在不需要再存储则需要手动进行移除。用户通过Sticky的形式发布事件，而消费者也需要通过Sticky的形式进行注册，当然这种注册除了可以接收 Sticky事件之外和常规的注册功能是一样的，其他类型的事件也会被正常处理。 基本使用发布和接收粘性事件一般有如下几步: 1、粘性事件的发布: 1EventBus.getDefault().postSticky(&quot;nearby&quot;); 123456@Subscribe(threadMode = ThreadMode.MAIN, sticky = true) public void receiveSoundRecongnizedmsg(String insType) &#123; if (&quot;nearby&quot;.equals(insType)) &#123; soundRecognizeCtrl(); &#125; &#125; 剩下的操作就和普通事件一样注册和反注册即可. 手动获取和移除粘性事件（Getting and Removing sticky Events manually）正如你之前看到的，最近发布的粘性事件在其新订阅者注册后将会自动传递给新订阅者。但有时可能更方便手动检查粘性事件。有时我们也需要移除粘性事件，以免它在传递下去。 12345MessageEvent stickyEvent = EventBus.getDefault().getStickyEvent(MessageEvent.class);if(stickyEvent != null) &#123; EventBus.getDefault().removeStickyEvent(stickyEvent); //TODO&#125; removeStickyEvent 会返回之前持有的粘性事件。 于是, 1234MessageEvent stickyEvent = EventBus.getDefault().removeStickyEvent(MessageEvent.class);if(stickyEvent != null) &#123; //TODO&#125; 使用场景我们要把一个Event发送到一个还没有初始化的Activity/Fragment，即尚未订阅事件。那么如果只是简单的post一个事件，那么是无法收到的，这时候，你需要用到粘性事件,它可以帮你解决这类问题. 小结对于EventBus3.0来说,我还只是知道如何简单的使用,是知其然,不知其所以然,它是一个比较强大的事件总线库,后续会看下源码,慢慢分析一下,消息是如何发送和接收的.","categories":[{"name":"EventBus","slug":"EventBus","permalink":"http://b.nearby.ren/categories/EventBus/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://b.nearby.ren/tags/Android/"}]},{"title":"androidMVP架构模式","slug":"androidmvp架构模式","date":"2019-10-31T08:47:42.000Z","updated":"2021-10-03T02:38:56.682Z","comments":true,"path":"2019/10/31/androidmvp架构模式/","link":"","permalink":"http://b.nearby.ren/2019/10/31/androidmvp架构模式/","excerpt":"","text":"android MVP模式在Android项目中的使用 在开发当中我们会涉及到一些架构模式，对于初级程序员来说是很陌生，但是对于中级过渡高级的程序员来说是非常重要需要了解的模式。首先我们先了解有哪些架构模式：不管都前端，移动端，后端都会涉及到这三种：MVC、MVP、MVVM。概念：什么是MVPMVP是模型(Model)、视图(View)、主持人(Presenter)的缩写,分别代表项目中3个不同的模块。模型(Model):负责处理数据的加载或者存储，比如从网络或者本地数据库获取数据等；视图(View):负责界面数据的展示，与用户进行交互；主持人(Presenter):相当于协调者，是模型与视图之间的桥梁，将模型与视图分离开来。 如下图所示，View与Model并不直接交互，而是使用Presenter作为View与Model之间的桥梁。其中Presenter中同时持有View层以及Model层的Interface的引用，而View层持有Presenter层Ineterface的引用。当View层某个界面需要展示展示某些数据的时候，首先会调用Presenter层的某个接口，然后Presneter层会调用Model层请求数据，当Model层数据加载成功之后会调用Presenter层的回调方法通知Presenter层数据加载完毕，最后Presneter层再调用View层的接口将加载后的数据展示给用户。这就是Mvp模式的整个核心过程。 这样分层的好处就是大大减少了Model与View层之间的耦合度。一方面可以使得View层和Model层单独开发与测试，互不依赖。另一方面Model层可以封装复用，可以极大的减少代码量。当然，Mvp还有其他的一些优点。 12345678910111213141.View层 View层首页数据展示模块的组件是Activity，里面有一个RecycleView 布局如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;android.support.v7.widget.RecyclerView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/recycle_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:scrollbars=&quot;vertical&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; android:paddingTop=&quot;@dimen/card_margin&quot;&gt; &lt;/android.support.v7.widget.RecyclerView&gt; 首页列表模块主要展示从网络获取的首页列表信息，view层的接口大概需要如下方法：(1)请求数据的过程中需要提示‘正在加载’的反馈信息给用户(2)加载数据成功后，将加载得到的数据填充到RecycleView展示给用户(3)加载数据成功后，将提示‘正在加载’反馈信息取消掉(4)若加载数据失败，如网络连接、则需要给用户提示信息。 12345678910111213141516171819202122232425262728//业务接口 public interface HomeContract &#123; interface View &#123; void onLoading(); void onError(String error); void updateUI(XXX xxx); void ToastMessage(String message); &#125; interface Action extends IPresenter &#123; void requestHome(XXX... xxx); &#125; &#125; //业务处理请求 public class HomePresenter implements HomeContract.Action&#123; HomeContract.view view; public HomePresenter(HomeContract.view view)&#123; this.view =view; &#125; @Override pubublic void requestHome(XXX... xxx)&#123; //请求网络数据处理业务层 view.onLoading(); view.onError(); view.updateUI(); view.ToastMessage(); &#125; &#125; 首页列表Activity中实现上述接口： 12345678910111213141516171819202122232425public class HomeActivity extends AppCompatActivity implements HomeContract.view &#123; HomeContract.Action action; @Override public void onLoading()&#123; //提示加载信息 &#125; @Override public void onError(String error)&#123; //加载错误ui &#125; @Override public void updateUI(XXX xxx)&#123; //更新UI数据 &#125; @Override public void ToastMessage(String message)&#123; //网络请求结束提示信息 &#125; @Override public void onCreate(@Nullable Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); action = new HomePresenter(this); action.requestHome(xx); &#125; &#125; 当用户打开首页界面时，就请求网络获取数据，初始化Presenter引用实例，调用Presenter层的requestHome接口，业务处理完毕后，调用相应的onLoading()、onError()、updateUI()、ToastMessage()方法处理不同逻辑。","categories":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"},{"name":"mvp","slug":"mvp","permalink":"http://b.nearby.ren/tags/mvp/"}]},{"title":"Handler的同步屏障机制","slug":"什么是Handler的同步屏障机制","date":"2019-09-30T05:50:25.000Z","updated":"2021-08-01T10:24:49.955Z","comments":true,"path":"2019/09/30/什么是Handler的同步屏障机制/","link":"","permalink":"http://b.nearby.ren/2019/09/30/什么是Handler的同步屏障机制/","excerpt":"","text":"对于Handler机制，想必大家都已经非常熟悉了吧，从迈进Android开发这扇大门的时候，就不停的研究和使用它，同样的这也是Android系统架构的精髓之一。然而在我们使用的时候，往往会忽略掉一些不常见却又很重要的内容，今天就来讲一讲经常被忽略的同步屏障以及异步消息。 制流程中窥视handler同步屏障为了引出今天的主题，我们先来看看ui的渲染流程吧。在Android的绘制流程中，ViewRootImpl这个类发挥了非常重要的作用，首先我们看一下这个类中比较重要的一个方法requestLayout(),下面开始按这个思路分析源码，直接从入口开始： 12345678910@Overridepublic void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123; //校验主线程 checkThread(); mLayoutRequested = true; //调用这个方法启动绘制流程 scheduleTraversals(); &#125;&#125; requestLayout()中会通过checkThread()方法检查发起布局请求的线程是否为主线程（校验ViewRootImpl构造时记录的mThread， 和当前线程是否一致），之后，在调用scheduleTraversals()的时候 postSyncBarrier添加同步消息屏障 requestLayout()中会通过checkThread()方法检查发起布局请求的线程是否为主线程（校验ViewRootImpl构造时记录的mThread， 和当前线程是否一致），之后，在调用scheduleTraversals()的时候 postSyncBarrier添加同步消息屏障 1234567891011121314151617181920212223242526@UnsupportedAppUsage void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; mTraversalScheduled = true; //1. 往主线程的Handler对应的MessageQueue发送一个同步屏障消息 mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); //2.将mTraversalRunnable保存到Choreographer中 mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); if (!mUnbufferedInputDispatch) &#123; scheduleConsumeBatchedInput(); &#125; notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); &#125; &#125; ... //在doTraversal方法中移除同步消息屏障 void doTraversal() &#123; if (mTraversalScheduled) &#123; mTraversalScheduled = false; //移除同步屏障 mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); ... &#125; &#125; 在这个方法中，涉及到三个比较重要的信息 mTraversalRunnable Choreographer编舞者 同步屏障消息 首先看mTraversalRunnable，它的作用就是从ViewRootImpl 从上往下执行performMeasure、performLayout、performDraw。 Choreographer主要是为了配合Vsync信号，给上层app的渲染提供一个稳定的Message处理时机，也就是Vsync信号到来时，系统通过对Vsync信号的调整，来控制每一帧绘制操作的时机。当Vsync信号到来时，会往主线程的MessageQueue中插入一条异步消息，由于在scheduleTraversals中给MessageQueue中插入了同步屏障消息，那么当执行到同步屏障时，会取出异步消息执行。 看下Choreography中插入消息的方法是如何实现的： 123456789101112131415private void postCallbackDelayedInternal(int callbackType, Object action, Object token, long delayMillis) &#123; synchronized (mLock) &#123; ... if (dueTime &lt;= now) &#123; scheduleFrameLocked(now); &#125; else &#123; Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action); msg.arg1 = callbackType; //设置为异步消息 msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, dueTime); &#125; &#125; &#125; 通过以上的分析，我们知道了，在刷新ui的时候原来会有这么多的参与者，但是那些什么同步消息、异步消息、消息屏障又是些什么东西呢？接下来我们就来研究一下。 何为同步屏障？message分类 Handler的message分为三种 同步消息 异步消息 屏障消息 通常我们使用handler发送消息，都是使用默认的构造函数构造handler，然后使用send方法发送。这样发送的消息都是普通消息也就是同步消息，发出去的消息就会在MessageQueue中排队。异步消息正常情况下跟同步消息没有区别，只有在设置了同步屏障之后，才会出现差异。 同步屏障就是在消息队列中插入一个屏障，插入之后，所有的同步消息都会被屏蔽，不能被执行，但是异步消息却不受影响，可以继续执行。 插入消息屏障正常插入消息会调用enqueueMessage方法，同时将handler赋值给message的target。 1234567891011//将消息插入消息队列private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg, long uptimeMillis) &#123; msg.target = this; msg.workSourceUid = ThreadLocalWorkSource.getUid(); //进行判断是否将消息设置为异步消息 if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 在MessageQueue中进行判断，如果target为空也就是这个message没有对应的handler则会报异常。 123456789101112boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(&quot;Message must have a target.&quot;); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); &#125; ... // 如果需要唤醒，则唤醒 if (needWake) &#123; nativeWake(mPtr); &#125; 通过MessageQueue的postSyncBarrier方法插入屏障，message的target属性为null 12345678910111213141516171819202122232425private int postSyncBarrier(long when) &#123; synchronized (this) &#123; final int token = mNextBarrierToken++; //msg没有为target属性赋值 final Message msg = Message.obtain(); ... //根据时间插入到MessageQueue中 if (when != 0) &#123; while (p != null &amp;&amp; p.when &lt;= when) &#123; prev = p; p = p.next; &#125; &#125; if (prev != null) &#123; // invariant: p == prev.next msg.next = p; prev.next = msg; &#125; else &#123; msg.next = p; mMessages = msg; &#125; //返回一个序号，通过它可以对屏障消息进行撤销 return token; &#125; &#125; 经过以上的操作，我们可以总结出 屏障消息和普通消息的区别是屏障消息没有target属性，普通消息有target属性是因为要将消息分发给target指向的handler处理 屏障消息会插入到MessageQueue中合适的位置，这个消息以后的普通消息将被屏蔽 postSyncBarrier返回一个int类型的数值，通过这个数值可以撤销屏障 postSyncBarrier方法是私有的，如果我们想调用它就得使用反射 插入普通消息会唤醒消息队列，但是插入屏障不会 如何发送异步消息通常我们发送的都是普通消息，如果想发送异步消息 可以在创建handler时使用如下的构造器中的一种，同时将async参数设置为true，这样这个handler发送的消息就都是异步消息了。 1234567891011121314151617181920public Handler(boolean async) &#123; this(null, async);&#125;public Handler(@NonNull Looper looper, @Nullable Callback callback) &#123; this(looper, callback, false);&#125;public Handler(@Nullable Callback callback, boolean async) &#123; ... mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( &quot;Can&apos;t create handler inside thread &quot; + Thread.currentThread() + &quot; that has not called Looper.prepare()&quot;); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 除了这种方式还可以直接设置消息的类型为异步消息 1234567public void setAsynchronous(boolean async) &#123; if (async) &#123; flags |= FLAG_ASYNCHRONOUS; &#125; else &#123; flags &amp;= ~FLAG_ASYNCHRONOUS; &#125; &#125; 消息处理的过程MessageQueue是通过next方法来遍历消息的 1234567891011121314151617181920212223242526272829303132333435363738394041424344@UnsupportedAppUsage Message next() &#123; for (;;) &#123; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; Message msg = mMessages; //如果msg.target为空，也就是说是一个同步屏障消息，则进入这个判断里面 if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. //在这个while循环中，找到最近的一个异步消息 do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; //找到了异步消息 if (msg != null) &#123; //如果消息的处理时间小于当前时间 则等待 if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. //处理消息 mBlocked = false; //将异步消息移除 if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg); msg.markInUse(); //返回异步消息 return msg; &#125; &#125; else &#123; // No more messages. //没有找到异步消息则进入阻塞状态，等待被唤醒 nextPollTimeoutMillis = -1; &#125; ... &#125; 在这段代码中，可以看到，处理过程中会先判断此消息是否为屏障消息，如果是屏障消息，则去循环遍历，直到寻找到异步消息为止。通过这种方式跳过了普通消息，直接执行异步消息。也就是说同步屏障为handler消息机制提供了一种优先级策略，异步消息的优先级要高于同步消息。 另外需要注意的是：同步屏障不会自动移除，使用完成之后需要手动移除，不然会造成同步消息无法处理。也就是上边提到的，通过removeSyncBarrier(int token)方法进行移除，token就是之前添加屏障时返回的token。 1public void removeSyncBarrier(int token)&#123;&#125; 通过以上的分析，想必对于handler消息机制中的几种不同的消息有了一个更深入的了解了吧，对于绘制流程中，为什么要发送一个同步屏障并且发送异步消息，应该心中也有了答案，不错，就是为了让保证在vsync信号到来时，异步任务可以优先执行，从而绘制任务可以被及时执行，避免造成界面卡顿。","categories":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"}]},{"title":"getLocationInWindow和getLocationOnScreen的区别","slug":"getLocationInWindow和getLocationOnScreen的区别","date":"2019-09-21T04:13:18.000Z","updated":"2021-10-22T13:38:22.980Z","comments":true,"path":"2019/09/21/getLocationInWindow和getLocationOnScreen的区别/","link":"","permalink":"http://b.nearby.ren/2019/09/21/getLocationInWindow和getLocationOnScreen的区别/","excerpt":"","text":"一个控件在其父窗口中的坐标位置View.getLocationInWindow(int[] location) 一个控件在其整个屏幕上的坐标位置View.getLocationOnScreen(int[] location) getLocationInWindow是以B为原点的C的坐标getLocationOnScreen以A为原点。下面是getLocationOnScreen示例 下面是getLocationOnScreen示例12345start = (Button) findViewById(R.id.start);int []location=new int[2];start.getLocationOnScreen(location);int x=location[0];//获取当前位置的横坐标int y=location[1];//获取当前位置的纵坐标 getLocationOnScreen 的源码123456789public void getLocationOnScreen(@Size(2) int[] outLocation) &#123; getLocationInWindow(outLocation); final AttachInfo info = mAttachInfo; if (info != null) &#123; outLocation[0] += info.mWindowLeft; outLocation[1] += info.mWindowTop; &#125;&#125; 下面是getLocationInWindow示例12345start = (Button) findViewById(R.id.start);int []location=new int[2];start.getLocationInWindow(location);int x=location[0];//获取当前位置的横坐标int y=location[1];//获取当前位置的纵坐标 getLocationInWindow 的源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public void getLocationInWindow(@Size(2) int[] outLocation) &#123; if (outLocation == null || outLocation.length &lt; 2) &#123; throw new IllegalArgumentException(&quot;outLocation must be an array of two integers&quot;); &#125; outLocation[0] = 0; outLocation[1] = 0; transformFromViewToWindowSpace(outLocation);&#125;public void transformFromViewToWindowSpace(@Size(2) int[] inOutLocation) &#123; if (inOutLocation == null || inOutLocation.length &lt; 2) &#123; throw new IllegalArgumentException(&quot;inOutLocation must be an array of two integers&quot;); &#125; if (mAttachInfo == null) &#123; // When the view is not attached to a window, this method does not make sense inOutLocation[0] = inOutLocation[1] = 0; return; &#125; float position[] = mAttachInfo.mTmpTransformLocation; position[0] = inOutLocation[0]; position[1] = inOutLocation[1]; if (!hasIdentityMatrix()) &#123; getMatrix().mapPoints(position); &#125; position[0] += mLeft; position[1] += mTop; ViewParent viewParent = mParent; while (viewParent instanceof View) &#123; final View view = (View) viewParent; position[0] -= view.mScrollX; position[1] -= view.mScrollY; if (!view.hasIdentityMatrix()) &#123; view.getMatrix().mapPoints(position); &#125; position[0] += view.mLeft; position[1] += view.mTop; viewParent = view.mParent; &#125; if (viewParent instanceof ViewRootImpl) &#123; // *cough* final ViewRootImpl vr = (ViewRootImpl) viewParent; position[1] -= vr.mCurScrollY; &#125; inOutLocation[0] = Math.round(position[0]); inOutLocation[1] = Math.round(position[1]); &#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://b.nearby.ren/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://b.nearby.ren/tags/Android/"}]},{"title":"Leakcanary原理浅析","slug":"Leakcanary原理浅析","date":"2019-09-17T12:31:28.000Z","updated":"2021-08-01T08:55:01.379Z","comments":true,"path":"2019/09/17/Leakcanary原理浅析/","link":"","permalink":"http://b.nearby.ren/2019/09/17/Leakcanary原理浅析/","excerpt":"","text":"LeakCanary是Android内存泄漏的框架，作为一个“面试常见问题”，它一定有值得学习的地方，今天我们就讲一下它。作为一名开发，我觉得给人讲框架或者库的原理，最好先把大概思路给读者讲一下，这样读者后面会按照这个框架往里填内容，理解起来也更容易一些，所以我先把LeakCanary的大致原理放出来： 其思路大致为：监听Activity生命周期-&gt;onDestroy以后延迟5秒判断Activity有没有被回收-&gt;如果没有回收,调用GC，再此判断是否回收，如果还没回收，则内存泄露了，反之，没有泄露。整个框架最核心的问题就是在什么时间点如何判断一个Activity是否被回收了。 下面开始按这个思路分析源码，直接从入口开始： 12345public static RefWatcher install(Application application) &#123; return refWatcher(application).listenerServiceClass(DisplayLeakService.class) .excludedRefs(AndroidExcludedRefs.createAppDefaults().build()) .buildAndInstall();&#125; builder模式构建了一个RefWatcher对象,listenerServiceClass()方法绑定了一个后台服务DisplayLeakService 这个服务主要用来分析内存泄漏结果并发送通知。你可以继承并重写这个类来进行一些自定义操作，比如上传分析结果等。 我们看最后buildAndInstall()方法： 12345678public RefWatcher buildAndInstall() &#123; RefWatcher refWatcher = build(); if (refWatcher != DISABLED) &#123; LeakCanary.enableDisplayLeakActivity(context); ActivityRefWatcher.installOnIcsPlus((Application) context, refWatcher); &#125; return refWatcher;&#125; build()方法，这个方法主要是配置一些东西，先大概了解一下，后面用到再说，下面是几个配置项目。 watchExecutor : 线程控制器，在 onDestroy()之后并且主线程空闲时执行内存泄漏检测 debuggerControl : 判断是否处于调试模式，调试模式中不会进行内存泄漏检测 gcTrigger : 用于GC watchExecutor 首次检测到可能的内存泄漏，会主动进行GC,GC之后会再检测一次，仍然泄漏的判定为内存泄漏，进行后续操作 heapDumper : dump内存泄漏处的heap信息，写入hprof文件 heapDumpListener : 解析完hprof文件并通知DisplayLeakService弹出提醒 excludedRefs : 排除可以忽略的泄漏路径 LeakCanary.enableDisplayLeakActivity(context)这行代码主要是为了开启LeakCanary的应用，显示其图标. 接下来是重点： ActivityRefWatcher.installOnIcsPlus((Application) context, refWatcher) 它会进入： 12ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher);activityRefWatcher.watchActivities(); 接下来：12stopWatchingActivities();application.registerActivityLifecycleCallbacks(lifecycleCallbacks); 第一行代码是为了确保不会重复绑定，第二行绑定生命周期，之后监听Activity的生命周期。123@Override public void onActivityDestroyed(Activity activity) &#123; ActivityRefWatcher.this.onActivityDestroyed(activity);&#125; 监听到Activity销毁时执行onActivityDestroyed方法,进入看看：1234567891011121314public void watch(Object watchedReference, String referenceName) &#123; if (this == DISABLED) &#123; return; &#125; checkNotNull(watchedReference, &quot;watchedReference&quot;); checkNotNull(referenceName, &quot;referenceName&quot;); final long watchStartNanoTime = System.nanoTime(); String key = UUID.randomUUID().toString(); retainedKeys.add(key); final KeyedWeakReference reference = new KeyedWeakReference(watchedReference, key, referenceName, queue); ensureGoneAsync(watchStartNanoTime, reference); &#125; 整个LeakCanary最核心的思路就在这儿了。 前面几行是这样的，根据Activity生成一个随机Key,并将Key加入到一个Set中，然后讲key，activity传如一个包装的弱引用里。 这里引出了第一个知识点，弱引用和引用队列ReferenceQueue联合使用时，如果弱引用持有的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。即 KeyedWeakReference持有的Activity对象如果被垃圾回收，该对象就会加入到引用队列queue,我们看看RefreceQueue的javadoc： 12345678/** * Reference queues, to which registered reference objects are appended by the * garbage collector after the appropriate reachability changes are detected. * * @author Mark Reinhold * @since 1.2 */public class ReferenceQueue&lt;T&gt; 证实了上面的说法,另外看名字我们就知道，不光弱引用，软和虚引用也可以这样做。 重点是最后一句:ensureGoneAsyc，看字面意思，异步确保消失。这里我们先不看代码，如果要自己设计一套检测方案的话，怎么想？其实很简单，就是在Activiy onDestroy以后，我们等一会，检测一下这个Acitivity有没有被回收,那么问题来了，什么时候检测？怎么检测？这也是本框架的核心和难点。 LeakCanary是这么做的：onDestroy以后，一旦主线程空闲下来，延时5秒执行一个任务：先判断Activity有没有被回收？如果已经回收了，说明没有内存泄漏，如果还没回收，我们进一步确认，手动触发一下gc，然后再判断有没有回收，如果这次还没回收，说明Activity确实泄漏了，接下来把泄漏的信息展示给开发者就好了。 思路其实挺清晰的，我们看代码实现：1234567private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakReference reference) &#123; watchExecutor.execute(new Retryable() &#123; @Override public Retryable.Result run() &#123; return ensureGone(reference, watchStartNanoTime); &#125; &#125;); &#125; 这里watchExecutor是AndroidWatchExecutor,看代码：1234567@Override public void execute(Retryable retryable) &#123; if (Looper.getMainLooper().getThread() == Thread.currentThread()) &#123; waitForIdle(retryable, 0); &#125; else &#123; postWaitForIdle(retryable, 0); &#125;&#125; 主线程和子线程其实一样，都要到主线程中执行， 123456789 void waitForIdle(final Retryable retryable, final int failedAttempts) &#123; // This needs to be called from the main thread. Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() &#123; @Override public boolean queueIdle() &#123; postToBackgroundWithDelay(retryable, failedAttempts); return false; &#125; &#125;);&#125; 这里有第二个知识点，IdleHandler，这个东西是干嘛的，其实看名字就知道了，就是当主线程空闲的时候，如果设置了这个东西，就会执行它的queueIdle()方法，所以这个方法就是在onDestory以后，一旦主线程空闲了，就会执行，然后我们看它执行了啥： 12345678910111213 private void postToBackgroundWithDelay(final Retryable retryable, final int failedAttempts) &#123; long exponentialBackoffFactor = (long) Math.min(Math.pow(2, failedAttempts), maxBackoffFactor); long delayMillis = initialDelayMillis * exponentialBackoffFactor; backgroundHandler.postDelayed(new Runnable() &#123; @Override public void run() &#123; Retryable.Result result = retryable.run(); if (result == RETRY) &#123; postWaitForIdle(retryable, failedAttempts + 1); &#125; &#125; &#125;, delayMillis); &#125;&#125; 很简单，延时5秒执行retryable的run()，注意，因为这里是backgroundHandler post出来的，所以是下面的run是在子线程执行的。这里的retryable就是前面传过来的: 1234567private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakReference reference) &#123; watchExecutor.execute(new Retryable() &#123; @Override public Retryable.Result run() &#123; return ensureGone(reference, watchStartNanoTime); &#125; &#125;);&#125; ensureGone(reference,watchStartNanoTime),在看它干了啥之前，我们先理一下思路，前面onDestory以后，AndroidWatchExecutor这个东西执行excute方法，这个方法让主线程在空闲的时候发送了一个延时任务，该任务会在5秒延时后在一个子线程执行。理清了思路，我们看看这个任务是怎么执行的。12345678910111213141516171819202122232425262728293031Retryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) &#123; long gcStartNanoTime = System.nanoTime(); long watchDurationMs = NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime); removeWeaklyReachableReferences(); if (debuggerControl.isDebuggerAttached()) &#123; // The debugger can create false leaks. return RETRY; &#125; if (gone(reference)) &#123; return DONE; &#125; gcTrigger.runGc(); removeWeaklyReachableReferences(); if (!gone(reference)) &#123; long startDumpHeap = System.nanoTime(); long gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime); File heapDumpFile = heapDumper.dumpHeap(); if (heapDumpFile == RETRY_LATER) &#123; // Could not dump the heap. return RETRY; &#125; long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap); heapdumpListener.analyze( new HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs, watchDurationMs, gcDurationMs, heapDumpDurationMs)); &#125; return DONE; &#125; 前面我们说过思路了，5秒延迟后先看看有没有回收，如果回收了，直接返回，没有发生内存泄漏，如果没有回收，触发GC，gc完成后，在此判断有没有回收，如果还没回收，说明泄漏了，收集泄漏信息，展示给开发者。而上面的代码完全按照这个思路来的。其中，removeWeaklyRechableReferences()和gone(reference)这两个方法配合，用来判断对象是否被回收了,看代码： 12345678 private void removeWeaklyReachableReferences() &#123; // WeakReferences are enqueued as soon as the object to which they point to becomes weakly // reachable. This is before finalization or garbage collection has actually happened. KeyedWeakReference ref; while ((ref = (KeyedWeakReference) queue.poll()) != null) &#123; retainedKeys.remove(ref.key); &#125;&#125; 通过知识点1知道：被回收的对象都会放到设置的引用队列queue中,我们从queue中拿出所有的ref，根据他们的key匹配retainedKeys集合中的元素并删除。然后在gone()函数里面判断key是否被移除.123private boolean gone(KeyedWeakReference reference) &#123; return !retainedKeys.contains(reference.key); &#125; 这个方法挺巧妙的，retainedKeys集合了所有destoryed了的但没有被回收的Activity的key，这个集合可以用来判断一个Activity有没有被回收，但是判断之前需要用removeWeaklyReachableReferences()这个方法更新一下。 一旦一个Activity检测出泄漏了，就收集泄漏信息然后通过前面配置的DisplayLeakService通知给用户并展示在DisplayLeakActivity中，后面的东西都是UI展示东西，就不是本文的重点了，有兴趣的可以自己查看。 稍微总结一下，我觉得这个框架中用到的一个很重要但冷门技巧就是弱引用的构造方法：传入一个RefrenceQueue，可以记录被垃圾回收的对象引用。说个题外话，一个对象都被回收了，他的弱引用咋办，总不能一直留着吧，（引用本身也是一个强引用对象，不要把引用和引用的对象搞混了，对象可以被回收了，但是它的引用，包括软，弱，虚引用都可以继续存在）。完全不用担心，这个引用在无用之后也会被GC回收的。","categories":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"},{"name":"Leakcanary","slug":"Leakcanary","permalink":"http://b.nearby.ren/tags/Leakcanary/"}]},{"title":"MAC /usr/local 文件夹权限问题","slug":"MAC文件夹权限问题","date":"2019-03-22T04:28:11.000Z","updated":"2019-10-05T07:50:24.999Z","comments":true,"path":"2019/03/22/MAC文件夹权限问题/","link":"","permalink":"http://b.nearby.ren/2019/03/22/MAC文件夹权限问题/","excerpt":"","text":"修改文件夹权限sudo chown -R $(whoami) /usr/local/ 如果失败提示Operation not permitted 或其他权限不足，则需要关闭Rootless Rootless 苹果从 OS X El Capitan 10.11 系统开始使用了 Rootless 机制，系统默认将会锁定 /system、/sbin、/usr 这三个目录。用户要获取这三个目录的写权限，需要关闭Rootless 关闭Rootless 重启 Mac 开机时后按下 Command+R，进入恢复模式。 在上面的菜单实用工具中找到并打开 Terminal 输入如下命令： 1csrutil disable 重启MAC，正常进入系统，此时已经可以给/system、/sbin、/usr 者几个目录进行权限更改 打开 Terminal 输入如下命令： 1sudo chown -R $(whoami) /usr/local","categories":[{"name":"mac","slug":"mac","permalink":"http://b.nearby.ren/categories/mac/"}],"tags":[{"name":"Mac/Linux","slug":"Mac-Linux","permalink":"http://b.nearby.ren/tags/Mac-Linux/"}]},{"title":"GoToken学习","slug":"GoToken学习","date":"2019-03-03T10:53:55.000Z","updated":"2021-07-24T08:56:59.442Z","comments":true,"path":"2019/03/03/GoToken学习/","link":"","permalink":"http://b.nearby.ren/2019/03/03/GoToken学习/","excerpt":"","text":"基本数据结构上面是签名的使用例子，下面分析签名的源码实现，首先看下数据结构Token，包含了我们标准中说道的三部分：头部，载荷和签名，此外还带了一个用于存储生成token的字段Raw和校验标识符Valid12345678910// A JWT Token. Different fields will be used depending on whether you&apos;re// creating or parsing/verifying a token.type Token struct &#123; Raw string // The raw token. Populated when you Parse a token Method SigningMethod // The signing method used or to be used Header map[string]interface&#123;&#125; // The first segment of the token Claims Claims // The second segment of the token Signature string // The third segment of the token. Populated when you Parse a token Valid bool // Is the token valid? Populated when you Parse/Verify a token&#125; 看下载荷，多了一个字段Audience123456789101112// Structured version of Claims Section, as referenced at// https://tools.ietf.org/html/rfc7519#section-4.1// See examples for how to use this with your own claim typestype StandardClaims struct &#123; Audience string `json:&quot;aud,omitempty&quot;` ExpiresAt int64 `json:&quot;exp,omitempty&quot;` Id string `json:&quot;jti,omitempty&quot;` IssuedAt int64 `json:&quot;iat,omitempty&quot;` Issuer string `json:&quot;iss,omitempty&quot;` NotBefore int64 `json:&quot;nbf,omitempty&quot;` Subject string `json:&quot;sub,omitempty&quot;`&#125; API介绍初始化API提供了两个API，一个只需提供加密方法，一个需要提供加密方法和载荷结构对象123456789101112131415// Create a new Token. Takes a signing methodfunc New(method SigningMethod) *Token &#123; return NewWithClaims(method, MapClaims&#123;&#125;)&#125; func NewWithClaims(method SigningMethod, claims Claims) *Token &#123; return &amp;Token&#123; Header: map[string]interface&#123;&#125;&#123; &quot;typ&quot;: &quot;JWT&quot;, &quot;alg&quot;: method.Alg(), &#125;, Claims: claims, Method: method, &#125;&#125; 生成签名API如标准所说，主要是将头部和载荷部分的结构对象转化为json格式，然后用base64编码，然后用’.’号连接，然后使用指定加密方法生成签名，再与前面的头部和载荷用’.’号连接1234567891011121314// Get the complete, signed tokenfunc (t *Token) SignedString(key interface&#123;&#125;) (string, error) &#123; var sig, sstr string var err error //把头部和载荷转化为json格式，base64编码之后用&apos;.&apos;号连接起来 if sstr, err = t.SigningString(); err != nil &#123; return &quot;&quot;, err &#125; //使用指定的加密方法生成签名 if sig, err = t.Method.Sign(sstr, key); err != nil &#123; return &quot;&quot;, err &#125; return strings.Join([]string&#123;sstr, sig&#125;, &quot;.&quot;), nil&#125; 头部和载荷数据结构对象的处理： 1234567891011121314151617181920212223// Generate the signing string. This is the// most expensive part of the whole deal. Unless you// need this for something special, just go straight for// the SignedString.func (t *Token) SigningString() (string, error) &#123; var err error parts := make([]string, 2) for i, _ := range parts &#123; var jsonValue []byte if i == 0 &#123; if jsonValue, err = json.Marshal(t.Header); err != nil &#123; return &quot;&quot;, err &#125; &#125; else &#123; if jsonValue, err = json.Marshal(t.Claims); err != nil &#123; return &quot;&quot;, err &#125; &#125; parts[i] = EncodeSegment(jsonValue) &#125; return strings.Join(parts, &quot;.&quot;), nil&#125; 校验API检验Token基本就是生成Token的逆过程了，也提供了两个API： 12345678910// Parse, validate, and return a token.// keyFunc will receive the parsed token and should return the key for validating.// If everything is kosher, err will be nilfunc Parse(tokenString string, keyFunc Keyfunc) (*Token, error) &#123; return new(Parser).Parse(tokenString, keyFunc)&#125; func ParseWithClaims(tokenString string, claims Claims, keyFunc Keyfunc) (*Token, error) &#123; return new(Parser).ParseWithClaims(tokenString, claims, keyFunc)&#125;","categories":[{"name":"go","slug":"go","permalink":"http://b.nearby.ren/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://b.nearby.ren/tags/go/"}]},{"title":"什么是TPS，什么是QPS，区别是什么？","slug":"TPS和QPS区别","date":"2018-12-31T05:55:20.000Z","updated":"2019-07-14T02:17:07.425Z","comments":true,"path":"2018/12/31/TPS和QPS区别/","link":"","permalink":"http://b.nearby.ren/2018/12/31/TPS和QPS区别/","excerpt":"","text":"一、TPS：Transactions Per Second（每秒传输的事物处理个数），即服务器美妙处理的事务数。TPS包括一条消息入和一条消息出，加上一次与数据库访问。（业务TPS=CAPS传*每次呼叫的平均TPS）TPS是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后我服务器作出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来算计算使用的时间和完成的事务个数。 一般的评价系统性能均以每秒钟完成的技术交易的数量来衡量，系统整体处理能力取决于处理能力最低模块的TPS值。 二、QPS：每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。对应fetches/sec，即每秒的响应请求数，也即是最大的吞吐能力。","categories":[{"name":"软件","slug":"软件","permalink":"http://b.nearby.ren/categories/软件/"}],"tags":[{"name":"软件名词","slug":"软件名词","permalink":"http://b.nearby.ren/tags/软件名词/"}]},{"title":"JWT实现用户认证原理与实现[golang]","slug":"JWT实现用户认证原理与实现[golang]","date":"2018-12-28T05:48:20.000Z","updated":"2019-10-05T10:31:46.321Z","comments":true,"path":"2018/12/28/JWT实现用户认证原理与实现[golang]/","link":"","permalink":"http://b.nearby.ren/2018/12/28/JWT实现用户认证原理与实现[golang]/","excerpt":"","text":"1 JWT标准规范JWT（JSON Web Token）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。 一个JWT由三部分组成，头部、载荷与签名。 JWT原理类似我们加盖公章或手写签名的的过程，合同上写了很多条款，不是随便一张纸随便写啥都可以的，必须要一些证明，比如签名，比如盖章。JWT就是通过附加签名，保证传输过来的信息是真的，而不是伪造的。 头部：用于说明签名的加密算法等，下面类型的json经过base64编码后得到JWT头部 1234&#123; &quot;typ&quot;: &quot;JWT&quot;, &quot;alg&quot;: &quot;HS256&quot;&#125; 载荷：包含生成Token时间，过期时间，以及一些身份标识,标准定义了6个字段，载荷json经过base64编码后得到JWT的载荷： sub: 该JWT所面向的用户 iss: 该JWT的签发者 iat(issued at): 在什么时候签发的token exp(expires): token什么时候过期 nbf(not before)：token在此时间之前不能被接收处理 jti：JWT ID为web token提供唯一标识 例子：12345678&#123; &quot;sub&quot;: &quot;1&quot;, &quot;iss&quot;: &quot;http://localhost:8000/user/sign_up&quot;, &quot;iat&quot;: 1451888119, &quot;exp&quot;: 1454516119, &quot;nbf&quot;: 1451888119, &quot;jti&quot;: &quot;37c107e4609ddbcc9c096ea5ee76c667&quot;&#125; 签名：将头部和载荷用’.’号连接，再加上一串密钥，经过头部声明的加密算法加密后得到签名 123456HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) JWT TokenToken=头部+’.’+载荷+’.’+签名 2 代码实现实现代码来之开源项目https://github.com/dgrijalva/jwt-go 使用例子Token生成：12345678910111213141516171819var( key []byte = []byte(&quot;Hello World！This is secret!&quot;))// 产生json web tokenfunc GenToken() string &#123; claims := &amp;jwt.StandardClaims&#123; NotBefore: int64(time.Now().Unix()), ExpiresAt: int64(time.Now().Unix() + 1000), Issuer: &quot;Bitch&quot;, &#125; token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims) ss, err := token.SignedString(key) if err != nil &#123; logs.Error(err) return &quot;&quot; &#125; return ss&#125; 检验Token：1234567891011// 校验token是否有效func CheckToken(token string) bool &#123; _, err := jwt.Parse(token, func(*jwt.Token) (interface&#123;&#125;, error) &#123; return key, nil &#125;) if err != nil &#123; fmt.Println(&quot;parase with claims failed.&quot;, err) return false &#125; return true&#125; 基本数据结构上面是签名的使用例子，下面分析签名的源码实现，首先看下数据结构Token，包含了我们标准中说道的三部分：头部，载荷和签名，此外还带了一个用于存储生成token的字段Raw和校验标识符Valid 12345678910// A JWT Token. Different fields will be used depending on whether you&apos;re// creating or parsing/verifying a token.type Token struct &#123; Raw string // The raw token. Populated when you Parse a token Method SigningMethod // The signing method used or to be used Header map[string]interface&#123;&#125; // The first segment of the token Claims Claims // The second segment of the token Signature string // The third segment of the token. Populated when you Parse a token Valid bool // Is the token valid? Populated when you Parse/Verify a token&#125; 看下载荷，多了一个字段Audience 123456789101112// Structured version of Claims Section, as referenced at// https://tools.ietf.org/html/rfc7519#section-4.1// See examples for how to use this with your own claim typestype StandardClaims struct &#123; Audience string `json:&quot;aud,omitempty&quot;` ExpiresAt int64 `json:&quot;exp,omitempty&quot;` Id string `json:&quot;jti,omitempty&quot;` IssuedAt int64 `json:&quot;iat,omitempty&quot;` Issuer string `json:&quot;iss,omitempty&quot;` NotBefore int64 `json:&quot;nbf,omitempty&quot;` Subject string `json:&quot;sub,omitempty&quot;`&#125; API介绍初始化API提供了两个API，一个只需提供加密方法，一个需要提供加密方法和载荷结构对象123456789101112131415// Create a new Token. Takes a signing methodfunc New(method SigningMethod) *Token &#123; return NewWithClaims(method, MapClaims&#123;&#125;)&#125; func NewWithClaims(method SigningMethod, claims Claims) *Token &#123; return &amp;Token&#123; Header: map[string]interface&#123;&#125;&#123; &quot;typ&quot;: &quot;JWT&quot;, &quot;alg&quot;: method.Alg(), &#125;, Claims: claims, Method: method, &#125;&#125; 生成签名API如标准所说，主要是将头部和载荷部分的结构对象转化为json格式，然后用base64编码，然后用’.’号连接，然后使用指定加密方法生成签名，再与前面的头部和载荷用’.’号连接 1234567891011121314// Get the complete, signed tokenfunc (t *Token) SignedString(key interface&#123;&#125;) (string, error) &#123; var sig, sstr string var err error //把头部和载荷转化为json格式，base64编码之后用&apos;.&apos;号连接起来 if sstr, err = t.SigningString(); err != nil &#123; return &quot;&quot;, err &#125; //使用指定的加密方法生成签名 if sig, err = t.Method.Sign(sstr, key); err != nil &#123; return &quot;&quot;, err &#125; return strings.Join([]string&#123;sstr, sig&#125;, &quot;.&quot;), nil&#125; 头部和载荷数据结构对象的处理： 1234567891011121314151617181920212223// Generate the signing string. This is the// most expensive part of the whole deal. Unless you// need this for something special, just go straight for// the SignedString.func (t *Token) SigningString() (string, error) &#123; var err error parts := make([]string, 2) for i, _ := range parts &#123; var jsonValue []byte if i == 0 &#123; if jsonValue, err = json.Marshal(t.Header); err != nil &#123; return &quot;&quot;, err &#125; &#125; else &#123; if jsonValue, err = json.Marshal(t.Claims); err != nil &#123; return &quot;&quot;, err &#125; &#125; parts[i] = EncodeSegment(jsonValue) &#125; return strings.Join(parts, &quot;.&quot;), nil&#125; 校验API检验Token基本就是生成Token的逆过程了，也提供了两个API： 1234567891011// Parse, validate, and return a token.// keyFunc will receive the parsed token and should return the key for validating.// If everything is kosher, err will be nilfunc Parse(tokenString string, keyFunc Keyfunc) (*Token, error) &#123; return new(Parser).Parse(tokenString, keyFunc)&#125; func ParseWithClaims(tokenString string, claims Claims, keyFunc Keyfunc) (*Token, error) &#123; return new(Parser).ParseWithClaims(tokenString, claims, keyFunc)&#125;","categories":[{"name":"mac","slug":"mac","permalink":"http://b.nearby.ren/categories/mac/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://b.nearby.ren/tags/golang/"}]},{"title":"Android各种Background","slug":"Android各种Background","date":"2018-11-21T04:22:18.000Z","updated":"2021-10-21T13:17:34.420Z","comments":true,"path":"2018/11/21/Android各种Background/","link":"","permalink":"http://b.nearby.ren/2018/11/21/Android各种Background/","excerpt":"","text":"setBackground、setBackgroundDrawable、setBackgroundResource、setBackgroundColor 的区别在 Android 开发中，我们常常遇到对 View 组件的背景颜色或者背景图片进行一些动态的设置。那么常见的这四种方法往往分不清楚，下面我们来看下它们之间的不同之处。1.setBackground(Drawable background) 方法的参数是一个Drawable对象.该方法用于设置view组件的背景图片。其中 Drawable 对象可以这样获取: 1Drawable background = getResources().getDrawable(R.drawable.xxx); 2.setBackgroundDrawable(Drawable background) 方法跟setBackground大体相同。 3.setBackgroundResource(int resId) 方法的参数是一个组件的id值。该方法也是用于加载组件的背景图片的。 4.setBackgroundColor(Color.XXX) 方法参数为一个 Color 类的静态常量，它是用来设置背景颜色的方法。 我们在动态设置背景颜色或图片时，有可能该背景颜色有圆角，如果我们直接设置背景颜色，那么原先的圆角就会没有了。所以，如果背景颜色有圆角的话，就不能直接设置了。我们使用如下的方法解决。 12345Drawable drawable = tv.getBackground();if (null != drawable &amp;&amp; drawable instanceof GradientDrawable) &#123; // 这种情况是设置了带shape的背景颜色 ((GradientDrawable)drawable).setColor(Color.GREEN);&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://b.nearby.ren/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://b.nearby.ren/tags/Android/"}]},{"title":"android EditText 延迟搜索","slug":"两种方式实现延迟搜索","date":"2018-11-08T03:52:03.000Z","updated":"2019-07-14T08:49:03.685Z","comments":true,"path":"2018/11/08/两种方式实现延迟搜索/","link":"","permalink":"http://b.nearby.ren/2018/11/08/两种方式实现延迟搜索/","excerpt":"","text":"1.Handler2.RxJava #Handler监听EditText的输入，每当文本变化，先检查Handler当前有无未处理的消息，有则移除该消息，然后用sendEmptyMessageDelayed再发哟天延迟消息，如果文本超过延迟时间没有变化，该延迟消息就可以成功执行。 #例：12345678910111213141516171819202122232425262728293031private final int RC_SEARCH = 1;private final int INTERVAL = 300; //输入时间间隔为300毫秒private EditText mEtHandler;private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; if (msg.what == RC_SEARCH) &#123; handlerSearch(); &#125; &#125; &#125;;mEtHandler.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; &#125; @Override public void afterTextChanged(Editable s) &#123; if (mHandler.hasMessages(RC_SEARCH)) &#123; mHandler.removeMessages(RC_SEARCH); &#125; mHandler.sendEmptyMessageDelayed(RC_SEARCH, INTERVAL); &#125; &#125;); #RxJava学习了RxJava后发现还有更简便的方法，即使用debounce操作符处理不断产生的文本变化事件 debounce操作符对源Observable每产生一个结果后，如果在规定的间隔时间内没有别的结果产生，则吧这个结果提交给订阅者处理，否则忽略结果。 1234567891011121314151617181920212223private EditText mEtRxJava;private final int INTERVAL = 300; //输入时间间隔为300毫秒RxTextView.textChangeEvents(mEtRxJava) .debounce(INTERVAL, TimeUnit.MILLISECONDS) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;TextViewTextChangeEvent&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(TextViewTextChangeEvent textViewTextChangeEvent) &#123; rxJavaSearch(); &#125; &#125;);","categories":[{"name":"延迟搜索","slug":"延迟搜索","permalink":"http://b.nearby.ren/categories/延迟搜索/"}],"tags":[{"name":"延迟","slug":"延迟","permalink":"http://b.nearby.ren/tags/延迟/"}]},{"title":"Go语言中 new()和make()的区别详解","slug":"Go语言中 new()和make()的区别详解","date":"2018-10-06T10:30:12.000Z","updated":"2019-04-14T07:50:25.393Z","comments":true,"path":"2018/10/06/Go语言中 new()和make()的区别详解/","link":"","permalink":"http://b.nearby.ren/2018/10/06/Go语言中 new()和make()的区别详解/","excerpt":"","text":"#概述Go语言中的new和make 一直是新手比较容易混淆的东西，咋一看很相似，接下来我们来分析两者的区别 #new的主要特性 首先new是内建函数，你可以从 http://golang.org/pkg/builtin/#new 这儿看到它，它的定义也很简单： 12代码如下：func new(Type) *Type 官方文档对于它的描述是： 内建函数new用来分配内存，它的第一个参数是类型，不是一个值，它的返回值是一个指向新分配类型零值的指针 根据这段描述，我们可以自己实现一个类似的new的功能123456代码如下：func newInt() *Int&#123; var i int return &amp;i &#125;someint :=newInt() 这个函数的功能跟 someInt :=new(int) 一摸一样，所以在我们自定义new开头的函数时，出于约定应该返回类型的指针。 #make的主要特性 make也是内建函数，你可以从http://golang.org/pkg/builtin/#make 这儿看到它，它的定义比 new 多了一个参数，返回值也不同： 12代码如下：func make(Type,size INtergerType)Type 官方文档对于它的描述是： 内建函数make用来为slie ，map 或 chan 类型分配内存和初始化一个对象(注意：只能用在这三种类型上)，跟new类似，第一个参数也是一个类型而不是一个值，跟new不同的是，make返回的类型的引用而不是指针，而返回值也依赖于具体传入的类型，具体说明如下： 代码如下： Slice ：第二个参数size指定了它的长度，它的容易和长度相同。你可以传入第三个参数来指定不同的容量值，但必须不能长度值小。比如 make([]int,0,10)Map:根据size大小来初始化分配内存，不过分配后的map长度为0，如果size被忽略了，那么会在初始化分配内存时分配一个小尺寸的内存Channel：管道缓冲区依据缓冲区容量被初始化。如果容量为0或者忽略容量。管道是没有缓冲区的 总结 new 的作用是初始化一个指向类型的指针(*T)，make 的作用是为 slice，map 或 chan 初始化并返回引用(T)。","categories":[{"name":"go","slug":"go","permalink":"http://b.nearby.ren/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://b.nearby.ren/tags/go/"}]},{"title":"Go语言中 new()和make()的区别详解","slug":"sync.WaitGroup使用说明的副本","date":"2018-10-06T10:30:12.000Z","updated":"2021-07-24T08:56:44.459Z","comments":true,"path":"2018/10/06/sync.WaitGroup使用说明的副本/","link":"","permalink":"http://b.nearby.ren/2018/10/06/sync.WaitGroup使用说明的副本/","excerpt":"","text":"#概述Go语言中的new和make 一直是新手比较容易混淆的东西，咋一看很相似，接下来我们来分析两者的区别 #new的主要特性 首先new是内建函数，你可以从 http://golang.org/pkg/builtin/#new 这儿看到它，它的定义也很简单： 12代码如下：func new(Type) *Type 官方文档对于它的描述是： 内建函数new用来分配内存，它的第一个参数是类型，不是一个值，它的返回值是一个指向新分配类型零值的指针 根据这段描述，我们可以自己实现一个类似的new的功能123456代码如下：func newInt() *Int&#123; var i int return &amp;i &#125;someint :=newInt() 这个函数的功能跟 someInt :=new(int) 一摸一样，所以在我们自定义new开头的函数时，出于约定应该返回类型的指针。 #make的主要特性 make也是内建函数，你可以从http://golang.org/pkg/builtin/#make 这儿看到它，它的定义比 new 多了一个参数，返回值也不同： 12代码如下：func make(Type,size INtergerType)Type 官方文档对于它的描述是： 内建函数make用来为slie ，map 或 chan 类型分配内存和初始化一个对象(注意：只能用在这三种类型上)，跟new类似，第一个参数也是一个类型而不是一个值，跟new不同的是，make返回的类型的引用而不是指针，而返回值也依赖于具体传入的类型，具体说明如下： 代码如下： Slice ：第二个参数size指定了它的长度，它的容易和长度相同。你可以传入第三个参数来指定不同的容量值，但必须不能长度值小。比如 make([]int,0,10)Map:根据size大小来初始化分配内存，不过分配后的map长度为0，如果size被忽略了，那么会在初始化分配内存时分配一个小尺寸的内存Channel：管道缓冲区依据缓冲区容量被初始化。如果容量为0或者忽略容量。管道是没有缓冲区的 总结 new 的作用是初始化一个指向类型的指针(*T)，make 的作用是为 slice，map 或 chan 初始化并返回引用(T)。","categories":[{"name":"go","slug":"go","permalink":"http://b.nearby.ren/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://b.nearby.ren/tags/go/"}]},{"title":"Go sync包 WaitGroup使用","slug":"sync.WaitGroup使用说明","date":"2018-10-05T08:30:12.000Z","updated":"2021-07-24T08:56:40.073Z","comments":true,"path":"2018/10/05/sync.WaitGroup使用说明/","link":"","permalink":"http://b.nearby.ren/2018/10/05/sync.WaitGroup使用说明/","excerpt":"","text":"sync.WaitGroup用途：它能够一直等到所有的goroutine执行完成，并且阻塞主线程的执行，直到所有的goroutine执行完成注意：它们的执行结果有没有顺序的，调度器不能保证多个goroutine执行次序，且进程退出时不会等待它们结束。 waiGroup共有三个方法：Add(delta int)Done()Wait()Add:添加或者减少等待goroutine的数量Done：相当于Add(-1)Wait:执行阻塞，知道直到所有的WaitGroutine数量变成0 123456789101112131415161718192021222324package mainimport ( &quot;sync&quot; &quot;time&quot; &quot;fmt&quot;)func main() &#123; var wg sync.WaitGroup for i := 0; i &gt; 5; i = i + 1 &#123; wg.Add(1) go func(n int) &#123; defer wg.Add(-1) EchoNumber(n) &#125;(i) &#125; wg.Wait()&#125;func EchoNumber(i int) &#123; time.Sleep(3e9) fmt.Println(i)&#125; golang中的同步是通过sync.WaitGroup来实现的，WaitGroup的功能：它实现了一个类似队列的结构，可以一直向队列添加任务，当任务完成后便从队列中删除，如果队列中的任务没有完全完成，可以通过Wait()函数来出发阻塞，防止程序继续进行，直到所有的队列任务都完成为止。WaitGroup的特点是Wait()可以用来阻塞直到队列中的所有任务都完成才解除阻塞，而不需要Sleep一个固定的时间来等待，但是其缺点是无法指定固定的goroutine数目，可能通过使用channel解决此问题。 1234567891011121314151617181920212223242526package mainimport ( &quot;fmt&quot; &quot;sync&quot;)var waitgroup sync.WaitGroupfunc Afunction(shownum int) &#123; fmt.Println(shownum) //任务队列，将任务队列中的任务数量-1，其实.Done就是.Add(-1) waitgroup.Done()&#125;func main() &#123; for i := 0; i &lt; 10; i++ &#123; //每创建一个goroutine，就把任务队列中的任务的数量+1 waitgroup.Add(1) go Afunction(i) &#125; //.Wait()这里发生阻塞，直到队列中所有的任务结束就会解除阻塞 waitgroup.Wait()&#125;","categories":[{"name":"go","slug":"go","permalink":"http://b.nearby.ren/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://b.nearby.ren/tags/go/"}]},{"title":"Go sync包 WaitGroup使用","slug":"Go sync包 WaitGroup使用","date":"2018-10-05T08:30:12.000Z","updated":"2019-04-10T14:08:54.595Z","comments":true,"path":"2018/10/05/Go sync包 WaitGroup使用/","link":"","permalink":"http://b.nearby.ren/2018/10/05/Go sync包 WaitGroup使用/","excerpt":"","text":"sync.WaitGroup用途：它能够一直等到所有的goroutine执行完成，并且阻塞主线程的执行，直到所有的goroutine执行完成注意：它们的执行结果有没有顺序的，调度器不能保证多个goroutine执行次序，且进程退出时不会等待它们结束。 waiGroup共有三个方法：Add(delta int)Done()Wait()Add:添加或者减少等待goroutine的数量Done：相当于Add(-1)Wait:执行阻塞，知道直到所有的WaitGroutine数量变成0 123456789101112131415161718192021222324package mainimport ( &quot;sync&quot; &quot;time&quot; &quot;fmt&quot;)func main() &#123; var wg sync.WaitGroup for i := 0; i &gt; 5; i = i + 1 &#123; wg.Add(1) go func(n int) &#123; defer wg.Add(-1) EchoNumber(n) &#125;(i) &#125; wg.Wait()&#125;func EchoNumber(i int) &#123; time.Sleep(3e9) fmt.Println(i)&#125; golang中的同步是通过sync.WaitGroup来实现的，WaitGroup的功能：它实现了一个类似队列的结构，可以一直向队列添加任务，当任务完成后便从队列中删除，如果队列中的任务没有完全完成，可以通过Wait()函数来出发阻塞，防止程序继续进行，直到所有的队列任务都完成为止。WaitGroup的特点是Wait()可以用来阻塞直到队列中的所有任务都完成才解除阻塞，而不需要Sleep一个固定的时间来等待，但是其缺点是无法指定固定的goroutine数目，可能通过使用channel解决此问题。 1234567891011121314151617181920212223242526package mainimport ( &quot;fmt&quot; &quot;sync&quot;)var waitgroup sync.WaitGroupfunc Afunction(shownum int) &#123; fmt.Println(shownum) //任务队列，将任务队列中的任务数量-1，其实.Done就是.Add(-1) waitgroup.Done()&#125;func main() &#123; for i := 0; i &lt; 10; i++ &#123; //每创建一个goroutine，就把任务队列中的任务的数量+1 waitgroup.Add(1) go Afunction(i) &#125; //.Wait()这里发生阻塞，直到队列中所有的任务结束就会解除阻塞 waitgroup.Wait()&#125;","categories":[{"name":"go","slug":"go","permalink":"http://b.nearby.ren/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://b.nearby.ren/tags/go/"}]},{"title":"android studio升级之后很多jar无法下载 解决","slug":"android studio升级之后很多jar无法下载 解决","date":"2018-09-08T08:03:12.000Z","updated":"2019-05-19T04:01:30.463Z","comments":true,"path":"2018/09/08/android studio升级之后很多jar无法下载 解决/","link":"","permalink":"http://b.nearby.ren/2018/09/08/android studio升级之后很多jar无法下载 解决/","excerpt":"","text":"解决方案12345678910111213141516171819buildscript &#123; repositories &#123; maven&#123; url &apos;http://maven.aliyun.com/nexus/content/groups/public/&apos;&#125; &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:3.2.1&apos; &#125;&#125; allprojects &#123; repositories &#123; maven&#123; url &apos;http://maven.aliyun.com/nexus/content/groups/public/&apos;&#125; &#125;&#125; task clean(type: Delete) &#123; delete rootProject.buildDir&#125;","categories":[{"name":"android studio","slug":"android-studio","permalink":"http://b.nearby.ren/categories/android-studio/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://b.nearby.ren/tags/mac/"}]},{"title":"mac android studio 无线调试","slug":"mac android studio 无线调试","date":"2018-09-05T08:30:12.000Z","updated":"2019-04-10T13:31:43.711Z","comments":true,"path":"2018/09/05/mac android studio 无线调试/","link":"","permalink":"http://b.nearby.ren/2018/09/05/mac android studio 无线调试/","excerpt":"","text":"1.打开Android studio 的 如下图：1.点开{1}Plugins.在{2}输入 wifi adb ultimate 点击{3}蓝色的英文字符会弹出一个框。点击{4}会提示重新启动ndroid studio，点击重新启动就好。2.重新打开Android studio后 将手机数据连接笔记本电脑如下图：如果无法设备，点击刷新稍等片刻。3.点击运行后，拔掉数据线即可无线调试了。我没有拔掉数据线所以在 Select Deployment Tagrget 有两处选择。","categories":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"}]},{"title":"adorid仅有一个设备，如何做好屏幕适配","slug":"adorid仅有一个设备，如何做好屏幕适配","date":"2018-08-05T05:30:12.000Z","updated":"2019-07-20T10:19:55.682Z","comments":true,"path":"2018/08/05/adorid仅有一个设备，如何做好屏幕适配/","link":"","permalink":"http://b.nearby.ren/2018/08/05/adorid仅有一个设备，如何做好屏幕适配/","excerpt":"当你只有一个设备的时候，如何做好屏幕适配一、多机型 UI 适配在 Android 开发的工作日常中，UI 适配是一件比较重要的事情。一般开发新的功能，有新的页面，最终开发完成发布之前，都需要让设计师来审 UI 效果。而有时候，明明我们已经在一款标准的 3 倍手机上，做到了让设计师小姐姐满意的效果，但是当换了另外一台手机的时候，效果又不那么如意。传统的做法是，拿到效果不对的手机，单独适配看看是不是哪里布局写的不对导致效果不正确，然后改正它。但是总能碰到我们拿不到真实设备的情况。本文就介绍一个命令，可以修改你当前设备的参数，来模拟出目标设备的显示效果，让你独立就把多机型 UI 效果确认的事情给做了。 二、WM 命令2.1 什么是 WM 命令说的这么厉害，实际上需要使用的就是一行 wm 命令，可以通过 adb shell 来操作它。 wm 命令主要用来帮助我们修改一些屏幕的参数，先来看看它的文档。使用 adb shell wm 命令，可以方便的查看 wm 的文档描述 可以看到，wm 命令可以帮助我们修改当前设备的 size 、 density 等参数，而这两个参数就是决定了当前设备的显示效果。","text":"当你只有一个设备的时候，如何做好屏幕适配一、多机型 UI 适配在 Android 开发的工作日常中，UI 适配是一件比较重要的事情。一般开发新的功能，有新的页面，最终开发完成发布之前，都需要让设计师来审 UI 效果。而有时候，明明我们已经在一款标准的 3 倍手机上，做到了让设计师小姐姐满意的效果，但是当换了另外一台手机的时候，效果又不那么如意。传统的做法是，拿到效果不对的手机，单独适配看看是不是哪里布局写的不对导致效果不正确，然后改正它。但是总能碰到我们拿不到真实设备的情况。本文就介绍一个命令，可以修改你当前设备的参数，来模拟出目标设备的显示效果，让你独立就把多机型 UI 效果确认的事情给做了。 二、WM 命令2.1 什么是 WM 命令说的这么厉害，实际上需要使用的就是一行 wm 命令，可以通过 adb shell 来操作它。 wm 命令主要用来帮助我们修改一些屏幕的参数，先来看看它的文档。使用 adb shell wm 命令，可以方便的查看 wm 的文档描述 可以看到，wm 命令可以帮助我们修改当前设备的 size 、 density 等参数，而这两个参数就是决定了当前设备的显示效果。 2.2 WM 的命令从上面的文档可以看出，它其实支持的命令还是挺多的，但是有一些根本用不上，是需要系统权限的，所以正常来说我们是无法使用的。那么，还是介绍几个比较实用的命令。 以下例子都是在一款标准 density 为 3 的设备上运行的，屏幕像素为 1080px * 1920px。 1、wm sizewm size 命令，可以用来查询和修改当前设备的尺寸，如果想要修改尺寸，可以使用 px 或者 dp 为单位（默认为 px），使用 x 进行连接，这个其实看看 wm size 的输出，你就清楚了。 在这里的例子中，做了几件事情： 1.使用 wm size 命令查看当前设备的尺寸。2.使用 wm size 命令将当前尺寸修改成了 1000x2000。3.再次使用 wm size 命令查看当前设备的尺寸。4.最后使用 wm size reset 命令，将屏幕尺寸还原。5.再用 wm size 命令，查看还原后的尺寸。 这几个步骤就已经涵盖了 wm size 命令的所有使用步骤，可以使用它查看当前屏幕尺寸，并且修改屏幕尺寸和还原它。 2、wm densitywm density 命令，可以用来查看和修改当前设备的 density 参数。 使用起来很简单，直接上命令了。 在这个例子中，我做了几件事情： 1.使用 wm density 查看当前设备的 density。2.在使用 wm density 命令，修改当前设备的 density 为 420。3.然后再使用 wm density 查看修改后的参数。4.最后使用 wm density reset 将设备的 density 还原。5.最后再查看一下还原后的值。 3、wm overscanwm overscan 命令，可以修改当前设备的屏幕内边距。其实我觉得这个命令没什么用处，但是还是演示一下如何使用。 在这个例子中，做了几件事情： 1.使用 wm overscan 修改边距为 20 。2.然后使用 wm overscan reset 将其还原。 2.3 WM 命令的原理wm 命令的逻辑非常的简单，它实际上是和 WindowManagerService 进行交互，通过 WMS 来修改屏幕相关的一些参数。这里就不介绍完整的 wm 源码了，就以一个方法举例来看看 wm 的逻辑。这里就以 wm size 命令举例好了。首先，看看 wm 命令的入口。 这里会初始化 mWm ，并且根据输入的参数，调用不同的方法，如果输入的是 size ，则会调用 runDisplaySize() 方法。 在 runDisplaySize() 方法中，会先判断 size 命令后面有没有跟其它参数，如果没有，则认为是一次查询操作，会将查询到的结果输出。而如果是 reset 方法的话，就将 w 、h 这两个代表宽高的值，设置为 -1，最终会通过 mWm.clearForcedDisplaySize() 方法，将屏幕的 size 还原。否者就从输入的参数中，通过 x 进行分割，拿到我们输入的宽高。最终通过 mWm.setForcedDisplaySize() 方法，将当前屏幕的 size 修改成我们输入的结果。在设置size 的时候，还会通过 parseDimens() 方法，重新计算一下输入的尺寸。 从这里可以看出，它支持两个尺寸，px 和 dp ，如果如果不指定尺寸，则默认认为是 px 。 到这里就完成了一次通过 wm size 命令，修改设备屏幕参数的全过程，跟多细节可以自行查阅源码。 源码的在线地址：http://androidxref.com/7.1.1_r6/xref/frameworks/base/cmds/wm/src/com/android/commands/wm/Wm.java 三、实施修改设备参数既然已经讲清楚 wm 命令的所有细节了，那么我们只需要拿到我们需要适配的设备的 size 和 density。就可以在我们自己的设备上模拟出对应的效果。我这里收集了一些比较常用的设备参数，可以供大家参考一下。 魅族MX3：440，1080x1800一加5：420，1080x1920红米NOTE，320，720x1280华为MATE7，480，1080x1812MOTO-G5，480，1080x1920Moto-tx1095，432，1080x1790Nexus5x，420，1080x1794Nexus6p，560，1440x2392奇酷360，460，1080x1920VivoX5，320，720x1280 当然，最重要的是拿到公司各种 CEO、CTO、CxO 正在使用的手机参数，进行一波适配，哈哈。 下面，我们随便挑两个设备的参数进行修改，然后看看运行后的效果。 命令如下: // 修改成 一加5adb shell wm density 420adb shell wm size 1080x1920// 修改成 Moto-tx1095adb shell wm density 432adb shell wm size 1080x1790 下面，从做到右，分别是原本的尺寸、一加5、Moto-tx1095。 其实看着差异不大，只能说桌面布局写的挺好的，所以说，如果布局写的好的话，是可以避免在不同设备上看着很明显的不同的问题 ，就像现在这样。 四、题外话实际上 wm 命令，也是有一些其它问题的，例如有时候通过 wm 命令修改 UI 的的时候，刷新会不及时，会卡顿，所以选择一个性能比较好的手机是一个缓解的办法。或者修改参数之后，退出 App 重新进也是一个不错的办法。如果调整到一个太特殊的参数，例如 200x1000 这种，可能渲染起来会很奇怪。但是如果只是做一些常规设备参数的修改，只要修改值在合理的范围内，一般都是可以的。","categories":[{"name":"适配","slug":"适配","permalink":"http://b.nearby.ren/categories/适配/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"}]},{"title":"linxu安装python3","slug":"linxu安装python3","date":"2018-05-22T03:53:55.000Z","updated":"2021-10-03T02:44:15.182Z","comments":true,"path":"2018/05/22/linxu安装python3/","link":"","permalink":"http://b.nearby.ren/2018/05/22/linxu安装python3/","excerpt":"","text":"1.首先来看一下系统版本12[root@python3 ~]# cat /etc/redhat-releaseCentOS Linux release 7.6.1810 (Core) 2.更新一下yum源，yum源我这里用的都是阿里云的源12345[root@python3 ~]# cd /etc/yum.repos.d/[root@python3 yum.repos.d]# mkdir bak[root@python3 yum.repos.d]# mv * bak[root@python3 yum.repos.d]# wget http://mirrors.aliyun.com/repo/Centos-7.repo[root@python3 yum.repos.d]# wget http://mirrors.aliyun.com/repo/epel-7.repo 3.安装python3.7之前需要先安装一些依赖，，这也是上面更新yum源的原因123456[root@python3 ~]# yum -y install zlib-devel bzip2-devel openssl-devel openssl-static ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel [root@python3 ~]# yum -y groupinstall &quot;Development tools&quot;CentOS Linux release 7.6.1810 (Core)[root@python3 ~]# cat /etc/redhat-releaseCentOS Linux release 7.6.1810 (Core)[root@python3 ~]# cat /etc/redhat-releaseCentOS Linux release 7.6.1810 (Core) 4.下载python3.7安装包，方法很多，我这里直接用wget从官网上下载12[root@python3 ~]# cd /usr/local/src/[root@python3 src]# wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tar.xz 将安装包下载到/usr/local/src/目录下 5.解压&amp;&amp;移动123[root@python3 src]# tar xvf Python-3.7.0.tar.xz[root@python3 src]# mv Python-3.7.0 /usr/local/python-3.7[root@python3 src]# cd /usr/local/python-3.7/ 6.安装&amp;&amp;编译1[root@python3 python-3.7]# ./configure --prefix=/usr/local/sbin/python-3.7 将python3.7安装到/usr/local/sbin/python-3.7目录下 1234[root@python3 python-3.7]# make &amp;&amp; make install安装完成后，若出现以下两行，说明安装成功；Installing collected packages: setuptools, pipSuccessfully installed pip-10.0.1 setuptools-39.0.1 7.安装成功之后就能使用了123456789[root@python3 python-3.7]# /usr/local/sbin/python-3.7/bin/python3Python 3.7.0 (default, Mar 15 2019, 00:44:37)[GCC 4.8.5 20150623 (Red Hat 4.8.5-36)] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt;【此处退出的命令 exit()】虽然能用了，但是命令较长使用起来并不方便,we konw 系统本身是带的有python的，看一下版本[root@python3 ~]# python -VPython 2.7.5 8.看一下python命令的绝对路径123456789101112[root@python3 ~]# which python/usr/bin/python[root@python3 ~]# ll /usr/bin/ |grep python-rwxr-xr-x. 1 root root 11312 Nov 14 00:00 abrt-action-analyze-pythonlrwxrwxrwx. 1 root root 7 Mar 14 18:19 python -&gt; python2lrwxrwxrwx. 1 root root 9 Mar 14 18:19 python2 -&gt; python2.7-rwxr-xr-x. 1 root root 7216 Oct 31 07:46 python2.7 可以看到python命令是通过软链接连接到python2.7的，[做运维的小年轻]那我们现在安装了python3.7，是不是可以将python命令做一个软链接链接到python3，答案是肯定的昂。 9.将python命令通过软链接指向到python3命令（就是上面那一大串/usr/local/sbin/python-3.7/bin/python3）123456789101112[root@python3 ~]# rm -rf /usr/bin/python[root@python3 ~]# ln -sv /usr/local/sbin/python-3.7/bin/python3 /usr/bin/python‘/usr/bin/python’ -&gt; ‘/usr/local/sbin/python-3.7/bin/python3’[root@python3 ~]# ll /usr/bin/ |grep python-rwxr-xr-x. 1 root root 11312 Nov 14 00:00 abrt-action-analyze-pythonlrwxrwxrwx. 1 root root 38 Mar 14 19:24 python -&gt; /usr/local/sbin/python-3.7/bin/python3lrwxrwxrwx. 1 root root 9 Mar 14 18:19 python2 -&gt; python2.7-rwxr-xr-x. 1 root root 7216 Oct 31 07:46 python2.7 10.查看现在的默认版本12[root@python3 ~]# python -VPython 3.7.0 11.修改完python默认版本之后，会存不能执行yum命令，需要做一些修改，如下：①将/usr/bin/yum的顶部的： vim !/usr/bin/python 改成 !/usr/bin/python2.7 ②将/usr/libexec/urlgrabber-ext-down的顶部的： vim /usr/bin/python 改为 /usr/bin/python2.7 ③将/usr/bin/yum-config-manager的顶部的 12.最后将pip指向到python3.71234[root@python3 ~]# ln -s /usr/local/sbin/python-3.7/bin/pip3 /usr/bin/pip 或者 ln -sf /usr/local/sbin/python-3.7/bin/pip3 /usr/bin/pip[root@python3 ~]# pip --versionpip 10.0.1 from /usr/local/sbin/python-3.7/lib/python3.7/site-packages/pip (python 3.7)","categories":[{"name":"linxu","slug":"linxu","permalink":"http://b.nearby.ren/categories/linxu/"}],"tags":[{"name":"linxu","slug":"linxu","permalink":"http://b.nearby.ren/tags/linxu/"}]},{"title":"分享常用的GoLang包工具","slug":"分享常用的GoLang包工具","date":"2018-03-31T10:53:55.000Z","updated":"2021-06-03T14:06:33.203Z","comments":true,"path":"2018/03/31/分享常用的GoLang包工具/","link":"","permalink":"http://b.nearby.ren/2018/03/31/分享常用的GoLang包工具/","excerpt":"","text":"包名 链接地址 备注machinery异步队列 https://github.com/RichardKnop/machineryMqtt通信 https://github.com/eclipse/paho.mqtt.golang go文档http://www.eclipse.org/paho/clients/golang/微信开发 https://github.com/chanxuehong/wechatfasthttp包 https://github.com/valyala/fasthttp数据库操作包 https://github.com/gocraft/dbrmysql db链式操作 https://github.com/gohouse/goroseglide包管理工具 https://zhuanlan.zhihu.com/p/27994151文件配置包 https://github.com/spf13/vipercli应用执行程序包 https://github.com/spf13/cobraredis包 命令式操作 https://github.com/garyburd/redigo/redisredis包 便捷操作 https://github.com/go-redis/redis日志包 https://www.jianshu.com/p/5fac8bed4505日志包 https://github.com/zbindenren/logrus_mail 邮件通知logrus的hooks日志包 https://go.uber.org/zap https://go.uber.org/zap/zapcore https://gopkg.in/natefinch/lumberjack.v2gin Api文档包 https://github.com/swaggo/gin-swaggergovalidator 参数验证器 https://github.com/asaskevich/govalidatorjson编解码库 https://github.com/json-iterator/gojson web token https://github.com/dgrijalva/jwt-go类型转换 https://github.com/Unknwon/com优雅的重启Http服务 https://github.com/fvbock/endless 目前只支持linux环境下使用，零时间重启。权限控制 https://github.com/mikespook/gorbacWebSocket包 https://github.com/gorilla/websocket定时任务包 https://github.com/robfig/cronCloudXNS-DDNS https://github.com/zwh8800/cloudxns-ddns 动态域名客户端 docker 镜像Restful和gprc相互转换 https://github.com/grpc-ecosystem/grpc-gateway example =&gt; https://github.com/go-up/go-exampleproto构建Go代码工具 https://github.com/tuneinc/truss 用于RPC协议文档生成Api网关 https://github.com/fagongzi/gatewayGO直播服务器 https://github.com/gwuhaolin/livegoRabbitMQ包 https://github.com/streadway/amqpgin中文文档 https://github.com/skybebe/gin-doc-cnhttp限流 https://github.com/didip/tollboothORM包 https://github.com/go-sql-driver/mysqlTCP网络编程框架 https://github.com/leesper/holmes https://github.com/leesper/taoweb框架 https://github.com/gin-gonic/gin数据结构的可视化 https://github.com/Arafatk/DataViz生成图 https://github.com/awalterschulze/gographviz与任何json交互 https://github.com/bitly/go-simplejson现代文本索引Go库，类似于lucene。 https://github.com/blevesearch/bleveGoogle 的一个开源图(Graph)数据库， https://github.com/cayleygraph/cayleygraph 其灵感来自于 Freebase 和 Google 的 Knowledge Graph 背后的图数据库。top工具 https://github.com/cjbassi/gotop golang重写的top工具，界面简洁、功能强大缓存库 https://github.com/coocood/freecache 无额外的 GC 负荷。数百万对象的垃圾收集延迟仅在数百毫秒特性： 可存储数以百万计条 零垃圾收集负荷 高并发而且线程安全的访问 近乎 LRU 的算法* 严格限制内存使用高可用的分布式key-value存储， https://github.com/coreos/etcd 可以用于配置共享和服务发现；类似于zookeeper和consul；提供restful的http接口，使用简单；基于raft算法的强一致性、高可用的服务存储目录。可视化工具 https://github.com/davecheney/httpstat 可以测试http状态的可视化工具，通过这个工具可以看出来http响应信息。包括dns解析、tcp连接等信息,httpstat一共有golang版本和python版本。调试工具 https://github.com/derekparker/delve Devle是一个非常棒的golang 调试工具，支持多种调试方式，直接运行调试，或者attach到一个正在运行中的golang程序，进行调试。基本数据结构与算法的实现。 https://github.com/floyernick/Data-Structures-and-Algorithms将ASCII图转换成手绘图。 https://github.com/esimov/diagram模拟鼠标键盘事件、截屏等 https://github.com/go-vgo/robotgopackr 方便的潜入静态资源文件到golang 二进制文件中 https://github.com/gobuffalo/packrgit服务器。 https://github.com/gogits/gogs从源码中提取json结构。 https://github.com/newhook/go-symbolsgo源码编写vim工具。 https://github.com/mdempsky/gocode消息队列。 https://github.com/nsqio/nsqgolang对于es操作库。 https://github.com/olivere/elastic支持类似于jQuery的功能。 https://github.com/PuerkitoBio/goqueryjavascript解析器。 https://github.com/robertkrimen/otto从go源码中查找符号表信息。 https://github.com/rogpeppe/godef嵌入式数据库sqlite相关go操作。 https://github.com/rqlite/rqlite从源码生成uml图，支持C++, Java, Python, Ruby and C#。 https://github.com/ruben2020/tags2umlZookeeper Golang客户端 https://github.com/samuel/go-zookeepergolang调试、测试使用，可以用来打印任何结构。 https://github.com/sanity-io/litter机器基本信息仪表盘。 https://github.com/senorprogrammer/wtfgolang操作kafka库。 https://github.com/Shopify/sarama日志框架。 https://github.com/Sirupsen/logrusCLI命令行 https://github.com/spf13/cobra Cobra既是一个用来创建强大的现代CLI命令行的golang库，也是一个生成程序应用和命令行文件的程序。Hugo是由Go语言实现的静态网站生成器。 https://github.com/spf13/hugo 简单、易用、高效、易扩展、快速部署。配置文件操作库。 https://github.com/spf13/viper多机器之间的同步工具。 https://github.com/syncthing/syncthinggolang操作leveldb，一个本地数据库，高效kv。 https://github.com/syndtr/goleveldb Leveldb是一个google实现的非常高效的kv数据库，目前的版本1.2能够支持billion级别的数据量了。LevelDB 只是一个 C/C++ 编程语言的库, 不包含网络服务封装。生成golang调用关系图。 https://github.com/TrueFurby/go-callvisweb框架。 https://github.com/urfave/negroni生成图表库。 https://github.com/vdobler/chart序列化反序列化工具，类似于pb。 https://github.com/vmihailenco/msgpack生成图表库。 https://github.com/wcharczuk/go-chartaccess Kafka metadata in Zookeeper https://github.com/wvanbergen/kazoo-go补充返回值。 https://github.com/sqs/goreturns","categories":[{"name":"go","slug":"go","permalink":"http://b.nearby.ren/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://b.nearby.ren/tags/go/"}]},{"title":"Flutter Widget 之旅","slug":"Flutter Widget 之旅","date":"2018-03-05T08:30:12.000Z","updated":"2019-04-10T14:25:42.486Z","comments":true,"path":"2018/03/05/Flutter Widget 之旅/","link":"","permalink":"http://b.nearby.ren/2018/03/05/Flutter Widget 之旅/","excerpt":"","text":"flutter 程序入口 ：1234567891011import &apos;package:flutter/material.dart&apos;;void main() &#123; runApp( new Center( child: new Text( &apos;Hello, world!&apos;, textDirection: TextDirection.ltr, ), ), );&#125; 基本的小部件： 1.Text：在应用程序中可以构建一个文本信息展示 2.Row、Cloumn：水平布局(Row)与垂直布局(Column)方向上创建灵活的布局。其设计基于网络的Flexbox布局模型。 3.Stack：绘制顺序上堆叠小部件(类似 android RelativeLayout),您可以根据Positioned在子布局使用该小部件 , Stack相对于堆栈的顶部 , 右侧 , 底部或左侧边缘定位他们。堆栈基于Web的绝对定位布局模型。 4.Container：创建矩形视觉元素。一个容器可以装饰一个 BoxDecoration , 如背景 ,边框或阴影。也可以具有边距 , 填充 和 应用于其大小的约束。也可以矩阵在三维空间进行变换 5.Scaffold：实现了基本的纸墨设计布局结构。MaterialApp的child是Scaffold Widget。支持 左边栏(Drawers) , snack bars , 以及bottom sheets。 Scaffold 有下面几个主要属性： appBar：显示在界面顶部的一个AppBar,也就是android中的ActionBar、Toolbar body：当前界面所显示的主要内容Widget floatingActionButton：纸墨设计中所定义的FAB,界面的主要功能按钮 persistentFooterButtons：固定在下方显示的按钮,比如对话框下方的确定、取消按钮 drawer：侧边栏控件 backgroundColor：内容的背景颜色,模拟热使用的是ThemeData.scaffoldBackgroundColor的值 bottomNavigationBar：类似于android重的android:windowSoftInputMode=”adjustResize”控制界面内容 body 是否重新布局来避免底部被覆盖了，比如当键盘显示的时候，重新布局避免被键盘盖住内容。默认值为 true。显示 snackbar 或者 bottom sheet 的时候，需要使用当前的 BuildContext 参数调用 Scaffold.of 函数来获取 ScaffoldState 对象，然后使用 ScaffoldState.showSnackBar 和 ScaffoldState.showBottomSheet 函数来显示。 主要的小部件： 1.StatelessWidget[无状态] 2.StatefulWidget[有状态]","categories":[{"name":"flutter","slug":"flutter","permalink":"http://b.nearby.ren/categories/flutter/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"},{"name":"ios","slug":"ios","permalink":"http://b.nearby.ren/tags/ios/"}]},{"title":"Centos 7 安装GNOME桌面环境与安装 VNC 使用图形界面远程","slug":"Centos 7 安装GNOME桌面环境与安装 VNC 使用图形界面远程","date":"2018-02-23T08:10:55.000Z","updated":"2021-10-03T02:44:38.160Z","comments":true,"path":"2018/02/23/Centos 7 安装GNOME桌面环境与安装 VNC 使用图形界面远程/","link":"","permalink":"http://b.nearby.ren/2018/02/23/Centos 7 安装GNOME桌面环境与安装 VNC 使用图形界面远程/","excerpt":"","text":"安装之前检查下是否已经安装VNC安装之前检查下是否已经安装VNC123[root@nearby ~]# rpm -q tigervnc tigervnc-server未安装软件包 tigervnc未安装软件包 tigervnc-server 没有安装的话直接使用yum进行安装 123456789[root@nearby ~]# yum -y install tigervnc tigervnc-server......已安装:igervnc.x86_64 0:1.8.0-13.el7 tigervnc-server.x86_64 0:1.8.0-13.el7作为依赖被安装:fltk.x86_64 0:1.3.4-1.el7 mesa-libGLU.x86_64 0:9.0.0-4.el7 tigervnc-icons.noarch 0:1.8.0-13.el7完毕！ 复制配置模板并进行配置 12[root@nearby ~]# cp /lib/systemd/system/vncserver@.service /etc/systemd/system/vncserver@:1.service[root@nearby ~]# vim /etc/systemd/system/vncserver@\\:1.service 将配置文件中的改成对应的用户，我这里用root12345# Clean any existing files in /tmp/.X11-unix environmentExecStartPre=/bin/sh -c &apos;/usr/bin/vncserver -kill %i &gt; /dev/null 2&gt;&amp;1 || :&apos;ExecStart=/usr/sbin/runuser -l &lt;USER&gt; -c &quot;/usr/bin/vncserver %i&quot;PIDFile=/home/&lt;USER&gt;/.vnc/%H%i.pidExecStop=/bin/sh -c &apos;/usr/bin/vncserver -kill %i &gt; /dev/null 2&gt;&amp;1 || :&apos; 调整为：12345# Clean any existing files in /tmp/.X11-unix environmentExecStartPre=/bin/sh -c &apos;/usr/bin/vncserver -kill %i &gt; /dev/null 2&gt;&amp;1 || :&apos;ExecStart=/usr/sbin/runuser -l root -c &quot;/usr/bin/vncserver %i&quot;PIDFile=/home/root/.vnc/%H%i.pidExecStop=/bin/sh -c &apos;/usr/bin/vncserver -kill %i &gt; /dev/null 2&gt;&amp;1 || :&apos; 要通知systemd重载此配置文件 1[root@nearby ~]# systemctl daemon-reload 现在为这个用户配置个密码 1234567[root@nearby ~]# vncpasswdPassword:Verify:Would you like to enter a view-only password (y/n)? yPassword:Verify:[root@nearby ~]# 设置开机服务自启12[root@nearby ~]# systemctl enable vncserver@:1.serviceCreated symlink from /etc/systemd/system/multi-user.target.wants/vncserver@:1.service to /etc/systemd/system/vncserver@:1.service. 启动服务 123456789[root@nearby ~]# vncserver :1A VNC server is already running as :1New &apos;nearby.jump:2 (root)&apos; desktop is nearby.jump:2Starting applications specified in /root/.vnc/xstartupLog file is /root/.vnc/nearby.jump:2.log[root@nearby ~]# 安Centos 7 安装GNOME桌面环境第1步：安装GNOME及相应桌面管理工具1[root@nearby ~]# yum groupinstall -y &quot;X Window System&quot; &quot;GNOME Desktop&quot; 第2步：设置开机启动为GNOME1[root@nearby ~]# systemctl set-default graphical.target 第3步：重启1[root@nearby ~]# reboot 第4步：开启VNC服务需要用到的5900和5901端口。【此处阿里云服务器配置】","categories":[{"name":"linxu","slug":"linxu","permalink":"http://b.nearby.ren/categories/linxu/"}],"tags":[{"name":"linxu","slug":"linxu","permalink":"http://b.nearby.ren/tags/linxu/"}]},{"title":"android webView独立进程详解","slug":"android webView独立进程详解","date":"2017-12-15T08:03:12.000Z","updated":"2018-02-24T08:02:42.628Z","comments":true,"path":"2017/12/15/android webView独立进程详解/","link":"","permalink":"http://b.nearby.ren/2017/12/15/android webView独立进程详解/","excerpt":"WebView独立进程的好处 1.有效增大App的运存，减少由webview引起的内存泄露对主进程内存的占用。2.避免WebView的Crash影响App主进程的运行。3.拥有对WebView独立进程操控权。WebView进程与其他进程通讯的方式把webview独立进程之后会发现，埋点功能和接收主进程数据都不正常了，这里就涉及到进程间通讯的问题了;进程通讯无非就是那几种，aidl，messager，content provider，广播;","text":"WebView独立进程的好处 1.有效增大App的运存，减少由webview引起的内存泄露对主进程内存的占用。2.避免WebView的Crash影响App主进程的运行。3.拥有对WebView独立进程操控权。WebView进程与其他进程通讯的方式把webview独立进程之后会发现，埋点功能和接收主进程数据都不正常了，这里就涉及到进程间通讯的问题了;进程通讯无非就是那几种，aidl，messager，content provider，广播; webview的配置 //声明WebSettings子类WebSettings webSettings = webView.getSettings(); //如果访问的页面中要与Javascript交互，则webview必须设置支持JavascriptwebSettings.setJavaScriptEnabled(true); //支持插件webSettings.setPluginsEnabled(true); //设置自适应屏幕，两者合用webSettings.setUseWideViewPort(true); //将图片调整到适合webview的大小webSettings.setLoadWithOverviewMode(true); // 缩放至屏幕的大小 //缩放操作webSettings.setSupportZoom(true); //支持缩放，默认为true。是下面那个的前提。webSettings.setBuiltInZoomControls(true); //设置内置的缩放控件。若为false，则该WebView不可缩放webSettings.setDisplayZoomControls(false); //隐藏原生的缩放控件 //其他细节操作webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK); //关闭webview中缓存webSettings.setAllowFileAccess(true); //设置可以访问文件webSettings.setJavaScriptCanOpenWindowsAutomatically(true); //支持通过JS打开新窗口webSettings.setLoadsImagesAutomatically(true); //支持自动加载图片webSettings.setDefaultTextEncodingName(“utf-8”);//设置编码格式 常见用法：设置WebView缓存 当加载 html 页面时，WebView会在/data/data/包名目录下生成 database 与 cache 两个文件夹请求的 URL记录保存在 WebViewCache.db，而 URL的内容是保存在 WebViewCache 文件夹下是否启用缓存： //优先使用缓存: WebView.getSettings().setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK); //缓存模式如下： //LOAD_CACHE_ONLY: 不使用网络，只读取本地缓存数据 //LOAD_DEFAULT: （默认）根据cache-control决定是否从网络上取数据。 //LOAD_NO_CACHE: 不使用缓存，只从网络获取数据. //LOAD_CACHE_ELSE_NETWORK，只要本地有，无论是否过期，或者no-cache，都使用缓存中的数据。 //不使用缓存: WebView.getSettings().setCacheMode(WebSettings.LOAD_NO_CACHE); 结合使用（离线加载） if (NetStatusUtil.isConnected(getApplicationContext())) { webSettings.setCacheMode(WebSettings.LOAD_DEFAULT);//根据cache-control决定是否从网络上取数据。} else { webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK);//没网，则从本地获取，即离线加载} webSettings.setDomStorageEnabled(true); // 开启 DOM storage API 功能webSettings.setDatabaseEnabled(true); //开启 database storage API 功能webSettings.setAppCacheEnabled(true);//开启 Application Caches 功能 String cacheDirPath = getFilesDir().getAbsolutePath() + APP_CACAHE_DIRNAME;webSettings.setAppCachePath(cacheDirPath); //设置 Application Caches 缓存目录 1.1 WebView的状态 //激活WebView为活跃状态，能正常执行网页的响应webView.onResume() ； //当页面被失去焦点被切换到后台不可见状态，需要执行onPause//通过onPause动作通知内核暂停所有的动作，比如DOM的解析、plugin的执行、JavaScript执行。webView.onPause()； //当应用程序(存在webview)被切换到后台时，这个方法不仅仅针对当前的webview而是全局的全应用程序的webview//它会暂停所有webview的layout，parsing，javascripttimer。降低CPU功耗。webView.pauseTimers()//恢复pauseTimers状态webView.resumeTimers()； //销毁Webview//在关闭了Activity时，如果Webview的音乐或视频，还在播放。就必须销毁Webview//但是注意：webview调用destory时,webview仍绑定在Activity上//这是由于自定义webview构建时传入了该Activity的context对象//因此需要先从父容器中移除webview,然后再销毁webview:rootLayout.removeView(webView);webView.destroy(); 1.2 关于前进 / 后退网页 //是否可以后退Webview.canGoBack()//后退网页Webview.goBack() //是否可以前进Webview.canGoForward()//前进网页Webview.goForward() //以当前的index为起始点前进或者后退到历史记录中指定的steps//如果steps为负数则为后退，正数则为前进Webview.goBackOrForward(intsteps) 常见用法：Back键控制网页后退 问题：在不做任何处理前提下 ，浏览网页时点击系统的“Back”键,整个 Browser 会调用 finish()而结束自身目标：点击返回后，是网页回退而不是推出浏览器解决方案：在当前Activity中处理并消费掉该 Back 事件 public boolean onKeyDown(int keyCode, KeyEvent event) { if ((keyCode == KEYCODE_BACK) &amp;&amp; mWebView.canGoBack()) { mWebView.goBack(); return true; } return super.onKeyDown(keyCode, event);} 1.3 清除缓存数据 //清除网页访问留下的缓存//由于内核缓存是全局的因此这个方法不仅仅针对webview而是针对整个应用程序.Webview.clearCache(true); //清除当前webview访问的历史记录//只会webview访问历史记录里的所有记录除了当前访问记录Webview.clearHistory()； //这个api仅仅清除自动完成填充的表单数据，并不会清除WebView存储到本地的数据Webview.clearFormData()； 1.4 WebViewClient类 作用：处理各种通知 &amp; 请求事件常见方法：常见方法1：shouldOverrideUrlLoading() 作用：打开网页时不调用系统浏览器， 而是在本WebView中显示；在网页上的所有加载都经过这个方法,这个函数我们可以做很多操作。//步骤1. 定义Webview组件Webview webview = (WebView) findViewById(R.id.webView1); //步骤2. 选择加载方式 //方式1. 加载一个网页： webView.loadUrl(“http://www.google.com/“); //方式2：加载apk包中的html页面 webView.loadUrl(“file:///android_asset/test.html”); //方式3：加载手机本地的html页面 webView.loadUrl(“content://com.android.htmlfileprovider/sdcard/test.html”); //步骤3. 复写shouldOverrideUrlLoading()方法，使得打开网页时不调用系统浏览器， 而是在本WebView中显示 webView.setWebViewClient(new WebViewClient(){ @Override public boolean shouldOverrideUrlLoading(WebView view, String url) { view.loadUrl(url); return true; } }); 常见方法2：onPageStarted() 作用：开始载入页面调用的，我们可以设定一个loading的页面，告诉用户程序在等待网络响应。 webView.setWebViewClient(new WebViewClient(){ @Override public void onPageStarted(WebView view, String url, Bitmap favicon) { //设定加载开始的操作 } }); 常见方法3：onPageFinished() 作用：在页面加载结束时调用。我们可以关闭loading 条，切换程序动作。 webView.setWebViewClient(new WebViewClient(){ @Override public void onPageFinished(WebView view, String url) { //设定加载结束的操作 } }); 常见方法4：onLoadResource() 作用：在加载页面资源时会调用，每一个资源（比如图片）的加载都会调用一次。 webView.setWebViewClient(new WebViewClient(){ @Override public boolean onLoadResource(WebView view, String url) { //设定加载资源的操作 } }); 常见方法5：onReceivedError（） 作用：加载页面的服务器出现错误时（如404）调用。App里面使用webview控件的时候遇到了诸如404这类的错误的时候，若也显示浏览器里面的那种错误提示页面就显得很丑陋了，那么这个时候我们的app就需要加载一个本地的错误提示页面，即webview如何加载一个本地的页面//步骤1：写一个html文件（error_handle.html），用于出错时展示给用户看的提示页面//步骤2：将该html文件放置到代码根目录的assets文件夹下 //步骤3：复写WebViewClient的onRecievedError方法//该方法传回了错误码，根据错误类型可以进行不同的错误分类处理 webView.setWebViewClient(new WebViewClient(){ @Override public void onReceivedError(WebView view, int errorCode, String description, String failingUrl){switch(errorCode) { case HttpStatus.SC_NOT_FOUND: view.loadUrl(“file:///android_assets/error_handle.html”); break; } } }); 常见方法6：onReceivedSslError() 作用：处理https请求webView默认是不处理https请求的，页面显示空白，需要进行如下设置：webView.setWebViewClient(new WebViewClient() { @Override public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) { handler.proceed(); //表示等待证书响应 // handler.cancel(); //表示挂起连接，为默认方式 // handler.handleMessage(null); //可做其他处理 } }); 1.4 WebChromeClient类 作用：辅助 WebView 处理 Javascript 的对话框,网站图标,网站标题等等。常见使用：常见方法1： onProgressChanged（） 作用：获得网页的加载进度并显示webview.setWebChromeClient(new WebChromeClient(){ @Override public void onProgressChanged(WebView view, int newProgress) { if (newProgress &lt; 100) { String progress = newProgress + &quot;%&quot;; progress.setText(progress); } else { } }); 常见方法2： onReceivedTitle（） 作用：获取Web页中的标题每个网页的页面都有一个标题，比如www.baidu.com这个页面的标题即“百度一下，你就知道”，那么如何知道当前webview正在加载的页面的title并进行设置呢？webview.setWebChromeClient(new WebChromeClient(){ @Override public void onReceivedTitle(WebView view, String title) { titleview.setText(title)； } 注意事项：如何避免WebView内存泄露？ 不在xml中定义 Webview ，而是在需要的时候在Activity中创建，并且Context使用 getApplicationgContext() LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT); mWebView = new WebView(getApplicationContext()); mWebView.setLayoutParams(params); mLayout.addView(mWebView); 在 Activity 销毁（ WebView ）的时候，先让 WebView 加载null内容，然后移除 WebView，再销毁 WebView，最后置空。 @Override protected void onDestroy() { if (mWebView != null) { mWebView.loadDataWithBaseURL(null, &quot;&quot;, &quot;text/html&quot;, &quot;utf-8&quot;, null); mWebView.clearHistory(); ((ViewGroup) mWebView.getParent()).removeView(mWebView); mWebView.destroy(); mWebView = null; } super.onDestroy(); }","categories":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"},{"name":"web","slug":"web","permalink":"http://b.nearby.ren/tags/web/"}]},{"title":"rxjava 操作符简略","slug":"rxjava 操作符简略","date":"2017-12-12T09:50:12.000Z","updated":"2019-03-28T03:08:00.248Z","comments":true,"path":"2017/12/12/rxjava 操作符简略/","link":"","permalink":"http://b.nearby.ren/2017/12/12/rxjava 操作符简略/","excerpt":"","text":"rxjava 变换字符：Map()/FlatMap/ConcatMap()/Buffer()/delay()/do()/onErrorReturn()/onErrorResumeNext()/onExceptionResumeNext()/retry()/retryUntil()/retryWhen()/repeat()/repeatWhen()/1.Map 作用：对被观察者发送的每1个事件都通过 指定的函数 处理，从而变换成另外一种事件 场景：数据类型转换2.FlatMap 作用：将被观察者发送的事件进行拆分&amp;单独转换，在合并成一个新的事件序列，最后进行发送。 场景：无序的将被观察者发送的整个事件序列进行变换3.ConcatMap 作用：类似FlatMap() 操作符 与FlatMap（）的 区别在于：拆分 &amp; 重新合并生成的事件序列 的顺序 = 被观察者旧序列生产的顺序 场景：有序的将被观察者发送的整个事件序列进行变换4.Buffer 作用：定期从 被观察者（Obervable）需要发送的事件中 获取一定数量的事件 &amp; 放到缓存区中，最终发送 场景：缓存被观察者发送的事件5.delay 作用：使得被观察者延迟一段时间再发送事件 [observable] 1.在事件的生命周期中操作6.do 作用：在某个事件的生命周期中调用0601：doOnEach/onNext/onError/onCompleted 当observable每次发送一次数据事件就会调用0602：doOnNext/doAftetNext 执行Next事件前调用/执行Next事件后调用0603：doError()/doOnCompleted()/doOnTerminate()/doFianlly() 发送错误事件时/正常发送事件完毕后/无论正常发送或异常终止/最后执行0604：doOnSubscribe()/doOnUnsubscribe() 观察者订阅时调用/观察者取消订阅时调用 2.错误处理 场景：发送事件过程中，遇到错误时的处理机制1.onErrorResumeNext（）拦截的错误 = Throwable；若需拦截Exception请用onExceptionResumeNext（）2.若onErrorResumeNext（）拦截的错误 = Exception，则会将错误传递给观察者的onError方法 7.onErrorReturn 作用：遇到错误时，发送1个特殊事件&amp;正常终止8.onErrorResumeNext 作用：遇到错误时，发送1个新的Observable9.onExceptionResumeNext 作用：遇到错误时，发送1个新的Observable10.retry 作用：重试，即当出现错误时，让被观察者（Observable）重新发射数据11.retryUntil 作用： 出现错误后，判断是否需要重新发送数据1101.若需要重新发送 &amp; 持续遇到错误，则持续重试1102.作用类似于retry（Predicate predicate）12.retryWhen 作用：遇到错误时，将发生的错误传递给一个新的被观察者（Observable），并决定是否需要重新订阅原始被观察者（Observable）&amp; 发送事件13.repeat 作用：无条件地、重复发送 被观察者事件14.repeatWhen 作用：有条件地、重复发送 被观察者事件 合并操/组合操作符1.组合多个被观察者 顺序：concat concatArray 时间：merge mergeArray 错误处理：concatDelayError mergeDelayError2.合并多个事件 数量：zip 时间：combineLatest combineLatestDelayError 合并成1个事件发送 reduce collect3.发送事件前追加发送事件 startWith startWithArray4.统计发送事件数量 count 1.concat 作用：组合多个被观察者一起发送数据，合并后 按发送顺序串行执行 二者区别：组合被观察者的数量，即concat（）组合被观察者数量≤4个，而concatArray（）则可＞4个2.merge 作用：组合多个被观察者一起发送数据，合并后 按时间线并行执行 区别上述concat（）操作符：同样是组合多个被观察者一起发送数据，但concat（）操作符合并后是按发送顺序串行执行3.concatDelayError 如果事件出现异常 决定是否继续发送4.zip 作用：合并 多个被观察者（Observable）发送的事件，生成一个新的事件序列（即组合过后的事件序列），并最终发送 场景：当需要展示的信息需要从多个地方获取(即信息 = 信息1 + 信息2 )&amp;统一结合后再展示 如合并网络请求的发送&amp;统一显示结果5.combineLatest 作用：当两个Observables中的任何一个发送了数据后，将先发送了数据的Observables 的最新（最后）一个数据 与 另外一个Observable发送的每个数据结合，最终基于该函数的结果发送数据6.reduce 作用：把被观察者需要发送的事件聚合成1个事件 &amp; 发送 聚合的逻辑根据需求撰写，但本质都是前2个数据聚合，然后与后1个数据继续进行聚合，依次类推7.collect 作用：将被观察者Observable发送的数据事件收集到一个数据结构里8.startWith / startWithArray 作用：在一个被观察者发送事件前，追加发送一些数据 / 一个新的被观察者9.conunt 作用：统计被观察者发送事件的数量","categories":[{"name":"rxjava","slug":"rxjava","permalink":"http://b.nearby.ren/categories/rxjava/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"},{"name":"rxjava","slug":"rxjava","permalink":"http://b.nearby.ren/tags/rxjava/"},{"name":"rxandroid","slug":"rxandroid","permalink":"http://b.nearby.ren/tags/rxandroid/"}]},{"title":"View的技术传递","slug":"View的技术传递","date":"2017-12-08T06:52:03.000Z","updated":"2021-08-01T10:31:45.423Z","comments":true,"path":"2017/12/08/View的技术传递/","link":"","permalink":"http://b.nearby.ren/2017/12/08/View的技术传递/","excerpt":"","text":"1. 基础知识 (1) 所有Touch事件都被封装成MotionEvent对象，包括Touch的位置、时间、历史记录以及第几个手指(多手指触摸灯)。 (2) 事件类型分类为ACTION_DOWN，ACTION_UP，ACTION_MOVE，ACTION_POINTER_DOWN，ACTION_POINTER_UP，ACTION_CANCEL，每个事件都以ACTION_DOWN开始ACTION_UP结束。 (3) 对事件的处理包括三类，分别为传递—dispatchTouchEvent()函数、拦截—oninterceptTouchEvent函数、消费—-onTouchEvent函数和OnTouchListener2.传递流程 (1) 事件从Activity.dispatchTouchEvent开始传递,只要没有被停止或拦截,从最上层的View(ViewGroup)开始一直往下(子View)传递。子View可以通过OnTouchEvent()对事件进行处理。 (2) 事件由父View(ViewGroup)传递给子View,ViewGroup可以通过oniterceptTouchEvent对事件做拦截,停止其往下传递。 (3) 如果事件从上往下传递过程中一直没有被停止，且最底层子View没有消费事件，事件会反向往上传递，这时父View(Group)可以进行消费，如果还是没有被消费的话，最后会到Activity的OnTouchEven()函数。 (4)如果View没有对ACTION_DOUWN进行消费,之后的其他事件不会传递过来 (5) OnTouchListener优于OnTouchEvent()对事件进行消费。 上面的消费即表示相应函数返回值为true (1)View不处理事件流程图 (2)View处理事件流程图","categories":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/categories/android/"}],"tags":[{"name":"view","slug":"view","permalink":"http://b.nearby.ren/tags/view/"}]},{"title":"RecyclerView的万能分割线","slug":"RecyclerView的万能分割线","date":"2017-12-05T05:30:12.000Z","updated":"2019-07-14T08:52:40.706Z","comments":true,"path":"2017/12/05/RecyclerView的万能分割线/","link":"","permalink":"http://b.nearby.ren/2017/12/05/RecyclerView的万能分割线/","excerpt":"","text":"##使用方法： #添加默认分割线：高度为2px，颜色为灰色1mRecyclerView.addItemDecoration(new RecyclerViewDivider(mContext, LinearLayoutManager.VERTICAL)); #添加自定义分割线：可自定义分割线drawable 12mRecyclerView.addItemDecoration(new RecyclerViewDivider(mContext, LinearLayoutManager.VERTICAL, R.drawable.divider_mileage)); #添加自定义分割线：可自定义分割线高度和颜色12mRecyclerView.addItemDecoration(new RecyclerViewDivider(mContext, LinearLayoutManager.VERTICAL, 10, ContextCompat.getColor(mContext, R.color.divide_gray_color))); #万能分割线登场： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130package utils;import android.content.Context;import android.content.res.TypedArray;import android.graphics.Canvas;import android.graphics.Paint;import android.graphics.Rect;import android.graphics.drawable.Drawable;import android.support.v4.content.ContextCompat;import android.support.v7.widget.LinearLayoutManager;import android.support.v7.widget.RecyclerView;import android.view.View;/** * Created by $&#123;火龙裸先生&#125; on 2016/10/29. * 邮箱：791335000@qq.com */public class RecyclerViewDivider extends RecyclerView.ItemDecoration &#123; private Paint mPaint; private Drawable mDivider; private int mDividerHeight = 2;//分割线高度，默认为1px private int mOrientation;//列表的方向：LinearLayoutManager.VERTICAL或LinearLayoutManager.HORIZONTAL private static final int[] ATTRS = new int[]&#123;android.R.attr.listDivider&#125;; /** * 默认分割线：高度为2px，颜色为灰色 * * @param context * @param orientation 列表方向 */ public RecyclerViewDivider(Context context, int orientation) &#123; if (orientation != LinearLayoutManager.VERTICAL &amp;&amp; orientation != LinearLayoutManager.HORIZONTAL) &#123; throw new IllegalArgumentException(&quot;请输入正确的参数！&quot;); &#125; mOrientation = orientation; final TypedArray a = context.obtainStyledAttributes(ATTRS); mDivider = a.getDrawable(0); a.recycle(); &#125; /** * 自定义分割线 * * @param context * @param orientation 列表方向 * @param drawableId 分割线图片 */ public RecyclerViewDivider(Context context, int orientation, int drawableId) &#123; this(context, orientation); mDivider = ContextCompat.getDrawable(context, drawableId); mDividerHeight = mDivider.getIntrinsicHeight(); &#125; /** * 自定义分割线 * * @param context * @param orientation 列表方向 * @param dividerHeight 分割线高度 * @param dividerColor 分割线颜色 */ public RecyclerViewDivider(Context context, int orientation, int dividerHeight, int dividerColor) &#123; this(context, orientation); mDividerHeight = dividerHeight; mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mPaint.setColor(dividerColor); mPaint.setStyle(Paint.Style.FILL); &#125; //获取分割线尺寸 @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; super.getItemOffsets(outRect, view, parent, state); outRect.set(0, 0, 0, mDividerHeight); &#125; //绘制分割线 @Override public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123; super.onDraw(c, parent, state); if (mOrientation == LinearLayoutManager.VERTICAL) &#123; drawVertical(c, parent); &#125; else &#123; drawHorizontal(c, parent); &#125; &#125; //绘制横向 item 分割线 private void drawHorizontal(Canvas canvas, RecyclerView parent) &#123; final int left = parent.getPaddingLeft(); final int right = parent.getMeasuredWidth() - parent.getPaddingRight(); final int childSize = parent.getChildCount(); for (int i = 0; i &lt; childSize; i++) &#123; final View child = parent.getChildAt(i); RecyclerView.LayoutParams layoutParams = (RecyclerView.LayoutParams) child.getLayoutParams(); final int top = child.getBottom() + layoutParams.bottomMargin; final int bottom = top + mDividerHeight; if (mDivider != null) &#123; mDivider.setBounds(left, top, right, bottom); mDivider.draw(canvas); &#125; if (mPaint != null) &#123; canvas.drawRect(left, top, right, bottom, mPaint); &#125; &#125; &#125; //绘制纵向 item 分割线 private void drawVertical(Canvas canvas, RecyclerView parent) &#123; final int top = parent.getPaddingTop(); final int bottom = parent.getMeasuredHeight() - parent.getPaddingBottom(); final int childSize = parent.getChildCount(); for (int i = 0; i &lt; childSize; i++) &#123; final View child = parent.getChildAt(i); RecyclerView.LayoutParams layoutParams = (RecyclerView.LayoutParams) child.getLayoutParams(); final int left = child.getRight() + layoutParams.rightMargin; final int right = left + mDividerHeight; if (mDivider != null) &#123; mDivider.setBounds(left, top, right, bottom); mDivider.draw(canvas); &#125; if (mPaint != null) &#123; canvas.drawRect(left, top, right, bottom, mPaint); &#125; &#125; &#125;&#125;","categories":[{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://b.nearby.ren/categories/RecyclerView/"}],"tags":[{"name":"view","slug":"view","permalink":"http://b.nearby.ren/tags/view/"}]},{"title":"vue 目录解析","slug":"vue 目录解析","date":"2017-11-08T08:03:12.000Z","updated":"2017-11-17T06:33:11.239Z","comments":true,"path":"2017/11/08/vue 目录解析/","link":"","permalink":"http://b.nearby.ren/2017/11/08/vue 目录解析/","excerpt":"","text":"vue 目录解析├── build/ # webpack config files / webpack 配置文件│ └── …├── config/│ ├── index.js # main project config / 项目主要配置│ └── …├── src/ # 主要的项目开发文件都在这个目录下：│ ├── main.js # app entry file / 应用入口文件│ ├── App.vue # main app component / App 父组件│ ├── components/ # ui components / 可复用的 ui 组件│ │ └── …│ ├── assets/ # module assets (processed by webpack) / 模块资源（经过 webpack 处理，如文件合并，图片压缩等）│ │ └── …│ ├── page/ ## 以页面为单位的 .vue 文件│ │ ├── index.vue ## 一级 router-view，顶部导航栏和左侧侧边导航栏│ │ ├── 404.vue ## 404 页面│ │ ├── menu1/ ## 二级 router-view，导航切换后的页面内容│ │ │ └── …│ │ └── menu2/ ## 按照菜单项创建文件夹对文件进行组织管理│ │ └── …│ └── router/│ └── index.js # 路由配置文件├── static/ # pure static assets (directly copied) / 纯静态资源（直接拷贝使用，不经过 webpack 处理）├── .babelrc # babel config├── .eslintrc.js # eslint config├── .editorconfig # editor config├── index.html # index.html template├── package.json # build scripts and dependencies└── … 关闭Eslint：build/webpack.base.conf.jsmodule: { rules: [ // { // test: /.(js|vue)$/, // loader: ‘eslint-loader’, // enforce: “pre”, // include: [resolve(‘src’), resolve(‘test’)], // options: { // formatter: require(‘eslint-friendly-formatter’) // } // }, { test: /.vue$/, loader: ‘vue-loader’, options: vueLoaderConfig }, … ] },","categories":[{"name":"web","slug":"web","permalink":"http://b.nearby.ren/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://b.nearby.ren/tags/web/"}]},{"title":"mac android studio 几个文件夹夹路径","slug":"mac android studio 几个文件夹路径","date":"2017-11-08T08:03:12.000Z","updated":"2019-04-14T05:09:31.372Z","comments":true,"path":"2017/11/08/mac android studio 几个文件夹路径/","link":"","permalink":"http://b.nearby.ren/2017/11/08/mac android studio 几个文件夹路径/","excerpt":"","text":"vue 目录解析在mac资源目录下保存的的目录地址 gradle 关系文件 ~/.gradle Android 模拟器(AVDs) and *.keystore 文件 ~/.android Android SDK 工具 ~/Library/Android* 完全移除android studio终端中执行下列命令 rm -Rf /Applications/Android\\ Studio.apprm -Rf ~/Library/Preferences/AndroidStudiorm -Rf ~/Library/Preferences/com.google.android.studio.plistrm -Rf ~/Library/Application\\ Support/AndroidStudiorm -Rf ~/Library/Logs/AndroidStudiorm -Rf ~/Library/Caches/AndroidStudio","categories":[{"name":"android studio","slug":"android-studio","permalink":"http://b.nearby.ren/categories/android-studio/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://b.nearby.ren/tags/mac/"}]},{"title":"Android SO文件的兼容和适配","slug":"android os文件的兼容和适配","date":"2017-11-08T08:03:12.000Z","updated":"2021-10-30T12:38:53.101Z","comments":true,"path":"2017/11/08/android os文件的兼容和适配/","link":"","permalink":"http://b.nearby.ren/2017/11/08/android os文件的兼容和适配/","excerpt":"如何查看自己手机的架构？1adb shell getprop ro.product.cpu.abi adb查看不同机型的CPU信息1adb shell cat /proc/cpuinfo 其中processor: 表示第几个核。Features：表示当前CPU所支持的特性，比如neon，vfp等。CPU architecture：7表示arm-v7，8表示arm-v8 2 cpu架构与so兼容对于一个cpu是arm64-v8a架构的手机，它运行app时，进入jnilibs去读取库文件时，先看有没有arm64-v8a文件夹，如果没有该文件夹，去找armeabi-v7a文件夹，如果没有，再去找armeabi文件夹，如果连这个文件夹也没有，就抛出异常。注意：这里说的是文件夹，即如果有arm64-v8a文件夹，那么就去找特定名称的.so文件，如果没有找到想要的.so文件，不会再往下（armeabi-v7a文件夹）找了，而是直接抛出异常。 现在大部分Android机型CPU都是armeabi-v7a和arm64-v8架构，而他们又是向下兼容，因此，仅适配一种CPU架构就能满足绝大部分要求，这样就能最大限度减少APK的大小。 方案一：只适配armeabi123ndk &#123; abiFilters &apos;armeabi&apos; &#125; 优点：基本上适配了全部CPU架构（除了淘汰的mips和mips_64）。缺点：性能低，相当于在绝大多数手机上都是需要辅助ABI或动态转码来兼容。 方案二：只适配 armeabi-v7a123ndk &#123; abiFilters &apos;armeabi-v7a&apos; &#125; 同方案一，只是又筛掉了一部分老旧设备,在性能和兼容二者中比较平衡。 方案三：只适配 arm64-v8a123ndk &#123; abiFilters &apos;arm64-v8a&apos; &#125; 优点：性能最佳缺点：只能运行在arm64-v8上，要放弃部分老旧设备用户。 Android SO文件的兼容和适配开发Android应用时，有时候Java层的编码不能满足实现需求，就需要到C/C++实现后生成SO文件，再用System.loadLibrary()加载进行调用，这里成为JNI层的实现。常见的场景如：加解密算法，音视频编解码等。在生成SO文件时，需要考虑适配市面上不同手机CPU架构，而生成支持不同平台的SO文件进行兼容。目前Android共支持七种不同类型的CPU架构，分别是：ARMv5，ARMv7 (从2010年起)，x86 (从2011年起)，MIPS (从2012年起)，ARMv8，MIPS64和x86_64 (从2014年起)。如果你要完美兼容所有类型的手机，理论上是要在的libs目录下放置各个架构平台的SO文件。 这样一来，虽然可以兼容所有机型，但你的项目体积也会变得非常庞大。是否一定需要带入这么多SO文件去兼容呢？答案是否定的。","text":"如何查看自己手机的架构？1adb shell getprop ro.product.cpu.abi adb查看不同机型的CPU信息1adb shell cat /proc/cpuinfo 其中processor: 表示第几个核。Features：表示当前CPU所支持的特性，比如neon，vfp等。CPU architecture：7表示arm-v7，8表示arm-v8 2 cpu架构与so兼容对于一个cpu是arm64-v8a架构的手机，它运行app时，进入jnilibs去读取库文件时，先看有没有arm64-v8a文件夹，如果没有该文件夹，去找armeabi-v7a文件夹，如果没有，再去找armeabi文件夹，如果连这个文件夹也没有，就抛出异常。注意：这里说的是文件夹，即如果有arm64-v8a文件夹，那么就去找特定名称的.so文件，如果没有找到想要的.so文件，不会再往下（armeabi-v7a文件夹）找了，而是直接抛出异常。 现在大部分Android机型CPU都是armeabi-v7a和arm64-v8架构，而他们又是向下兼容，因此，仅适配一种CPU架构就能满足绝大部分要求，这样就能最大限度减少APK的大小。 方案一：只适配armeabi123ndk &#123; abiFilters &apos;armeabi&apos; &#125; 优点：基本上适配了全部CPU架构（除了淘汰的mips和mips_64）。缺点：性能低，相当于在绝大多数手机上都是需要辅助ABI或动态转码来兼容。 方案二：只适配 armeabi-v7a123ndk &#123; abiFilters &apos;armeabi-v7a&apos; &#125; 同方案一，只是又筛掉了一部分老旧设备,在性能和兼容二者中比较平衡。 方案三：只适配 arm64-v8a123ndk &#123; abiFilters &apos;arm64-v8a&apos; &#125; 优点：性能最佳缺点：只能运行在arm64-v8上，要放弃部分老旧设备用户。 Android SO文件的兼容和适配开发Android应用时，有时候Java层的编码不能满足实现需求，就需要到C/C++实现后生成SO文件，再用System.loadLibrary()加载进行调用，这里成为JNI层的实现。常见的场景如：加解密算法，音视频编解码等。在生成SO文件时，需要考虑适配市面上不同手机CPU架构，而生成支持不同平台的SO文件进行兼容。目前Android共支持七种不同类型的CPU架构，分别是：ARMv5，ARMv7 (从2010年起)，x86 (从2011年起)，MIPS (从2012年起)，ARMv8，MIPS64和x86_64 (从2014年起)。如果你要完美兼容所有类型的手机，理论上是要在的libs目录下放置各个架构平台的SO文件。 这样一来，虽然可以兼容所有机型，但你的项目体积也会变得非常庞大。是否一定需要带入这么多SO文件去兼容呢？答案是否定的。 SO（CPU）的兼容 对于CPU来说，不同的架构并不意味着一定互不兼容，根据目前Android共支持七种不同类型的CPU架构，其兼容特点可总结如下： armeabi设备只兼容armeabi；armeabi-v7a设备兼容armeabi-v7a、armeabi；arm64-v8a设备兼容arm64-v8a、armeabi-v7a、armeabi；X86设备兼容X86、armeabi；X86_64设备兼容X86_64、X86、armeabi；mips64设备兼容mips64、mips；mips只兼容mips；根据以上的兼容总结，我们还可以得到一些规律： armeabi的SO文件基本上可以说是万金油，它能运行在除了mips和mips64的设备上，但在非armeabi设备上运行性能还是有所损耗；64位的CPU架构总能向下兼容其对应的32位指令集，如：x86_64兼容X86，arm64-v8a兼容armeabi-v7a，mips64兼容mips；关于SO的兼容规律就介绍到此，下面谈谈适配工作。 SO的适配从目前移动端CPU市场的份额数据看，ARM架构几乎垄断，所以，除非你的用户很特殊，否则几乎可以不考虑单独编译带入X86、X86_64、mips、mips64架构SO文件。除去这四个架构之后，还要带入armeabi、armeabi-v7a、arm64-v8a这三个不同类型，这对于一个拥有大量SO文件的应用来说，安装包的体积将会增大不少。 针对以上情况，我们可以应用的设备分布和市场情况再进行取舍斟酌，如果你的应用仍有不少armeabi类型的设备，可以考虑只保留armeabi目录下的SO文件（万金油特性）。但是，尽管armeabi可以兼容多种平台，仍有些运算在armeabi-v7a、arm64-v8a去使用armeabi的SO文件时，性能会非常差强人意，所以还是应该用其对应平台架构的SO文件进行运算。注意，这里并不是要带多一整套SO文件到不同的目录下，而是将性能差异比较明显的某个armeabi-v7a、arm64-v8a平台下的SO文件放到armeabi目录，然后通过代码判断设备的CPU类型，再加载其对应架构的SO文件，很多大厂的应用便是这么做的。如微信的lib下虽然只有armeabi一个目录，但目录内的文件仍放着v5、v7a架构的SO文件，用于处理兼容带来的某些性能运算问题。 就目前市场份额而言，绝大部分的设备都已经是armeabi-v7a、arm64-v8a，你也可以考虑只保留armeabi-v7a架构的SO文件，这样能获得更好的性能效果。 总结 以上便是关于SO文件兼容适配的一点总结梳理，如有错误，欢迎指出。","categories":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"},{"name":"https","slug":"https","permalink":"http://b.nearby.ren/tags/https/"}]},{"title":"java List 删除数据问题","slug":"java List 删除数据问题","date":"2017-11-05T08:30:12.000Z","updated":"2019-04-10T14:05:10.231Z","comments":true,"path":"2017/11/05/java List 删除数据问题/","link":"","permalink":"http://b.nearby.ren/2017/11/05/java List 删除数据问题/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546 void test() &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;); ); //第一种方式 for (String str : list) &#123; if (str.contains(&quot;b&quot; )) &#123; list.remove(str); &#125; &#125; //第二种方式 int size = list.size(); for (int i = 0; i &lt; size; i++) &#123; String str = list.get(i); if (str.contains(&quot;b&quot; )) &#123; list.remove(i); &#125; &#125; //第三种方式 for (int i = 0; i &lt; list.size(); i++) &#123; String str = list.get(i); if (str.contains(&quot;b&quot; )) &#123; list.remove(i); &#125; &#125; //第四种方式 for (Iterator&lt;String&gt; ite = list.iterator(); ite.hasNext(); ) &#123; String str = ite.next(); if (str.contains(&quot;b&quot; )) &#123; ite.remove(); &#125; &#125; //第五种方式 for (Iterator&lt;String&gt; ite = list.iterator(); ite.hasNext(); ) &#123; String str = ite.next(); if (str.contains(&quot;b&quot; )) &#123; list.remove(str); &#125; &#125;&#125; 方式一：报错java.util.ConcurrentModificationException方式二：报错：下标越界 java.lang.IndexOutOfBoundsException list大小会发生变化，索引也会变化。导致你在遍历的时候漏掉某些元素，当删除第1个元素后，继续根据索引访问第2个元素时，因为删除的关系后面的元素都会往前移动一位，所以实际访问的是第3个元素，因此，这种方式可以用在删除特定的一个元素时使用，但不适合循环删除多个元素时使用。方式三：正常删除，不推荐，每次循环都需要计算list的大小，效率低。方式四：正常删除，推荐使用方式五：报错：java.util.ConcurrentModificationException","categories":[{"name":"java","slug":"java","permalink":"http://b.nearby.ren/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://b.nearby.ren/tags/java/"}]},{"title":"Fragment库区别","slug":"Fragment库区别","date":"2017-09-22T06:48:20.000Z","updated":"2018-05-31T02:39:52.841Z","comments":true,"path":"2017/09/22/Fragment库区别/","link":"","permalink":"http://b.nearby.ren/2017/09/22/Fragment库区别/","excerpt":"","text":"在做项目时，同事把基础fragment类中的Android.support.v4.app.Fragment改成了android.app.Fragment，导致了一些问题，今天特别来标注一下： 强烈推荐使用android.support.v4.app.Fragment，不过依然要了解为什么？？ 1.最低支持版本不同 android.app.Fragment 兼容的最低版本是android:minSdkVersion=”11” 即3.0版 android.support.v4.app.Fragment 兼容的最低版本是android:minSdkVersion=”4” 即1.6版 2.需要导jar包 fragment android.support.v4.app.Fragment 需要引入包android-support-v4.jar 3.获取manager的方法不同 android.app.Fragment使用getFragmentManager() android.support.v4.app.Fragment使用getSupportFragmentManager() 注意: android.support.v4.app.Fragment不能使用标签 而且想用fragment+viewpager只能使用android.support.v4.app.Fragment，因为FragmentPagerAdapter就是android.support.v4.app.Fragment才有。 切记！！ android.support.v4.app.Fragment与android.app.Fragment不要混用。","categories":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"}]},{"title":"androidHttps搭建与服务器Tomcat9.0配置","slug":"androidHttps搭建与服务器Tomcat9-0配置","date":"2017-06-08T08:03:12.000Z","updated":"2017-11-16T05:56:10.194Z","comments":true,"path":"2017/06/08/androidHttps搭建与服务器Tomcat9-0配置/","link":"","permalink":"http://b.nearby.ren/2017/06/08/androidHttps搭建与服务器Tomcat9-0配置/","excerpt":"","text":"http://www.jianshu.com/p/64172ccfb73bhttp://www.cnblogs.com/LoganChen/p/6369774.html","categories":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"},{"name":"https","slug":"https","permalink":"http://b.nearby.ren/tags/https/"}]},{"title":"swiftype账号与教程","slug":"swiftype账号与教程","date":"2017-04-21T12:20:55.000Z","updated":"2021-10-03T03:04:39.063Z","comments":true,"path":"2017/04/21/swiftype账号与教程/","link":"","permalink":"http://b.nearby.ren/2017/04/21/swiftype账号与教程/","excerpt":"","text":"首先，老一套的要去swiftype的网站https://swiftype.com注册一个账号，然后根据指引建立好自己网站对应的索引。对了有人说注册以后是30天试用，这个没关系，网站给的是30天高级账户的使用（那种有可以建立多个搜索引擎、多账户共同管理、一个引擎index多个域名的功能的账户），30天到期后你可选择花钱继续用这个高级账户（土豪自便），或者选择降级成为免费的账户类型，也就是我现在用的那种，所以，不用担心。登陆后会自动切换到dashboard，一开始会有什么welcome to swiftype，不用搭理直接close即可。然后下面的Create an engine选项便出现了，点吧，如图所示： https://github.com/ppoffice/hexo-theme-icarus/wiki/Search然后到下一步，给你的网站建立一个索引：接着让你输入网址，写吧：然后让你起个名字，起吧：然后他开始抓取你网站的数据，等等吧：抓好之后你的dashboard会变成这个样子：可以点进去看看抓了些什么数据：最后点击菜单的右边 interface 下的 install serarch复制出key 即可。然后打开 icarus配置搜索引擎的教程按教程即可https://github.com/ppoffice/hexo-theme-icarus/wiki/Search","categories":[{"name":"hexo","slug":"hexo","permalink":"http://b.nearby.ren/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://b.nearby.ren/tags/hexo/"}]},{"title":"androidStudio编译与运行常见问题","slug":"androidStudio编译与运行常见问题","date":"2017-03-30T05:50:25.000Z","updated":"2017-11-22T02:02:29.716Z","comments":true,"path":"2017/03/30/androidStudio编译与运行常见问题/","link":"","permalink":"http://b.nearby.ren/2017/03/30/androidStudio编译与运行常见问题/","excerpt":"最近开发公司一个项目，环信客服SDK的demo接入。android5.0的手机大部分可以正确使用，其他之下的手机会报java.lang.VerifyError.。之前以为环信客服SDK的兼容问题，后来把融云屏蔽掉，后面又接连报错，才意思到是我项目出问题，百度了一些资料，才发现java.lang.VerifyError有几种情况会报错;google的官方说法是：java.lang.VerifyError是adt与jdk的不同版本的不同，进入架包之类的会报错各种不同的错误，是无法机器无法解决的。","text":"最近开发公司一个项目，环信客服SDK的demo接入。android5.0的手机大部分可以正确使用，其他之下的手机会报java.lang.VerifyError.。之前以为环信客服SDK的兼容问题，后来把融云屏蔽掉，后面又接连报错，才意思到是我项目出问题，百度了一些资料，才发现java.lang.VerifyError有几种情况会报错;google的官方说法是：java.lang.VerifyError是adt与jdk的不同版本的不同，进入架包之类的会报错各种不同的错误，是无法机器无法解决的。解决方法一 但是，不要忘记，这只是让你app的编辑文件分成2分，你软件运行有可能只运行第一个软件，它是默认运行的，有可能会报VerifyError。Apk在运行的时候，有一个dexpathlist，而Multidex的源码中，会根据你的系统版本号对dexpathlist做修改，将所有的dex都添加到dexpathlist中.接下来集成有两个步骤:一. 从sdk\\extras\\android\\support\\multidex\\library\\libs 目录将android-support-multidex.jar导入工程中二. 如果你的工程中已经含有Application类,那么让它继承android.support.multidex.MultiDexApplication类, 如果你的Application已经继承了其他类并且不想做改动，那么还有另外一种使用方式,覆写attachBaseContext()方法: 网上的一些解释是：app项目过大，必须分成2个Dex文件，Android studio才会运行正常。 这样才能让你的两个dex文件合并在一起，不会报异常了。解决方法二:我只说使用android studio的情况，有可能是你的升级android studio2.0出现的问题 Android Studio 2.0带来了很多新功能和优化，其中最让我兴奋的是Instant Run和Gradle编译速度的提升，虽然预览版bug多，但是程序员怕这个？网上处理的方法是：解决方法就是把Gradle版本改回去，改成1.5版本比较稳定，不会出现问题解决方法三:最后一种是，我也没有碰见过，但是我看着比较靠谱，所有写下来，哈哈 我的记性比较差，请原谅我这个智障哦/(ㄒoㄒ)/~~。你的LibRARY架包包含的.class源文件与你自己module内的一个架包一个源文件.class文件冲突，所有你可以通过ctrl+N,可以在android studio中遍历你的.class源文件，删除其中一个，运行是ok的。 由于是第一次写，有点没头没脑，只要是想给那些遇见跟我一样问题的人 一些解决方案 O(∩_∩)O哈哈~，不过这个问题我难了一个月，头疼死了。","categories":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"},{"name":"bug","slug":"bug","permalink":"http://b.nearby.ren/tags/bug/"}]},{"title":"hexo插入本地图片","slug":"hexo插入本地图片","date":"2017-03-21T02:20:55.000Z","updated":"2021-10-03T02:53:08.539Z","comments":true,"path":"2017/03/21/hexo插入本地图片/","link":"","permalink":"http://b.nearby.ren/2017/03/21/hexo插入本地图片/","excerpt":"","text":"1.先把hexo[你的项目]目录下的配置文件[_config.yml ]打开，更改里面的 post_asset_folder：true。2.在dos命令行下，操作到你的hexo[你的项目]目录下，输入 npm install hexo-asset-image –save 命令，这是下载安装一个可以上传本地图片的插件。3.稍等片刻，在dos命令行下，输入hexo n “xxx”来生成md博客文件后，在hexo[你的项目]目录下source/_posts文件夹里，会生成刚才输入命令的 “xxx”.md文件和”xxx”文件夹4.编辑打开”xxx”.md文件，然后在”xxx”.md文件中按照markdown的格式引入图片： 在”xxx”文件夹存放图片即可5.另种方式：在hexo[你的项目]目录下source文件夹，新建images文件夹存放图片，引用方式如下两种&lt;img src=”../../../../images/20180426104055.png &gt;6.因为 hexo g生成网页后，会在hexo[你的项目]下生成public/xx/xx/xx/文件名/index.html 所以前xx/xx/xx/文件名/ 就像相当于 ../../../../这是在hexo目录下source文件夹，新建images管理图片的好处。第一种方式就是对应的每个xx.md文件生成一个xx文件夹存放图片第二种方式就是在source文件夹，新建images文件夹负责存储所有xx.md文件所有的图片 hexo123npm install hexo -g #安装npm update hexo -g #升级hexo init #初始化 简写hexo n “我的博客” == hexo new “我的博客” #新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署hexo clean &amp;&amp; hexo g &amp;&amp; hexo d #清除部署上线 服务器hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页hexo d #开始部署 监视文件变动hexo generate #使用 Hexo 生成静态文件快速而且简单hexo generate –watch #监视文件变动 完成后部署两个命令的作用是相同的hexo generate –deployhexo deploy –generate hexo deploy -ghexo server -g 草稿hexo publish [layout] 模版hexo new “postName” #新建文章hexo new page “pageName” #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy #将.deploy目录部署到GitHub hexo new [layout] hexo new photo “My Gallery”hexo new “Hello World” –lang tw ｜变量 ｜描述｜｜layout ｜布局｜｜title ｜标题｜｜date ｜文件建立日期｜ 12345678title: 使用Hexo搭建个人博客layout: postdate: 2014-03-03 19:07:43comments: truecategories: Blogtags: [Hexo]keywords: Hexo, Blogdescription: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。 模版（Scaffold）hexo new photo “My Gallery” ｜变量 ｜描述｜｜layout ｜布局｜｜title ｜标题｜｜date ｜文件建立日期｜ 设置文章摘要1以上是文章摘要 &lt;!--more--&gt; 以下是余下全文 写作hexo new page hexo new post ｜变量 ｜描述｜｜:title ｜标题｜｜:year ｜建立的年份（4 位数）｜｜:month ｜建立的月份（2 位数）｜｜:i_month ｜建立的月份（去掉开头的零）｜｜:day ｜建立的日期（2 位数）｜｜:i_day ｜建立的日期（去掉开头的零）｜ 推送到服务器上hexo n #写文章hexo g #生成hexo d #部署 #可与hexo g合并为 hexo d -g 报错1.找不到git部署1ERROR Deployer not found: git 解决方法 npm install hexo-deployer-git –save 3.部署类型设置githexo 3.0 部署类型不再是github，_config.yml 中修改 123456# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repository: git@***.github.com:***/***.github.io.git branch: master 4. xcodebuildxcode-select: error: tool ‘xcodebuild’ requires Xcode, but active developer directory ‘/Library/Developer/CommandLineTools’ is a command line tools instance npm install bcrypt 5. RSS不显示安装RSS插件 npm install hexo-generator-feed –save 开启RSS功能 编辑hexo/_config.yml，添加如下代码： 1rss: /atom.xml #rss地址 默认即可 开启评论 1.我使用多说代替自带的评论，在多说 网站注册 &gt; 后台管理 &gt; 添加新站点 &gt; 工具 === 复制通用代码 里面有 short_name 在根目录 _config.yml 添加一行 disqus_shortname: jslite 是在多说注册时产生的 复制到 themes\\landscape\\layout_partial\\article.ejs把 1234567&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt;&lt;section id=&quot;comments&quot;&gt;&lt;div id=&quot;disqus_thread&quot;&gt; &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;//disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/section&gt;&lt;% &#125; %&gt; 改为1234567891011121314151617181920&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt; &lt;section id=&quot;comments&quot;&gt; &lt;!-- 多说评论框 start --&gt; &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;&quot; data-title=&quot;&lt;%= post.title %&gt;&quot; data-url=&quot;&lt;%= page.permalink %&gt;&quot;&gt;&lt;/div&gt; &lt;!-- 多说评论框 end --&gt; &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt; &lt;script type=&quot;text/javascript&quot;&gt; var duoshuoQuery = &#123;short_name:&apos;&lt;%= config.disqus_shortname %&gt;&apos;&#125;; (function() &#123; var ds = document.createElement(&apos;script&apos;); ds.type = &apos;text/javascript&apos;;ds.async = true; ds.src = (document.location.protocol == &apos;https:&apos; ? &apos;https:&apos; : &apos;http:&apos;) + &apos;//static.duoshuo.com/embed.js&apos;; ds.charset = &apos;UTF-8&apos;; (document.getElementsByTagName(&apos;head&apos;)[0] || document.getElementsByTagName(&apos;body&apos;)[0]).appendChild(ds); &#125;)(); &lt;/script&gt; &lt;!-- 多说公共JS代码 end --&gt; &lt;/section&gt;&lt;% &#125; %&gt;","categories":[{"name":"hexo","slug":"hexo","permalink":"http://b.nearby.ren/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://b.nearby.ren/tags/hexo/"}]},{"title":"反编译操作","slug":"反编译操作","date":"2017-03-05T08:30:12.000Z","updated":"2018-12-22T01:35:01.104Z","comments":true,"path":"2017/03/05/反编译操作/","link":"","permalink":"http://b.nearby.ren/2017/03/05/反编译操作/","excerpt":"","text":"使用apktool进行反编译获取XML资源文件 apktool d -f c:\\test.apk -o c:\\test 其中，c:\\test.apk表示要反编译的apk；c:\\test表示反编译后需要保存的文件名字 apktool d -f c:\\test2.apk -o c:\\test2 使用dex2jar-0.0.9.15 进行反编译获取源代码。 dex2jar.bar classes.dex rxjava2 操作符号大全https://blog.csdn.net/philos3/article/details/78314865RxJava2.0 操作符https://www.jianshu.com/p/60ceafe8f8d0线程锁https://www.cnblogs.com/qjjazry/p/6581568.html dagger.android使用https://www.jianshu.com/p/6d3b1805f5e5https://blog.csdn.net/qq_17766199/article/details/73030696https://blog.csdn.net/soslinken/article/details/70231089https://blog.csdn.net/u010961631/article/details/72626134 https://www.colabug.com/2662538.htmlhttp://www.xitongzhijia.net/xtjc/20170310/93698.html ndk问题https://blog.csdn.net/qq_34476727/article/details/74910379","categories":[{"name":"apk","slug":"apk","permalink":"http://b.nearby.ren/categories/apk/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"},{"name":"ios","slug":"ios","permalink":"http://b.nearby.ren/tags/ios/"}]},{"title":"hexo Markdown","slug":"hexo Markdown语法","date":"2017-03-02T10:20:55.000Z","updated":"2021-08-01T10:29:32.652Z","comments":true,"path":"2017/03/02/hexo Markdown语法/","link":"","permalink":"http://b.nearby.ren/2017/03/02/hexo Markdown语法/","excerpt":"","text":"Markdown语法 1、分段： 两个回车 2、换行 两个空格 + 回车 3、标题 # ~ ###### 井号的个数表示几级标题，即Markdown可以表示一级标题到六级标题 4、引用 &gt; 5、列表 * ， + ， - ， 1. ，选其中之一，注意后面有个空格 6、代码区块 四个空格 开头 7、链接 /*[文字]/(链接地址) 8、图片 /*![图片说明]/(图片地址) ，图片地址可以是本地路劲，也可以是网络地址 9、强调 /文字/ ， /__*/文字/_/ ， /*/文字/**_/ ， /文字/ 10、代码 /```*/，/``*/ hexo 命令 1.新建 hexo new “my blog”2.编译 hexo generate 或者 hexo g3.开启本地服务 hexo server4.部署 hexo deploy 或者 hexo d5.清除 public hexo clean","categories":[{"name":"markdown","slug":"markdown","permalink":"http://b.nearby.ren/categories/markdown/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://b.nearby.ren/tags/hexo/"},{"name":"markdown","slug":"markdown","permalink":"http://b.nearby.ren/tags/markdown/"}]},{"title":"hexo部署问题","slug":"hexo部署问题","date":"2017-02-21T00:20:55.000Z","updated":"2021-10-03T02:56:03.678Z","comments":true,"path":"2017/02/21/hexo部署问题/","link":"","permalink":"http://b.nearby.ren/2017/02/21/hexo部署问题/","excerpt":"","text":"这两天学着使用hexo和github page搭建个人博客到使用hexo deploy自动部署到github page的时候出现了错误： FATAL bash: /dev/tty: No such device or addresserror: failed to execute prompt script (exit code 1)fatal: could not read Username for ‘https://github.com‘: Invalid argumentError: bash: /dev/tty: No such device or addresserror: failed to execute prompt script (exit code 1)fatal: could not read Username for ‘https://github.com‘: Invalid argument 在服务器上部署一点问题都没有，但是在本地部署是就一直报这个错误最后把_config.yml中的Git仓库链接改成了ssh链接，然后又给git账户增加了ssh key才解决了问题 要使用自动部署首先要安装hexo-deployer-git工具：$ npm install hexo-deployer-git –save 配置_config.yml中的deploy： deploy: type: git repo:git@github.com:your_github_user_name/your_github_user_name.github.io.git branch: master 注意：这里的repo需要设置成你git仓库的ssh链接 生成 ssh key 命令行中输入： $ ssh-keygen -t rsa -C greenovia@qq.com（换成你的邮箱地址）接着出现的一些步骤都可以回车跳过，如下：这样在 /c/Users/Administrator/.ssh/id_rsa文件中就生成了公钥 配置github账户的ssh key 打开id_rsa.pub文件将一整串公钥拷贝下来 进入你的github账户设置，在ssh and GPG keys中新增一个ssh key，如下 把刚刚拷贝出来的公钥粘贴到key中，title放空就好 验证ssh key： $ ssh -T git@github.com 出现下面的语句说明你的ssh key已经配置好了 Hi wispyoureyes! You’ve successfully authenticated, but GitHub does not provide shell access. 初始化本地git仓库 设置Git的user name和email： $ git config –global user.name “wuyanqina”$ git config –global user.email “greenovia@qq.com”（换成你的邮箱地址） 在本地的hexo init生成的文件夹中初始化git仓库： $ git init 将本地仓库和远程仓库连接（这一步骤可以不做）： $ git remote add origin git@github.com:your_github_user_name/your_github_user_name.github.io.git(远程仓库ssh地址) 做完以上这些步骤，说明你的仓库可以使用ssh方式来上传下载代码，而不需要输入用户名和密码了","categories":[{"name":"hexo","slug":"hexo","permalink":"http://b.nearby.ren/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://b.nearby.ren/tags/hexo/"}]},{"title":"android6.0运行时权限列表","slug":"android6-0运行时权限列表","date":"2017-02-15T03:11:49.000Z","updated":"2017-10-10T07:42:46.886Z","comments":true,"path":"2017/02/15/android6-0运行时权限列表/","link":"","permalink":"http://b.nearby.ren/2017/02/15/android6-0运行时权限列表/","excerpt":"新的权限机制更好的保护了用户的隐私，Google将权限分为两类，一类是Normal Permissions，这类权限一般不涉及用户隐私，是不需要用户进行授权的，比如手机震动、访问网络等；另一类是Dangerous Permission，一般是涉及到用户隐私的，需要用户进行授权，比如读取sdcard、访问通讯录等。","text":"新的权限机制更好的保护了用户的隐私，Google将权限分为两类，一类是Normal Permissions，这类权限一般不涉及用户隐私，是不需要用户进行授权的，比如手机震动、访问网络等；另一类是Dangerous Permission，一般是涉及到用户隐私的，需要用户进行授权，比如读取sdcard、访问通讯录等。1.Normal Permissions如下 ACCESS_LOCATION_EXTRA_COMMANDSACCESS_NETWORK_STATEACCESS_NOTIFICATION_POLICYACCESS_WIFI_STATEBLUETOOTHBLUETOOTH_ADMINBROADCAST_STICKYCHANGE_NETWORK_STATECHANGE_WIFI_MULTICAST_STATECHANGE_WIFI_STATEDISABLE_KEYGUARDEXPAND_STATUS_BARGET_PACKAGE_SIZEINSTALL_SHORTCUTINTERNETKILL_BACKGROUND_PROCESSESMODIFY_AUDIO_SETTINGSNFCREAD_SYNC_SETTINGSREAD_SYNC_STATSRECEIVE_BOOT_COMPLETEDREORDER_TASKSREQUEST_INSTALL_PACKAGESSET_ALARMSET_TIME_ZONESET_WALLPAPERSET_WALLPAPER_HINTSTRANSMIT_IRUNINSTALL_SHORTCUTUSE_FINGERPRINTVIBRATEWAKE_LOCKWRITE_SYNC_SETTINGS 2.Dangerous Permissions: group:android.permission-group.CONTACTS permission:android.permission.WRITE_CONTACTS permission:android.permission.GET_ACCOUNTS permission:android.permission.READ_CONTACTS group:android.permission-group.PHONE permission:android.permission.READ_CALL_LOG permission:android.permission.READ_PHONE_STATE permission:android.permission.CALL_PHONE permission:android.permission.WRITE_CALL_LOG permission:android.permission.USE_SIP permission:android.permission.PROCESS_OUTGOING_CALLS permission:com.android.voicemail.permission.ADD_VOICEMAIL group:android.permission-group.CALENDAR permission:android.permission.READ_CALENDAR permission:android.permission.WRITE_CALENDAR group:android.permission-group.CAMERA permission:android.permission.CAMERA group:android.permission-group.SENSORS permission:android.permission.BODY_SENSORS group:android.permission-group.LOCATION permission:android.permission.ACCESS_FINE_LOCATION permission:android.permission.ACCESS_COARSE_LOCATION group:android.permission-group.STORAGE permission:android.permission.READ_EXTERNAL_STORAGE permission:android.permission.WRITE_EXTERNAL_STORAGE group:android.permission-group.MICROPHONE permission:android.permission.RECORD_AUDIO group:android.permission-group.SMS permission:android.permission.READ_SMS permission:android.permission.RECEIVE_WAP_PUSH permission:android.permission.RECEIVE_MMS permission:android.permission.RECEIVE_SMS permission:android.permission.SEND_SMS permission:android.permission.READ_CELL_BROADCASTS","categories":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"}]},{"title":"android快捷键","slug":"android 快捷键 ","date":"2017-01-12T04:50:12.000Z","updated":"2019-03-28T03:05:52.669Z","comments":true,"path":"2017/01/12/android 快捷键 /","link":"","permalink":"http://b.nearby.ren/2017/01/12/android 快捷键 /","excerpt":"CtrlCtrl + F 在当前文件进行文本查找（必备） Ctrl + R 在当前文件进行文本替换（必备） Ctrl + Z 撤销（必备） Ctrl + Shift + Z ：还原修改 Ctrl + Y 删除光标所在行或删除选中的行（必备） Ctrl + X 剪切光标所在行或剪切选择内容","text":"CtrlCtrl + F 在当前文件进行文本查找（必备） Ctrl + R 在当前文件进行文本替换（必备） Ctrl + Z 撤销（必备） Ctrl + Shift + Z ：还原修改 Ctrl + Y 删除光标所在行或删除选中的行（必备） Ctrl + X 剪切光标所在行或剪切选择内容 Ctrl + C 复制光标所在行或复制选择内容 Ctrl + D 复制光标所在行或复制选择内容，并把复制内容插入光标位置下面（必备） Ctrl + W 递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围（必备） Ctrl + E 显示最近打开的文件记录列表 Ctrl + N 根据输入的类名查找类文件 Ctrl + G 在当前文件跳转到指定行处 Ctrl + J 插入自定义动态代码模板 Ctrl + P 方法参数提示显示 Ctrl + Q 光标所在的变量/ 类名/ 方法名等上面（也可以在提示补充的时候按），显示文档内容 Ctrl + U 前往当前光标所在的方法的父类的方法/ 接口定义 Ctrl + B 进入光标所在的方法/变量的接口或是定义出，等效于Ctrl + 左键单击 Ctrl + K 版本控制提交项目，需要此项目有加入到版本控制才可用 Ctrl + T 版本控制更新项目，需要此项目有加入到版本控制才可用 Ctrl + H 显示当前类的层次结构 Ctrl + O 选择可重写的方法 Ctrl + I 选择可继承的方法 Ctrl + + 展开代码 Ctrl + - 折叠代码 Ctrl + / 注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号（必备） Ctrl + [ 移动光标到当前所在代码的花括号开始位置 Ctrl + ] 移动光标到当前所在代码的花括号结束位置 Ctrl + F1 在光标所在的错误代码出显示错误信息 Ctrl + F3 | F3 调转到所选中的词的下一个引用位置 Shift + F3 调转到所选中的词的上一个引用位置 Ctrl + F4 关闭当前编辑文件 Ctrl + F8 在Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点 Ctrl + F9 执行Make Project 操作 Ctrl + F11 选中文件/ 文件夹，使用助记符设定/ 取消书签 Ctrl + F12 弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选 Ctrl + Tab 编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口 Ctrl + Enter 智能分隔行 Ctrl + End 跳到文件尾 Ctrl + Home 跳到文件头 Ctrl + Space 基础代码补全，默认在Windows 系统上被输入法占用，需要进行修改，建议修改为Ctrl + 逗号（必备） Ctrl + Delete 删除光标后面的单词或是中文句 Ctrl + BackSpace 删除光标前面的单词或是中文句 Ctrl + 1,2,3…9 定位到对应数值的书签位置(可作为备用键) Ctrl + 左键单击 在打开的文件标题上，弹出该文件路径 Ctrl + 光标定位 按Ctrl 不要松开，会显示光标所在的类信息摘要 Ctrl + 左方向键 光标跳转到当前单词/ 中文句的左侧开头位置 Ctrl + 右方向键 光标跳转到当前单词/ 中文句的右侧开头位置 Ctrl + 前方向键 等效于鼠标滚轮向前效果 Ctrl + 后方向键 等效于鼠标滚轮向后效果 Alt Alt + ` 显示版本控制常用操作菜单弹出层 Alt + Q 弹出一个提示，显示当前类的声明/ 上下文信息 Alt + F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择 Alt + F2 对于前面页面，显示各类浏览器打开目标选择弹出层 Alt + F3 选中文本，逐个往下查找相同文本，并高亮显示 Alt + F7 查找光标所在的方法/ 变量/ 类被调用的地方 Alt + F8 在Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果 Alt + Home 定位/ 显示到当前文件的Navigation Bar Alt + Enter IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同（必备） Alt + Insert 代码自动生成，如生成对象的set / get 方法，构造函数，toString() 等 Alt + 左方向键 按左方向切换当前已打开的文件视图 Alt + 右方向键 按右方向切换当前已打开的文件视图 Alt + 前方向键 当前光标跳转到当前文件的前一个方法名位置 Alt + 后方向键 当前光标跳转到当前文件的后一个方法名位置 Alt + 1,2,3…9 显示对应数值的选项卡，其中1 是Project 用得最多（除了1和5以为，其他可以当备用键） Shift Shift + F1 如果有外部文档可以连接外部文档 Shift + F2 跳转到上一个高亮错误或警告位置 Shift + F3 在查找模式下，查找匹配上一个 Shift + F4 对当前打开的文件，使用新Windows窗口打开，旧窗口保留 Shift + F6 对文件/ 文件夹重命名 Shift + F7 在Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法 Shift + F8 在Debug 模式下，跳出，表现出来的效果跟F9 一样 Shift + F9 等效于点击工具栏的Debug 按钮 Shift + F10 等效于点击工具栏的Run 按钮 Shift + F11 弹出书签显示层 Shift + Tab 取消缩进 Shift + ESC 隐藏当前或最后一个激活的工具窗口 Shift + End 选中光标到当前行尾位置 Shift + Home 选中光标到当前行头位置 Shift + Enter 开始新一行。光标所在行下空出一行，光标定位到新行位置 Shift + 左键单击 在打开的文件名上按此快捷键，可以关闭当前打开文件 Shift + 滚轮前后滚动当前文件的横向滚动轴滚动 Ctrl + Alt Ctrl + Alt + L 格式化代码，可以对当前文件和整个包目录使用（必备） Ctrl + Alt + O 优化导入的类，可以对当前文件和整个包目录使用（必备） Ctrl + Alt + I 光标所在行或选中部分进行自动代码缩进，有点类似格式化 Ctrl + Alt + T 对选中的代码弹出环绕选项弹出层 Ctrl + Alt + J 弹出模板选择窗口，讲选定的代码加入动态模板中 Ctrl + Alt + H 调用层次 Ctrl + Alt + B 在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口 Ctrl + Alt + V 快速引进变量 Ctrl + Alt + Y 同步、刷新 Ctrl + Alt + S 打开IntelliJ IDEA 系统设置 Ctrl + Alt + F7 显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来 Ctrl + Alt + F11 切换全屏模式 Ctrl + Alt + Enter 光标所在行上空出一行，光标定位到新行 Ctrl + Alt + Home 弹出跟当前文件有关联的文件弹出层 Ctrl + Alt + Space 类名自动完成 Ctrl + Alt + 左方向键退回到上一个操作的地方（必备） Ctrl + Alt + 右方向键前进到上一个操作的地方（必备） Ctrl + Alt + 前方向键在查找模式下，跳到上个查找的文件 Ctrl + Alt + 后方向键在查找模式下，跳到下个查找的文件 Ctrl + Shift 快捷键介绍 Ctrl + Shift + F根据输入内容查找整个项目或指定目录内文件（必备） Ctrl + Shift + R根据输入内容替换对应内容，范围为整个项目或指定目录内文件（必备） Ctrl + Shift + J自动将下一行合并到当前行末尾（必备） Ctrl + Shift + Z取消撤销（必备） Ctrl + Shift + W递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围（必备） Ctrl + Shift + N通过文件名定位/ 打开文件/ 目录，打开目录需要在输入的内容后面多加一个正斜杠（必备） Ctrl + Shift + U对选中的代码进行大/ 小写轮流转换（必备） Ctrl + Shift + T对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择 Ctrl + Shift + C复制当前文件磁盘路径到剪贴板 Ctrl + Shift + V弹出缓存的最近拷贝的内容管理器弹出层 Ctrl + Shift + E显示最近修改的文件列表的弹出层 Ctrl + Shift + H显示方法层次结构 Ctrl + Shift + B跳转到类型声明处 Ctrl + Shift + I快速查看光标所在的方法或类的定义 Ctrl + Shift + A查找动作/ 设置 Ctrl + Shift + /代码块注释（必备） Ctrl + Shift + [选中从光标所在位置到它的顶部中括号位置 Ctrl + Shift + ]选中从光标所在位置到它的底部中括号位置 Ctrl + Shift + +展开所有代码 Ctrl + Shift + -折叠所有代码 Ctrl + Shift + F7高亮显示所有该选中文本，按Esc高亮消失 Ctrl + Shift + F8在Debug 模式下，指定断点进入条件 Ctrl + Shift + F9编译选中的文件/ 包/ Module Ctrl + Shift + F12编辑器最大化 Ctrl + Shift + Space智能代码提示 Ctrl + Shift + Enter自动结束代码，行末自动添加分号（必备） Ctrl + Shift + Backspace退回到上次修改的地方 Ctrl + Shift + 1,2,3…9快速添加指定数值的书签(可以充当快捷键) Ctrl + Shift + 左方向键在代码文件上，光标跳转到当前单词/ 中文句的左侧开头位置，同时选中该单词/ 中文句 Ctrl + Shift + 右方向键在代码文件上，光标跳转到当前单词/ 中文句的右侧开头位置，同时选中该单词/ 中文句 Ctrl + Shift + 左方向键在光标焦点是在工具选项卡上，缩小选项卡区域 Ctrl + Shift + 右方向键在光标焦点是在工具选项卡上，扩大选项卡区域 Ctrl + Shift + 前方向键光标放在方法名上，将方法移动到上一个方法前面，调整方法排序 Ctrl + Shift + 后方向键光标放在方法名上，将方法移动到下一个方法前面，调整方法排序 Alt + Shift 快捷键介绍 Alt + Shift + N选择/ 添加task Alt + Shift + F显示添加到收藏夹弹出层 Alt + Shift + C查看最近操作项目的变化情况列表 Alt + Shift + F添加到收藏夹 Alt + Shift + I查看项目当前文件 Alt + Shift + F7在Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入 Alt + Shift + F9弹出Debug 的可选择菜单 Alt + Shift + F10弹出Run 的可选择菜单 Alt + Shift + 左键双击选择被双击的单词/ 中文句，按住不放，可以同时选择其他单词/ 中文句 Alt + Shift + 前方向键移动光标所在行向上移动 Alt + Shift + 后方向键移动光标所在行向下移动 Ctrl + Shift + Alt 快捷键介绍 Ctrl + Shift + Alt + V无格式黏贴 Ctrl + Shift + Alt + N前往指定的变量/ 方法 Ctrl + Shift + Alt + S打开当前项目设置 Ctrl + Shift + Alt + C复制参考信息 Debug 常用快捷键 快捷键介绍 F7在Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中必备 F8在Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内必备 F9在Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上必备 Alt + F8在Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果必备 Ctrl + F8在Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点 Shift + F7在Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法 Shift + F8在Debug 模式下，跳出，表现出来的效果跟F9 一样 Ctrl + Shift + F8在Debug 模式下，指定断点进入条件 Alt + Shift + F7在Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入 Idea 常用十大快捷键 智能提示 Intellij首当其冲的当然就是Intelligence 智能！基本的代码提示用Ctrl+Space，还有更智能地按类型信息提示Ctrl+Shift+Space，但因为Intellij总是随着我们敲击而自动提示，所以很多时候都不会手动敲这两个快捷键(除非提示框消失了)。用F2/ Shift+F2移动到有错误的代码，Alt+Enter快速修复(即Eclipse中的Quick Fix功能)。当智能提示为我们自动补全方法名时，我们通常要自己补上行尾的反括号和分号，当括号嵌套很多层时会很麻烦，这时我们只需敲Ctrl+Shift+Enter就能自动补全末尾的字符。而且不只是括号，例如敲完if/for时也可以自动补上{}花括号。 最后要说一点，Intellij能够智能感知spring、hibernate等主流框架的配置文件和类，以静制动，在看似“静态”的外表下，智能地扫描理解你的项目是如何构造和配置的。 重构 Intellij重构是另一完爆Eclipse的功能，其智能程度令人瞠目结舌，比如提取变量时自动检查到所有匹配同时提取成一个变量等。尤其看过《重构-改善既有代码设计》之后，有了Intellij的配合简直是令人大呼过瘾！也正是强大的智能和重构功能，使Intellij下的TDD开发非常顺畅。 切入正题，先说一个无敌的重构功能大汇总快捷键Ctrl+Shift+Alt+T，叫做Refactor This。按法有点复杂，但也符合Intellij的风格，很多快捷键都要双手完成，而不像Eclipse不少最有用的快捷键可以潇洒地单手完成(不知道算不算Eclipse的一大优点)，但各位用过Emacs的话就会觉得也没什么了(非Emacs黑)。此外，还有些最常用的重构技巧，因为太常用了，若每次都在Refactor This菜单里选的话效率有些低。比如Shift+F6直接就是改名，Ctrl+Alt+V则是提取变量。 代码生成 这一点类似Eclipse，虽不是独到之处，但因为日常使用频率极高，所以还是罗列在榜单前面。常用的有fori/sout/psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码，用Ctrl+J可以查看所有模板。后面“辅助”一节中将会讲到Alt+Insert，在编辑窗口中点击可以生成构造函数、toString、getter/setter、重写父类方法等。这两个技巧实在太常用了，几乎每天都要生成一堆main、System.out和getter/setter。 另外，Intellij IDEA 13中加入了后缀自动补全功能(Postfix Completion)，比模板生成更加灵活和强大。例如要输入for(User user : users)只需输入user.for+Tab。再比如，要输入Date birthday = user.getBirthday();只需输入user.getBirthday().var+Tab即可。 编辑 编辑中不得不说的一大神键就是能够自动按语法选中代码的Ctrl+W以及反向的Ctrl+Shift+W了。此外，Ctrl+Left/Right移动光标到前/后单词，Ctrl+[/]移动到前/后代码块，这些类Vim风格的光标移动也是一大亮点。以上Ctrl+Left/Right/[]加上Shift的话就能选中跳跃范围内的代码。Alt+Forward/Backward移动到前/后方法。还有些非常普通的像Ctrl+Y删除行、Ctrl+D复制行、Ctrl+折叠代码就不多说了。 关于光标移动再多扩展一点，除了Intellij本身已提供的功能外，我们还可以安装ideaVim或者emacsIDEAs享受到Vim的快速移动和Emacs的AceJump功能(超爽！)。另外，Intellij的书签功能也是不错的，用Ctrl+Shift+Num定义1-10书签(再次按这组快捷键则是删除书签)，然后通过Ctrl+Num跳转。这避免了多次使用前/下一编辑位置Ctrl+Left/Right来回跳转的麻烦，而且此快捷键默认与Windows热键冲突(默认多了Alt，与Windows改变显示器显示方向冲突，一不小心显示器就变成倒着显式的了，冏啊)。 查找打开 类似Eclipse，Intellij的Ctrl+N/Ctrl+Shift+N可以打开类或资源，但Intellij更加智能一些，我们输入的任何字符都将看作模糊匹配，省却了Eclipse中还有输入*的麻烦。最新版本的IDEA还加入了Search Everywhere功能，只需按Shift+Shift即可在一个弹出框中搜索任何东西，包括类、资源、配置项、方法等等。 类的继承关系则可用Ctrl+H打开类层次窗口，在继承层次上跳转则用Ctrl+B/Ctrl+Alt+B分别对应父类或父方法定义和子类或子方法实现，查看当前类的所有方法用Ctrl+F12。 要找类或方法的使用也很简单，Alt+F7。要查找文本的出现位置就用Ctrl+F/Ctrl+Shift+F在当前窗口或全工程中查找，再配合F3/Shift+F3前后移动到下一匹配处。 Intellij更加智能的又一佐证是在任意菜单或显示窗口，都可以直接输入你要找的单词，Intellij就会自动为你过滤。 其他辅助 以上这些神键配上一些辅助快捷键，即可让你的双手90%以上的时间摆脱鼠标，专注于键盘仿佛在进行钢琴表演。这些不起眼却是至关重要的最后一块拼图有： Ø命令：Ctrl+Shift+A可以查找所有Intellij的命令，并且每个命令后面还有其快捷键。所以它不仅是一大神键，也是查找学习快捷键的工具。 Ø新建：Alt+Insert可以新建类、方法等任何东西。 Ø格式化代码：格式化import列表Ctrl+Alt+O，格式化代码Ctrl+Alt+L。 Ø切换窗口：Alt+Num，常用的有1-项目结构，3-搜索结果，4/5-​​运行调试。Ctrl+Tab切换标签页，Ctrl+E/Ctrl+Shift+E打开最近打开过的或编辑过的文件。 Ø单元测试：Ctrl+Alt+T创建单元测试用例。 Ø运行：Alt+Shift+F10运行程序，Shift+F9启动调试，Ctrl+F2停止。 Ø调试：F7/F8/F9分别对应Step into，Step over，Continue。 此外还有些我自定义的，例如水平分屏Ctrl+|等，和一些神奇的小功能Ctrl+Shift+V粘贴很早以前拷贝过的，Alt+Shift+Insert进入到列模式进行按列选中。 最终榜单 这榜单阵容太豪华了，后几名都是如此有用，毫不示弱。 ØTop #10切来切去：Ctrl+Tab ØTop #9选你所想：Ctrl+W ØTop #8代码生成：Template/Postfix +Tab ØTop #7发号施令：Ctrl+Shift+A ØTop #6无处藏身：Shift+Shift ØTop #5自动完成：Ctrl+Shift+Enter ØTop #4创造万物：Alt+Insert太难割舍，前三名并列吧！ ØTop #1智能补全：Ctrl+Shift+Space ØTop #1自我修复：Alt+Enter ØTop #1重构一切：Ctrl+Shift+Alt+T","categories":[{"name":"android studio","slug":"android-studio","permalink":"http://b.nearby.ren/categories/android-studio/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"}]},{"title":"2017.01.01","slug":"2017-01-01","date":"2017-01-01T02:32:24.000Z","updated":"2017-01-04T09:16:44.000Z","comments":true,"path":"2017/01/01/2017-01-01/","link":"","permalink":"http://b.nearby.ren/2017/01/01/2017-01-01/","excerpt":"","text":"没什么，只是说说而已。感激似曾拥有，感谢获得重生。没什么比懂自己的心来得更重要。","categories":[{"name":"文字","slug":"文字","permalink":"http://b.nearby.ren/categories/文字/"}],"tags":[{"name":"笔录","slug":"笔录","permalink":"http://b.nearby.ren/tags/笔录/"}]},{"title":"2016","slug":"2016","date":"2016-12-31T10:53:55.000Z","updated":"2017-01-04T09:16:38.000Z","comments":true,"path":"2016/12/31/2016/","link":"","permalink":"http://b.nearby.ren/2016/12/31/2016/","excerpt":"","text":"妥协生活妥协工作妥协感情我得到了什么，又失去了什么。","categories":[{"name":"文字","slug":"文字","permalink":"http://b.nearby.ren/categories/文字/"}],"tags":[{"name":"笔录","slug":"笔录","permalink":"http://b.nearby.ren/tags/笔录/"}]},{"title":"二零一六年总结","slug":"二零一六年总结","date":"2016-12-28T07:26:24.000Z","updated":"2017-01-21T02:53:18.000Z","comments":true,"path":"2016/12/28/二零一六年总结/","link":"","permalink":"http://b.nearby.ren/2016/12/28/二零一六年总结/","excerpt":"","text":"1.情感优先于思考选择跳槽去了朋友公司。2.对问题的思考程度不是很慎重。3.太过于注重自己在熟人的位置。4.该经历的总会经历，该放下也会放下。5.以上都是屁话。","categories":[{"name":"文字","slug":"文字","permalink":"http://b.nearby.ren/categories/文字/"}],"tags":[{"name":"笔录","slug":"笔录","permalink":"http://b.nearby.ren/tags/笔录/"}]},{"title":"为你的JAVA代码配上类模块注释模板","slug":"为你的JAVA代码配上类模块注释模板","date":"2016-12-05T05:30:12.000Z","updated":"2019-07-14T08:48:38.668Z","comments":true,"path":"2016/12/05/为你的JAVA代码配上类模块注释模板/","link":"","permalink":"http://b.nearby.ren/2016/12/05/为你的JAVA代码配上类模块注释模板/","excerpt":"","text":"模板1： /* 类描述：* @author: ${user} @date： ${date} ${time} ${tags} @version 1.0 Version Date ModifiedBy Content 1.0 ${date} ${user} */ 模板1效果： /** 类描述：* @author: 逍遥梦 @date： 2014-2-22 上午10:38:41 @version 1.0 Version Date ModifiedBy Content 1.0 2014-2-22 逍遥梦 */ 模板2（个人比较喜欢）： /** Simple to Introduction @ProjectName: [${project_name}] @Package: [${package_name}] @ClassName: [${type_name}] @Description: [一句话描述该类的功能] @Author: [${user}] @CreateDate: [${date} ${time}] @UpdateUser: [${user}] @UpdateDate: [${date} ${time}] @UpdateRemark: [说明本次修改内容] @Version: [v1.0] */ 模板2效果：/** Simple to Introduction @ProjectName: [EmpMis] @Package: [cn.xym.empmis.service.impl] @ClassName: [BussinessServiceImpl] @Description: [一句话描述该类的功能] @Author: [Administrator] @CreateDate: [2014-2-22 上午10:56:16] @UpdateUser: [Administrator] @UpdateDate: [2014-2-22 上午10:56:16] @UpdateRemark: [说明本次修改内容] @Version: [v1.0] / 模板3： /** Simple To Introduction 项目名称: [${project_name}] 包: [${package_name}] 类名称: [${type_name}] 类描述: [一句话描述该类的功能] 创建人: [${user}] 创建时间: [${date} ${time}] 修改人: [${user}] 修改时间: [${date} ${time}] 修改备注: [说明本次修改内容] 版本: [v1.0] */ 模板3效果： /** Simple To Introduction 项目名称: [EmpMis] 包: [cn.xym.empmis.service.impl] 类名称: [BussinessServiceImpl] 类描述: [一句话描述该类的功能] 创建人: [Administrator] 创建时间: [2014-2-22 上午10:58:49] 修改人: [Administrator] 修改时间: [2014-2-22 上午10:58:49] 修改备注: [说明本次修改内容] 版本: [v1.0] /","categories":[{"name":"android studio","slug":"android-studio","permalink":"http://b.nearby.ren/categories/android-studio/"}],"tags":[{"name":"android studio","slug":"android-studio","permalink":"http://b.nearby.ren/tags/android-studio/"}]},{"title":"android开发要避免的那些坑","slug":"android开发要避免的那些坑","date":"2016-11-07T07:21:19.000Z","updated":"2016-11-21T14:59:36.000Z","comments":true,"path":"2016/11/07/android开发要避免的那些坑/","link":"","permalink":"http://b.nearby.ren/2016/11/07/android开发要避免的那些坑/","excerpt":"","text":"android开发要避免的那些坑","categories":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"}]},{"title":"rxjava操作符","slug":"rxjava操作符","date":"2016-11-02T02:53:49.000Z","updated":"2018-04-24T09:54:29.620Z","comments":true,"path":"2016/11/02/rxjava操作符/","link":"","permalink":"http://b.nearby.ren/2016/11/02/rxjava操作符/","excerpt":"操作符决策树 直接创建一个Observable（创建操作） 组合多个Observable（组合操作） 对Observable发射的数据执行变换操作（变换操作） 从Observable发射的数据中取特定的值（过滤操作） 转发Observable的部分值（条件/布尔/过滤操作） 对Observable发射的数据序列求值（算术/聚合操作）创建操作","text":"操作符决策树 直接创建一个Observable（创建操作） 组合多个Observable（组合操作） 对Observable发射的数据执行变换操作（变换操作） 从Observable发射的数据中取特定的值（过滤操作） 转发Observable的部分值（条件/布尔/过滤操作） 对Observable发射的数据序列求值（算术/聚合操作）创建操作用于创建Observable的操作符Create通过调用观察者的方法从头创建一个ObservableEmpty/Never/Throw创建行为受限的特殊ObservableDefer在观察者订阅之前不创建这个Observable，为每一个观察者创建一个新的ObservableJust将对象或者对象集合转换为一个会发射这些对象的ObservableFrom将其它的对象或数据结构转换为ObservableRange创建发射指定范围的整数序列的Observable,range操作符,发射从start开始的count个数Interval间隔一定时间发送一个数字,从0开始.本身运行在Schedulers.computation() 线程内RepeatRepeat作用在Observable上,会对其重复发射count次TimerTimer会在指定时间后发射一个数字0，注意其也是运行在computation Scheduler变换操作 对Observable发射的数据进行变，能将数据转化为我们想要的格式，Buffer缓存，可以简单的理解为缓存，它定期从Observable收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个FlatMap扁平映射，将Observable发射的数据变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable，可以认为是一个将嵌套的数据结构展开的过程。GroupBy分组，将原来的Observable分拆为Observable集合，将原始Observable发射的数据按Key分组，每一个Observable发射一组不同的数据Map映射，通过对序列的每一项都应用一个函数变换Observable发射的数据，实质是对序列中的每一项执行一个函数，函数的参数就是这个数据项Scan扫描， 连续地对数据序列的每一项应用一个函数，然后连续发射结果,每一项结果基于之前的结果.累加器函数.Window窗口，定期将来自Observable的数据分拆成一些Observable窗口，然后发射这些窗口，而不是每次发射一项。类似于Buffer，但Buffer发射的是数据，Window发射的是Observable，每一个Observable发射原始Observable的数据的一个子集toListReturns an Observable that emits a single item, a list composed of all the items emitted by the source Observable. 将一个Observable转换为一个List.过滤操作 滤掉数据集合中我们不想要的数据。用于从Observable发射的数据中进行选择。throttleWithTimeout源Observable每次发射出来一个数据后就会进行计时,如果在设定好的时间结束前源Observable有新的数据发射出来，这个数据就会被丢弃，同时重新开始计时。Debounce只有在空闲了一段时间后才发射数据，通俗的说，就是如果一段时间没有操作，就执行一次操作.还可以根据一个函数来进行限流。这个函数的返回值是一个临时Observable，如果源Observable在发射一个新的数据的时候，上一个数据根据函数所生成的临时Observable还没有结束,没有调用onComplete，那么上一个数据就会被过滤掉。如果是最后一个,还是会发射.Distinct去重，过滤掉所有的重复数据项DistinctUtilChanged过滤掉相邻的重复项ElementAt取值，取特定位置的数据项Filter过滤，过滤掉没有通过谓词测试的数据项，只发射通过测试的First取满足条件的第一个,如无满足条件数据抛出异常.可以使用takeFisrt(),仅会调动onComplete.有null数据时会抛空指针异常,要判空处理.只取满足条件的第一个数据.可以和BlockingObservable连用。可以Observable.toBlocking或者BlockingObservable.from方法来将一个Observable对象转化为BlockingObservable对象Last末项，只发射最后一条数据.IgnoreElements忽略所有的数据，只保留终止通知(onError或onCompleted)Sample取样，定期发射最新的数据，等于是数据抽样，有的实现里叫ThrottleFirstthrottleFirst会定期发射这个时间段里源Observable发射的第一个数据Skip跳过前面的若干项数据SkipLast跳过后面的若干项数据Take只保留前面的若干项数据TakeLast只保留后面的若干项数据takeFirst有null数据时会抛空指针异常,要判空处理和first一样，但在所有数据不满足条件时不会抛出异常，仅仅调用onComplete.组合操作 And/Then/When通过模式(And条件)和计划(Then次序)组合两个或多个Observable发射的数据集CombineLatest当两个Observables中的任何一个发射了一个数据时，通过一个指定的函数组合每个Observable发射的最新数据（一共两个数据），然后发射这个函数的结果必须满足两个条件:1)所有的Observable都发射过数据。2)满足条件1的时候任何一个Observable发射一个数据，就将所有Observable最新发射的数据按照提供的函数组装起来发射出去。在这两个条件下,可能会忽略掉一些发射的数据.Join无论何时，如果一个Observable发射了一个数据项，只要在另一个Observable发射的数据项定义的时间窗口内，就将两个Observable发射的数据合并发射参数说明:1)源Observable所要组合的目标Observable2)一个函数，就收从源Observable发射来的数据，并返回一个Observable，这个Observable的生命周期决定了源Observable发射出来数据的有效期3)一个函数，就收从目标Observable发射来的数据，并返回一个Observable，这个Observable的生命周期决定了目标Observable发射出来数据的有效期4)一个函数，接收从源Observable和目标Observable发射来的数据，并返回最终组合完的数据。Merge将两个Observable发射的数据组合并成一个Merge可能会让合并的Observables发射的数据交错（可以使用Concat操作符,不会让数据交错，它会按顺序一个接着一个发射多个Observables的发射物）。StartWith在发射原来的Observable的数据序列之前，先发射一个指定的数据序列或数据项在数据序列的开头插入一条指定的项你也可以传递一个Observable给startWith，它会将那个Observable的发射物插在原始Observable发射的数据序列之前.这可以看作是Concat的反转。Switch，在RxJava的实现为SwitchOnNext将一个发射Observable序列的Observable转换为这样一个Observable：它逐个发射那些Observable最近发射的数据用来将一个发射多个小Observable的源Observable转化为一个Observable，然后发射这多个小Observable所发射的数据。需要注意的就是，如果一个小的Observable正在发射数据的时候，源Observable又发射出一个新的小Observable，则前一个Observable发射的数据会被抛弃，直接发射新的小Observable所发射的数据。Zipzip zipWith打包，使用一个指定的函数将多个Observable发射的数据组合在一起，然后将这个函数的结果作为单项数据发射Zip操作符将多个Observable发射的数据按顺序组合起来，每个数据只能组合一次，而且都是有序的。最终组合的数据的数量由发射数据最少的Observable来决定。错误处理 这些操作符用于从错误通知中恢复Catch捕获，继续序列操作，将错误替换为正常的数据，从onError通知中恢复onErrorReturn当发生错误的时候，让Observable发射一个预先定义好的数据并正常地终止,不会抛出异常 onErrorResumeNext当发生错误的时候，由另外一个Observable来代替当前的Observable并继续发射数据 onExceptionResumeNext类似于OnErrorResume,不同之处在于其会对onError抛出的数据类型做判断，如果是Exception，也会使用另外一个Observable代替原Observable继续发射数据，否则会将错误分发给Subscriber。Retry重试，如果Observable发射了一个错误通知，重新订阅它，期待它正常终止retryRetry操作符在发生错误的时候会重新进行订阅,而且可以重复多次，所以发射的数据可能会产生重复。如果重复指定次数还有错误的话就会将错误返回给观察者,会掉onError retryWhen当错误发生时，retryWhen会接收onError的throwable作为参数，并根据定义好的函数返回一个Observable，如果这个Observable发射一个数据，就会重新订阅。需要注意的是使用retryWhen的时候,因为每次重新订阅都会产生错误，所以作为参数的obserbvable会不断地发射数据，使用zipWith操作符可以限制重新订阅的次数，否则会无限制地重新订阅。会正常结束,调用onCompleted辅助操作 Delay延迟一段时间发射结果数据DelaySubscription延迟注册到Observer上DoDo操作符就是给Observable的生命周期的各个阶段加上一系列的回调监听，当Observable执行到这个阶段的时候，这些回调就会被触发.doOnEachObservable每发射一个数据的时候就会触发这个回调，不仅包括onNext还包括onError和onCompleted。doOnNext只有onNext的时候才会被触发。doOnSubscribe,doOnUnSubscribe会在Subscriber进行订阅和反订阅的时候触发回调。当一个Observable通过OnError或者OnCompleted结束的时候，会反订阅所有的Subscriber。在Android中和生命周期绑定起来,因为有些Observable执行不完啊.doOnSubscribeOn在开始注册前做一些工作。处于当前线程，而不是subscribeOn指定的线程。DoOnError在OnError发生的时候触发回调，并将Throwable对象作为参数传进回调函数里。DoOnComplete会在OnCompleted发生的时候触发回调。DoOnTerminate会在Observable结束前触发回调，无论是正常还是异常终止。finallyDo,doAfterTerminate会在Observable结束后触发回调，无论是正常还是异常终止。Materialize,dematerializeMeterialize操作符将OnNext/OnError/OnComplete都转化为一个Notification对象并按照原来的顺序发射出来,dematerialize相反使用integerNotification.getValue() +”, ” + integerNotification.getKind()可以看到打印值和类型.ObserveOn指定Subscriber的调度程序（工作线程）SubscribeOn指定Observable应该在哪个调度程序上执行Serialize强制Observable按次序发射数据并且功能是有效的Subscribe收到Observable发射的数据和通知后执行的操作TimeInterval将一个Observable转换为发射两个数据之间所耗费时间的ObservableTimeInterval会拦截发射出来的数据，取代为前后两个发射两个数据的间隔时间。对于第一个发射的数据，其时间间隔为订阅后到首次发射的间隔。Timeout添加超时机制，如果过了指定的一段时间没有发射数据，就发射一个错误通知Timeout操作符给Observable加上超时时间，每发射一个数据后就重置计时器，当超过预定的时间还没有发射下一个数据，就抛出一个超时的异常。Rxjava将Timeout实现为很多不同功能的操作符，比如说超时后用一个备用的Observable继续发射数据等。Timestamp给Observable发射的每个数据项添加一个时间戳TimeStamp会将每个数据项给重新包装一下，加上了一个时间戳来标明每次发射的时间Using创建一个只在Observable的生命周期内存在的一次性资源Using操作符创建一个在Observable生命周期内存活的资源，也可以这样理解：我们创建一个资源并使用它，用一个Observable来限制这个资源的使用时间，当这个Observable终止的时候，这个资源就会被销毁。Using需要使用三个参数，分别是：1)创建这个一次性资源的函数2)创建Observable的函数3)释放资源的函数条件和布尔操作 这些操作符可用于单个或多个数据项，也可用于ObservableAll判断Observable发射的所有的数据项是否都满足某个条件All操作符根据一个函数对源Observable发射的所有数据进行判断，最终返回的结果就是这个判断结果。对发射的所有数据应用这个函数,如果全部都满足则返回true，否则就返回false。AmbAmb操作符可以将至多9个Observable结合起来，让他们竞争。哪个Observable首先发射了数据（包括onError和onComplete)就会继续发射这个Observable的数据，其他的Observable所发射的数据都会别丢弃。Contains判断Observable是否会发射一个指定的数据项Contains操作符用来判断源Observable所发射的数据是否包含某一个数据，如果包含会返回true，如果源Observable已经结束了却还没有发射这个数据则返回false。IsEmptyIsEmpty操作符用来判断源Observable是否发射过数据，没有发射过数据返回true.Null也是一个数据DefaultIfEmpty发射来自原始Observable的数据，如果原始Observable没有发射数据，就发射一个默认数据会判断源Observable是否发射数据，如果源Observable发射了数据则正常发射这些数据，如果没有则发射一个默认的数据SequenceEqual判断两个Observable是否按相同的数据序列SequenceEqual操作符用来判断两个Observable发射的数据序列是否相同（发射的数据相同，数据的序列相同，结束的状态相同），如果相同返回true，否则返回falseSkipUntilSkipUnitl是根据一个标志Observable来判断的，当这个标志Observable没有发射数据的时候，所有源Observable发射的数据都会被跳过；当标志Observable发射了一个数据，则开始正常地发射数据。一直等到skipUntil发射了数据才能发射源Observable的数据,并忽略了此段时间内的数据SkipWhileSkipWhile则是根据一个函数来判断是否跳过数据，当函数返回值为true的时候则一直跳过源Observable发射的数据；当函数返回false的时候则开始正常发射数据。TakeUntil和SkipUtil恰好相反,只获取takeUntil里的Observable之前的数据TakeWhile和SkipWhile相反,获取满足skipWhile的数据算术和聚合操作 Concat将多个Observable结合成一个Observable并发射数据，并且严格按照先后顺序发射数据，前一个Observable的数据没有发射完，不发射后面Observable的数据CountCount操作符用来统计源Observable发射了多少个数据，最后将数目给发射出来；如果源Observable发射错误，则会将错误直接报出来；在源Observable没有终止前，count是不会发射统计数据的。ReduceReduce操作符应用一个函数接收Observable发射的数据和函数的计算结果作为下次计算的参数，输出最后的结果。跟前面我们了解过的scan操作符很类似，只是scan会输出每次计算的结果，而reduce只会输出最后的结果。Collectcollect用来将源Observable发射的数据给收集到一个数据结构里面，需要使用两个参数：一个产生收集数据结构的函数一个接收第一个函数产生的数据结构和源Observable发射的数据作为参数的函数。连接操作 一些有精确可控的订阅行为的特殊Observable什么是Connectable Observable:就是一种特殊的Observable对象，并不是Subscrib的时候就发射数据，而是只有对其应用connect操作符的时候才开始发射数据，所以可以用来更灵活的控制数据发射的时机。使用Publish操作符将Observable转换为Connectable Observable,然后可以通过connect控制何时发射.Publish将一个普通的Observable转换为可连接的Publish操作符就是用来将一个普通的Observable对象转化为一个Connectable Observable。需要注意的是如果发射数据已经开始了再进行订阅只能接收以后发射的数据。ConnectConnect操作符就是用来触发Connectable Observable发射数据的。应用Connect操作符后会返回一个Subscription对象，通过这个Subscription对象，我们可以调用其unsubscribe方法来终止数据的发射。另外，如果还没有订阅者订阅的时候就应用Connect操作符也是可以使其开始发射数据的。RefCountRefCount操作符就是将一个Connectable Observable 对象再重新转化为一个普通的Observable对象，这时候订阅者进行订阅时就会触发数据的发射。ReplayReplay操作符返回一个Connectable Observable 对象并且可以缓存其发射过的数据，这样即使有订阅者在其发射数据之后进行订阅也能收到其之前发射过的数据。不过使用Replay操作符我们最好还是限定其缓存的大小，否则缓存的数据太多了可会占用很大的一块内存。对缓存的控制可以从空间和时间两个方面来实现。直接返回一个connectable observable,不用publish转换操作 to自定义操作符 lift compose rxjava汇总链接","categories":[{"name":"rxjava","slug":"rxjava","permalink":"http://b.nearby.ren/categories/rxjava/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"},{"name":"rxjava","slug":"rxjava","permalink":"http://b.nearby.ren/tags/rxjava/"},{"name":"rxandroid","slug":"rxandroid","permalink":"http://b.nearby.ren/tags/rxandroid/"}]},{"title":"Tinker[微信]热更新","slug":"Tinker[微信]热更新","date":"2016-11-02T02:53:49.000Z","updated":"2018-04-26T06:16:52.776Z","comments":true,"path":"2016/11/02/Tinker[微信]热更新/","link":"","permalink":"http://b.nearby.ren/2016/11/02/Tinker[微信]热更新/","excerpt":"","text":"现在市面上有很多热更新的开源比如：Tinker、QZone、Andfix、Robust比较 https://blog.csdn.net/hao_m582/article/details/78694439","categories":[{"name":"tinker","slug":"tinker","permalink":"http://b.nearby.ren/categories/tinker/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"}]},{"title":"android常用的算法","slug":"android常用的算法","date":"2016-11-01T08:20:48.000Z","updated":"2021-06-03T14:56:46.269Z","comments":true,"path":"2016/11/01/android常用的算法/","link":"","permalink":"http://b.nearby.ren/2016/11/01/android常用的算法/","excerpt":"","text":"1.插入排序算法 插入排序的基本思想是在遍历数组的过程中，假设在序号 i 之前的元素即 [0..i-1] 都已经排好序，本趟需要找到 i 对应的元素 x 的正确位置 k ，并且在寻找这个位置 k 的过程中逐个将比较过的元素往后移一位，为元素 x “腾位置”，最后将 k 对应的元素值赋为 x ，一般情况下，插入排序的时间复杂度和空间复杂度分别为 O(n2 ) 和 O(1)。1234567891011public int [] sortInsert(int[] array)&#123; for(int i = 1 ; i &lt; array.length; i++)&#123; int temp = array[i]; int j ; for ( j = i - 1; j &gt;= 0 &amp;&amp; temp &lt; array[j] ; j--)&#123; array[ j + 1 ] = array[j]; &#125; array[ j + i ] = temp; &#125; return array;&#125; 2.选择排序算法选择排序的基本思想是遍历数组的过程中，以 i 代表当前需要排序的序号，则需要在剩余的 [i…n-1] 中找出其中的最小值，然后将找到的最小值与 i 指向的值进行交换。因为每一趟确定元素的过程中都会有一个选择最大值的子流程，所以人们形象地称之为选择排序。选择排序的时间复杂度和空间复杂度分别为 O(n2 ) 和 O(1) 。1234567891011121314151617181920212223242526272829303132333435363738 public int[] sortSelect(int[] arr)&#123; for (int i = 0; i &lt; arr.length; i++) &#123; int miniPost = i; for (int m = i + 1; m &lt; arr.length; m++) &#123; if (arr[m] &lt; arr[miniPost]) &#123; miniPost = m; &#125; &#125; if (arr[i] &gt; arr[miniPost]) &#123; int temp; temp = arr[i]; arr[i] = arr[miniPost]; arr[miniPost] = temp; &#125; &#125; return arr; &#125;``` # 3.冒泡排序算法## 冒泡排序是將比較大的數字沉在最下面，较小的浮在上面``` public int[] sortBubble(int[] array)&#123; int temp; // 第一层循环:表明比较的次数, 比如 length 个元素,比较次数为 length-1 次（肯定不需和自己比） for(int i=0;i&lt;array.length-1;i++)&#123; for (int j = array.length - 1; j &gt; i; j--) &#123; if (array[j] &lt; array[j - 1]) &#123; temp = array[j]; array[j] = array[j - 1]; array[j - 1] = temp; &#125; &#125; &#125; return array; 4.快速排序算法通过一趟排序将待排记录分割成独立的两部分,其中一部分记录的关键字均比另一部分的关键字小,则可以分别对这两部分记录继续进行排序,已达到整个序列有序的目的，本质就是,找一个基位(枢轴,分水岭,作用是左边的都比它小,右边的都比它大.可随机,取名base，首先从序列最右边开始找比base小的,如果小,换位置,从而base移到刚才右边(比较时比base小)的位置(记为临时的high位),这样base右边的都比base大。然后,从序列的最左边开始找比base大的，如果大,换位置,从而base移动到刚才左边(比较时比base大)的位置(记为临时的low位),这样base左边的都比base小，循环以上两步,直到 low == heigh, 这使才真正的找到了枢轴,分水岭. 返回这个位置,分水岭左边和右边的序列,分别再来递归。 12345678910111213public int[] sortQuick(int[] array)&#123; return quickSort(array, 0, array.length-1); &#125; private int[] quickSort(int[] arr, int low, int heigh) &#123; if (low &lt; heigh) &#123; int division = partition(arr, low, heigh); quickSort(arr, low, division - 1); quickSort(arr, division + 1, heigh); &#125; return arr; &#125; 分水岭,基位,左边的都比这个位置小,右边的都大 123456789101112131415161718192021222324private int partition(int[] arr, int low, int heigh) &#123; int base = arr[low]; //用子表的第一个记录做枢轴(分水岭)记录 while (low &lt; heigh) &#123; //从表的两端交替向中间扫描 while (low &lt; heigh &amp;&amp; arr[heigh] &gt;= base) &#123; heigh--; &#125; // base 赋值给 当前 heigh 位,base 挪到(互换)到了这里,heigh位右边的都比base大 swap(arr, heigh, low); while (low &lt; heigh &amp;&amp; arr[low] &lt;= base) &#123; low++; &#125; // 遇到左边比base值大的了,换位置 swap(arr, heigh, low); &#125; // now low = heigh; return low; &#125;private void swap(int[] arr, int a, int b) &#123; int temp; temp = arr[a]; arr[a] = arr[b]; arr[b] = temp; &#125; 5.合并排序算法##归并排序采用的是递归来实现，属于“分而治之”，将目标数组从中间一分为二，之后分别对这两个数组进行排序，排序完毕之后再将排好序的两个数组“归并”到一起，归并排序最重要的也就是这个“归并”的过程，归并的过程中需要额外的跟需要归并的两个数组长度一致的空间123456789101112131415161718192021222324252627282930313233343536373839404142private int[] sort(int[] nums, int low, int high) &#123; int mid = (low + high) / 2; if (low &lt; high) &#123; // 左边 sort(nums, low, mid); // 右边 sort(nums, mid + 1, high); // 左右归并 merge(nums, low, mid, high); &#125; return nums;&#125;private void merge(int[] nums, int low, int mid, int high) &#123; int[] temp = new int[high - low + 1]; int i = low;// 左指针 int j = mid + 1;// 右指针 int k = 0; // 把较小的数先移到新数组中 while (i &lt;= mid &amp;&amp; j &lt;= high) &#123; if (nums[i] &lt; nums[j]) &#123; temp[k++] = nums[i++]; &#125; else &#123; temp[k++] = nums[j++]; &#125; &#125; // 把左边剩余的数移入数组 while (i &lt;= mid) &#123; temp[k++] = nums[i++]; &#125; // 把右边边剩余的数移入数组 while (j &lt;= high) &#123; temp[k++] = nums[j++]; &#125; // 把新数组中的数覆盖nums数组 for (int k2 = 0; k2 &lt; temp.length; k2++) &#123; nums[k2 + low] = temp[k2]; &#125; &#125; public int[] sortMerge(int[] array) &#123; return sort(array, 0, array.length - 1);&#125; 6.希尔排序算法希尔排序的诞生是由于插入排序在处理大规模数组的时候会遇到需要移动太多元素的问题。希尔排序的思想是将一个大的数组“分而治之”，划分为若干个小的数组，以 gap 来划分，比如数组 [1, 2, 3, 4, 5, 6, 7, 8] ，如果以 gap = 2 来划分，可以分为 [1, 3, 5, 7] 和 [2, 4, 6, 8] 两个数组（对应的，如 gap = 3 ， 则划分的数组为： [1, 4, 7] 、 [2, 5, 8] 、 [3, 6] ）然后分别对划分出来的数组进行插入排序，待各个子数组排序完毕之后再减小 gap 值重复进行之前的步骤，直至 gap = 1 ，即对整个数组进行插入排序，此时的数组已经基本上快排好序了，所以需要移动的元素会很小很小，解决了插入排序在处理大规模数组时较多移动次数的问题， 希尔排序是插入排序的改进版，在数据量大的时候对效率的提升帮助很大，数据量小的时候建议直接使用插入排序就好了。 1234567891011121314151617public int[] sortShell(int[] array) &#123; // 取增量 int step = array.length / 2; while (step &gt;= 1) &#123; for (int i = step; i &lt; array.length; i++) &#123; int temp = array[i]; int j = 0; // 跟插入排序的区别就在这里 for (j = i - step; j &gt;= 0 &amp;&amp; temp &lt; array[j]; j -= step) &#123; array[j + step] = array[j]; &#125; array[j + step] = temp; &#125; step /= 2; &#125; return array;&#125; 7.堆排序算法本质就是先构造一个大顶堆,parent比children大,root节点就是最大的节点 把最大的节点(root)与尾节点(最后一个节点,比较小)位置互换，剩下最后的尾节点,现在最大,其余的,从第一个元素开始到尾节点前一位,构造大顶堆递归。12345678910111213141516171819202122232425262728293031public int[] sortHeap(int[] array) &#123; buildHeap(array);// 构建堆 int n = array.length; int i = 0; for (i = n - 1; i &gt;= 1; i--) &#123; swap(array, 0, i); heapify(array, 0, i); &#125; return array; &#125;private void buildHeap(int[] array) &#123; int n = array.length;// 数组中元素的个数 for (int i = n / 2 - 1; i &gt;= 0; i--) heapify(array, i, n);&#125;private void heapify(int[] A, int idx, int max) &#123; int left = 2 * idx + 1;// 左孩子的下标（如果存在的话） int right = 2 * idx + 2;// 左孩子的下标（如果存在的话） int largest = 0;// 寻找3个节点中最大值节点的下标 if (left &lt; max &amp;&amp; A[left] &gt; A[idx]) largest = left; else largest = idx; if (right &lt; max &amp;&amp; A[right] &gt; A[largest]) largest = right; if (largest != idx) &#123; swap(A, largest, idx); heapify(A, largest, max); &#125; &#125;&#125; 建堆函数，认为【s，m】中只有 s对应的关键字未满足大顶堆定义，通过调整使【s，m】成为大顶堆 1234567891011121314151617181920public static void heapAdjust(int[] array, int s, int m) &#123; // 用0下标元素作为暂存单元 array[0] = array[s]; // 沿孩子较大的结点向下筛选 for (int j = 2 * s; j &lt;= m; j *= 2) &#123; // 保证j为较大孩子结点的下标，j &lt; m 保证 j+1 &lt;= m ，不越界 if (j &lt; m &amp;&amp; array[j] &lt; array[j + 1]) &#123; j++; &#125; if (!(array[0] &lt; array[j])) &#123; break; &#125; // 若S位较小，应将较大孩子上移 array[s] = array[j]; // 较大孩子的值变成S位的较小值，可能引起顶堆的不平衡，故对其所在的堆进行筛选 s = j; &#125;// 若S位较大，则值不变；否则，S位向下移动至2*s、4*s、。。。array[s] = array[0];&#125;","categories":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"},{"name":"算法","slug":"算法","permalink":"http://b.nearby.ren/tags/算法/"}]},{"title":"一路走来","slug":"一路走来","date":"2016-11-01T01:26:17.000Z","updated":"2016-11-21T14:59:36.000Z","comments":true,"path":"2016/11/01/一路走来/","link":"","permalink":"http://b.nearby.ren/2016/11/01/一路走来/","excerpt":"","text":"2014.07.10-12 坐绿皮火车卧铺，学校同班几个伙伴，说说笑笑，经历两天的时间，抵达了梦寐已久的之都，深圳。【因为两年前的我，曾经说一句话，我毕业后第一站就是深圳。】 2014.07.15-25 那时的我们还带着学校的稚气，未毕业就踏入社会之门，我们以为社会应该跟学校差不多，其实错了，一开始我们以毕业生的姿态，拿着不是很起眼的学历，奔波于地铁、公交， 不断的求职，在一次一次挫折后，我们开始披上社会的面具，伪造假学历，毕业证书，说着不太切实际的话，职位才向我们敞开大门。这是我的第一份工作太突然，做了两个星期就离开，那时的我没自信，恐惧，加上没钱了跟爸妈提拿钱时，倒出了自己的离职，也被说一顿。 2014.07.15-2015.06.31 从上家公司离职后，突然大病一场，带着病找了一周时间，没找到面试的工作机会，那时真的很失望。这时同班的同学介绍我去她公司面试，我带自己的简历与在学校做的作品，终于敲开了入职之门。这是我的入职二家公司呆了一年。这里年的时间里，我学到很多很多东西，也是最深刻的一年，经历太多，种种原因，坚持到了合同结束，没有想过续签合同的就走了。 2015.07.04-2016.06.31 第三家公司，面试了几天两个off，第一个off，是早上去同学公司面试。第二个off下午自己找到的公司，这家也是我一年多以来最自信，最爽快的面试经历。在一天的考虑之中。最终还是去了同学的公司。然而没呆到合同结束就走人了。非常感谢自己的上司热情款待，部门老大的教育，带我们疯，带我们闹。 2016.7.-至今 第四家公司，突然来到这家公司是跳槽过来的，上家公司环境，待遇算可以，但是公司的产品迭代太慢，闲就是一个月以上，考虑一个星期多。最后还是选择跳槽来到了这家公司就为了两点，未接触过的技术点。待遇提升。","categories":[{"name":"文字","slug":"文字","permalink":"http://b.nearby.ren/categories/文字/"}],"tags":[{"name":"文字","slug":"文字","permalink":"http://b.nearby.ren/tags/文字/"}]},{"title":"dagger2mvp架构使用","slug":"dagger2mvp架构使用","date":"2016-10-31T08:02:34.000Z","updated":"2021-06-03T14:57:51.686Z","comments":true,"path":"2016/10/31/dagger2mvp架构使用/","link":"","permalink":"http://b.nearby.ren/2016/10/31/dagger2mvp架构使用/","excerpt":"","text":"了解请点击dagger2基础了解 dagger2使用教程： 根目录的build文件加入android-apt支持123456789101112131415161718192021222324252627282930313233343536373839环境配置：buildscript&#123; repositories&#123; jcenter() &#125;&#125;dependencies&#123; classpath &apos;com.android.tools.build:gradle:x.x.x&apos; classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.4&apos;&#125;在app目录的build文件加入 apt plugin的支持plugin : &apos;com.neenbeankt.android-apt&apos; 加入dagger2 retrofit okhttp依赖 compile &apos;com.google.dagger:dagger:2.0&apos; apt &apos;com.google.dagger:dagger-compiler:2.0&apos; provided &apos;org.glassfish:javax.annotation:10.0-b28&apos; 在Application中实践Dagger2 现在依赖已经加入，开始动手使用Dagger2，第一步考虑我们Application。 先创建AppApplication，并在AndroidMainfest.xml 注册好。 public class AppApplication extends Application&#123; public void onCreate()&#123; super.onCreate(); &#125;&#125;&lt;application android:name=&quot;.AppApplication&quot; android:allowBackuo=&quot;true&quot; android:icon=&quot;@mipmap/ic_lacuncher&quot; android:label=&quot;@string/app_name&quot; android:label=&quot;@string/app_name&quot; /&gt;","categories":[{"name":"mvp","slug":"mvp","permalink":"http://b.nearby.ren/categories/mvp/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"},{"name":"mvp","slug":"mvp","permalink":"http://b.nearby.ren/tags/mvp/"},{"name":"dagger2","slug":"dagger2","permalink":"http://b.nearby.ren/tags/dagger2/"}]},{"title":"android断点调试","slug":"android断点调试","date":"2016-10-31T01:47:42.000Z","updated":"2018-07-23T05:36:32.447Z","comments":true,"path":"2016/10/31/android断点调试/","link":"","permalink":"http://b.nearby.ren/2016/10/31/android断点调试/","excerpt":"","text":"Android Studio包含一个debugger程序,可以帮助你在模拟器和真机上调试你的android应用.通过Android Studio的debugger,你可以: 1.选择你想调试的设备.2.在代码上设置断点.3.在运行时去检查变量和表达式的值.可能平时大家调试代码都是通过打印log的形式,今天带大家走进断点调试的世界. 断点调试-基础篇设置断点设置断点的方法: 左键在需要调试的代码所处的侧边栏处单击.如下图所示: 开始调试点击红色箭头指向的按钮,即可进行代码调试,如下图所示:调试界面如下所示:单步调试Step Over(F6)代表程序直接执行当前行代码.(ps:如果该行是函数调用,则直接执行完函数的全部代码)Step Into(F5)代表程序执行当前行代码(ps:如果该行有自定义方法,则运行进入自定义方法,不会进入官方类库的方法)具体效果如下:Step Out(F7)跳出Step Into进入的方法.例如我们感觉进入的方法没有问题,不需要执行后续代码,就可以通过Step Out跳出当前进入的代码.","categories":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"},{"name":"mvp","slug":"mvp","permalink":"http://b.nearby.ren/tags/mvp/"}]},{"title":"dagger2学习","slug":"dagger2学习","date":"2016-10-28T06:54:43.000Z","updated":"2021-06-03T15:04:53.581Z","comments":true,"path":"2016/10/28/dagger2学习/","link":"","permalink":"http://b.nearby.ren/2016/10/28/dagger2学习/","excerpt":"","text":"为什么使用依赖注入使用依赖注入的可以带来以下好处： 依赖的注入和配置独立于组件之处。 因为对象是在一个独立、不耦合的地方初始化，所以当注入抽象方法的时候，我们只需要修改对象的实现方式，而不是用大改代码库。 以来可以注入到一个组件中：我们可以注入这些依赖的模拟实现，这样使得测试更加简单。 基本特点 多个注入点:依赖，通过injected 多种绑定方法:以来，通过provided 多个modules:实现某种功能的绑定集合 多个对象图:实现一个范围的modules集合 区别点 再也没有使用反射:图的验证、配置和预先设置都在编译的时候执行。 容易调试和可跟踪:完全具体地调用提供和创建的堆栈。 更过的性能:谷歌声称他们提高了13%的处理性能 代码混淆:使用派遣方法，就如同自己写的代码一样当然素偶有这些很棒的特点都需要付出一个代价，那就是缺乏灵活性，例如：dagger2没用反射所有没有动态机制。 概念与注入 @Inject：通常在需要依赖的地方使用这个注解.换句话说，你用它告诉Dagger这个类或者字段需要依赖注入。这样，Dagger就会构造一个这个类的实例并满足他们的依赖。 @Module：Modules类里面的方法专门提供依赖，所以我们定义一个类，用@Module注解，这样dagger在构造类的实例的时候，就知道从哪里去找到需要的依赖。modules的一个重要的特征它们设计分区并组合在一起(比如说，在我们的app中可以有多个组成在一起的modules)。 @Provide：再modules中，我们定义的方法是用这哥注解，以此告诉dagger我们想要构造对象并提供这些依赖。 @Component:Components从根本上说就是一个注入器，也可以说是@Inject和@Modules的桥梁，它的主要作用就是连接这两个部分。Components可以提供所有定义了的类型的实例，比如：我们必须用@Componets注解一个借口然后列出所有的@Modules组成该组件，如果缺失了任何一块都在编译的时候报错。所有的组件都可以通过它的modules知道依赖的范围。 @Scope:Scope可是非常的有用，dagger2可以通过自定义注解限定注解的作用域。 @Qualifier:当类的类型不足以鉴别一个依赖的时候，我们就可以使用这个注解表示。 使用方式123456789101112131415161718192021222324app-&gt;build.gradle apply plugin: &apos;com.neenbedankt.android-apt&apos; buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.4&apos; &#125; &#125; android &#123; ... &#125; dependencies &#123; apt &apos;com.google.dagger:dagger-compiler:2.0&apos; compile &apos;com.google.dagger:dagger:2.0&apos; ... &#125; 如上所示，我们添加了编译和运行库，还有必不可少的apt插件，没有这插件，dagger可能不会正常工作，特别是在Android studio中。 dagger2注解的使用方式 构造方法注入：在类的构造方法前面注入@Inject 成员变量注入：在类的成员变量(非私有)前面注解@Inject 函数方法注入：在函数前面注解@Inject","categories":[{"name":"dagger2","slug":"dagger2","permalink":"http://b.nearby.ren/categories/dagger2/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"},{"name":"dagger2","slug":"dagger2","permalink":"http://b.nearby.ren/tags/dagger2/"}]},{"title":"android基于HLS和TRMP协议的第三方SDK选择","slug":"android基于HLS和TRMP协议的第三方SDK选择","date":"2016-10-28T01:29:49.000Z","updated":"2016-11-21T14:59:36.000Z","comments":true,"path":"2016/10/28/android基于HLS和TRMP协议的第三方SDK选择/","link":"","permalink":"http://b.nearby.ren/2016/10/28/android基于HLS和TRMP协议的第三方SDK选择/","excerpt":"","text":"协议的详解网上资料都太多了，我就不赘述了。Android上3.0开始支持hls，但在4.0以后就支持的不太好了。而对rtmp来说，Android是默认不支持的。网上有一些第三方库支持这两种协议，下面就我找到的第三方库列出并做出比较。 提到流播放就不得不提到 Vitamio .协议支持全面，嵌入项目简单，对个人开发者免费。项目地址:https://github.com/yixia/VitamioBundle. B站开源出来的 ijkplayer.项目维护及时，许多大公司都在用。网易云音乐，斗鱼TV，火猫TV等等，影响力可见一斑。支持RTMP，HLS。项目地址:https://github.com/Bilibili/ijkplayer.七牛开源出来的 PLDroidPlayer. 这个是基于B站的 ijkplayer进行二次开发的。项目维护也很及时，你去上边提issue，很快就会有人回复你。同样支持RTMP,HLS。继承步骤简单，有wiki，我现在用的就是这个;),但以后收不收费就不一定了。项目地址:https://github.com/pili-engineering/PLDroidPlayer. 大牛直播出品的 SmarterStreaming.个人使用免费，项目地址:https://github.com/daniulive/SmarterStreaming. 新浪开源出来的 sinavideo_playersdk.完全免费，你甚至可以修改备注。不过只支持hls协议，定制简单。项目地址:https://github.com/SinaVDDeveloper/sinavideo_playersdk. 原文地址","categories":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"},{"name":"直播","slug":"直播","permalink":"http://b.nearby.ren/tags/直播/"}]},{"title":"android视频播放总结","slug":"Android视频播放总结","date":"2016-10-27T07:06:29.000Z","updated":"2021-06-03T15:08:24.758Z","comments":true,"path":"2016/10/27/Android视频播放总结/","link":"","permalink":"http://b.nearby.ren/2016/10/27/Android视频播放总结/","excerpt":"","text":"[Android] Android 视频播放总结 1VideoView VideoView 的使用非常简单，播放视频的步骤： 在界面布局文件中定义VideoView组件，或在程序中创建VideoView组件 调用VideoView的如下两个方法来加载指定的视频： setVideoPath(String path);加载path文件代表的视频 setVideoURL(Uri uri);加载uri所对应的视频 调用VideoView的start()、stop()、psuse()方法控制视频的播放ExoplayerExoPlayer Git 地址 用法ExoPlayer开源项目包含了libray和示例： ExoPlayer library - 这部分是核心的库 Demo app - 这部分是演示怎么使用ExoPlayerExoPlayer库的核心类是ExoPlayer类。该类维护了播放器的全局状态。比如如何获取媒体数据，如何缓冲以及是怎样编码格式。 ExoPlayer基于MediaCodec和AudioTrack提供了默认的音视频的TrackRenderer实现。所有的renderers都需要SampleSource对象，Exoplayer从SampleSource获得media samples用于播放。下图展示了Exoplayer是如何配置组合这些组件用于播放音视频的。ExoPlayer库提供了一些不同类型的SampleSource实例： ExtractorSampleSource – 用于 MP3，M4A，WebM，MPEG-TS 和 AAC； ChunkSampleSource – 用于 DASH 和平滑流的播放； HlsSampleSource – 用于 HLS 播放； 在 ExoPlayer 的 Dome 中使用 DemoPlayer 对 ExoPlayer 进行了封装，并提供了使用上述几种 SampleSource 构建 TrackRenderer 的 Builder。 SmoothStreamingRendererBuilder DashRendererBuilder ExtractorRendererBuilder在使用的时候我们根据不同的需求创建对应的 RendererBuilder，然后将 RendererBuilder 传递给 DemoPlayer 然后调用 DemoPlayer 的 setPlayWhenReady 方法。 优缺点 ExoPlayer 相较于 MediaPlayer 有很多很多的优点： 支持动态的自适应流 HTTP (DASH) 和 平滑流，任何目前 MediaPlayer 支持的视频格式（同时它还支持 HTTP 直播(HLS)，MP4，MP3，WebM，M4A，MPEG-TS 和 AAC）。 支持高级的 HLS 特性，例如正确处理EXT-X-DISCONTINUITY 标签； 支持自定义和扩治你的使用场景。ExoPlayer 专门为此设计； 便于随着 App的升级而升级。因为 ExoPlayer是一个包含在你的应用中的库，对于你使用哪个版本有完全的控制权，并且你可以简单的跟随应用的升级而升级； 更少的适配性问题。 ExoPlayer 的缺点： ExoPlayer 的音频和视频组件依赖 Android 的 MediaCodec 接口，该接口发布于 Android4.1（API 等级16）。因此它不能工作于之前的Android 版本。 Vitamio Vitamio demo 地址 用法Vitamio的使用步骤： 下载Vitamio库，并作为工程依赖。 在Activity的onCreate方法中添加如下代码，初始化Vitamio的解码器12345@Override public void onCreate(Bundle icicle)&#123; super.onCreate(icicle) if(!LibsChecker.checkVitamioLibs(this)) return ;&#125; 在AndroidMainfest.xml中声明InitActivity 123&lt;activity android:name=&quot;io.vov.vitamio.activity.InitActivity&quot; android:configChanges=&quot;orientation|screenSize|smallestScreenSize|keyboard|keyboardHidden&quot; android:launchMode=&quot;singleTop&quot; android:theme=&quot;@android:style/Theme.NoTitleBar&quot; android:windowSoftInputMode=&quot;stateAlwaysHidden&quot;/&gt; 其余步骤和使用 Android 原生的 VideoView 是一样的。 优点 强大、支持超多格式视频和网络视频播放 使用简单。调用非常简单，方便使用。 ijkplayer 【哔哔哩开源】ijkplayer 项目地址 用法1.clone ijkplayer 项目到本地 2.编译 ijkplayer 下面是我的编译环境 编译环境 Mac OS X 10.10.5 Android NDK — android-ndk-r10e Android Studio 1.3.1 Gradle 2.4编译之前要安装 homebrew, git, yasm。 ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)”brew install gitbrew install yasm 配置 NDK 1234567# add these lines to your ~/.bash_profile or ~/.profile# export ANDROID_SDK=&lt;your sdk path&gt;# export ANDROID_NDK=&lt;your ndk path&gt;clone 项目git clone https://github.com/Bilibili/ijkplayer.git ijkplayer-android 编译 ffmpeg 12345678cd ijkplayer-android ./init-android.sh cd configrm module.shln -s module-default.sh module.shcd android/contrib./compile-ffmpeg.sh clean./compile-ffmpeg.sh all ffmpeg 编译通过后，编译 ijkplayer cd .. ./compile-ijk.sh all 编译通过后在 android 目录下有 ijkplayer 文件夹，这个是 ijkplayer 的 demo。导入 Android Studio 即可。ijkplayer 的 demo 中提供了 IjkVideoView 类，它封装了 Android 原生的 MediaPlayer 、ExoPlayer 和 IjkMediaPlayer。可根据需要选择。 优缺点 ijkplayer 最大的优点就是可以根据需要编译需要的解码器。在编译的时候通过 ln -s module-default.shmodule.sh 选择要编译的解码器。ijkplayer 在 config目录下提供了三种 module.sh 。也可自己修改module.sh 。 ijkplayer 的缺点是库太大。加入项目后会大大增加你的 APP 的大小。","categories":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"}]},{"title":"Android开发职位分类","slug":"Android开发职位分类","date":"2016-10-24T05:46:08.000Z","updated":"2016-11-21T14:59:36.000Z","comments":true,"path":"2016/10/24/Android开发职位分类/","link":"","permalink":"http://b.nearby.ren/2016/10/24/Android开发职位分类/","excerpt":"","text":"Android开发职位分类 Android开发分三类： 驱动开发：需要熟悉Linux和C语言，了解嵌入式开发相关知识，最好有驱动开发经验；待遇普遍比后两类高。 Android系统开发：基于Android系统的源码进行修改，修复bug或者对系统进行深度定制，重新设计并实现用户交互，主要是修改Android java层框架和Android系统自带的应用。需要应聘者熟练掌握JAVA语言，有移动开发经验或者J2ME开发经验。 Android应用开发。 前两类的工作一般是手机硬件制造商或者手机设计公司提供这些职位，如华为、中兴、魅族、联想Lephone；华为、中兴大多是做运营商定制，基本很少对系统层进行深度定制，主要是修改bug(Android系统每个版本都有大量的bug），做这一块不但积累对Android系统层的经验，而且也积累分析问题、解决问题的经验。 Android应用开发这个职位，大部分PC软件或互联网公司已经或正在做Android平台的支持。 对于没有JAVA经验的人，首先掌握J2SE，然后再学Android的应用开发。无论看书、看视频、上培训班最重要的都是练习。 Android应用开发书籍推荐《Google Android开发入门与实战》、《Google Android SDK开发范例大全》这两本书。 知识体系图 软件码工的修炼之路 一门语言的语法，SDK的常用API，算法与数据结构；有了上面的知识，再加上一点实践，再从网上找一些笔试题做几套，基本可以过笔试这一关。 编码规范、高性能编码经验技巧；要成为一个职业化的、专业化的程序员，首先要养成良好的习惯，良好的习惯从规范化的点滴日常工作开始。 熟练掌握IDE、常用 编程设计的原则；重点掌握面向对象的原则，如单一职责原则SRP、开放－封闭原则、替换原则LSP、依赖倒置原则DIP等。这些原则对后面内容理解的深入有很大帮助。不了解这些原则而去学设计模式会有空中楼阁、头重脚轻的感觉。 重构：重构是在不改变软件功能的前提下改善代码的设计以提高可维护性。修改代码或者优化代码都需要用到重构技术。 设计模式：基于一些常用的模式来学习如何使用设计模式。设计模式对于做框架开发的程序员比较有帮助。 代码重构的艺术：最重要、最难，看上去却最简单的功夫。修改别人的代码开始是功夫，优化就是艺术。 架构设计：这是步入殿堂必不可少的部分。 软件工程：从CMM到敏捷的转变，个人是比较推崇敏捷开发的。 质量管理：越往后越偏向管理了，开始是个人修炼，后面是站在组织、站在公司的角度来看软件。质量管理中有很多很好的理论和工具，不只可以应用到软件开发上，生活中也很有用的。","categories":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"}]},{"title":"Git分支管理策略","slug":"Git分支管理策略","date":"2016-10-24T03:55:47.000Z","updated":"2019-07-14T02:20:53.101Z","comments":true,"path":"2016/10/24/Git分支管理策略/","link":"","permalink":"http://b.nearby.ren/2016/10/24/Git分支管理策略/","excerpt":"","text":"Git分支管理策略 https://learngitbranching.js.org/?demo1.主要分支：master 说明：代码库应该有一个、且仅有一个主分支。所有提供给用户使用的正式版本，都在这个主分支开发。 2.开发分支：Develop 说明：主分支只用来分布重大版本，日常开发应该在另一个分支完成。我们把开发用的分支，叫做Develop 命令： 1.开启分支：git checkout -b develop master 2.将develop分支发布到Master分支命令：#切换到Master分支 git checkout master #对Develop分支进行合并 git merge --no-ff develop -m&quot;合并分支信息&quot; 3.临时分支：Feature/Release/Fixbug 1.Feature 功能分支：主要开发特定某功能，从Develop分支上面分出来。开发完成后，要再并入Develop。 命名格式采用 feature-* 创建一个临时分支 git checkout -b feature-x develop 开发完成后，将功能分支合并到develop分支。 1.git checkout develop 2.git merge --no-ff feature-x -m&quot;合并分支信息&quot; 3.git branch -d feature-x 2.Felease 预发分支：是指发布正式版之前（即合并到Master分支之前），我们可能需要一个预发布的版本进行测试。 从Develop分支上面分出来。 开发完成后，要再并入Develop和Master。 命名格式采用 release-* 创建预发分支 git checkout -b release-1.2 develop 开发确认没问题后。 1.git checkout master 2.git merge --on-ff release-1.2 -m&quot;合并分支信息&quot; #对合并的生成的新节点，做一个标签 git tag -a 1.2 #再合并到develop分支： 1.git checkout develop 2.git merge --no-ff release-1.2 -m&quot;合并分支信息&quot; 3.git branch -d release-1.2 3.Fixbug bug分支：软件正式发布后，难免会出现bug，就需要创建一个分支，进行bug修补。 从Master分支上面分出来的。修补结束以后，在合并到Master和Develop分支。 命名格式fixbug-* 创建bug分支 git checkout -b fixbug-0.1 master 修复结束后 合并到master分支 1.git checkout master 2.git merge --no-ff fixbug-0.1 -m&quot;合并分支信息&quot; 3.git tag -a 0.1.1 #再合并到develop分支 1.git checkout develop 2.git merge --no-ff fixbug-0.1 -m&quot;合并分支信息&quot; 3.git branch -d fixbug-0.1","categories":[{"name":"git","slug":"git","permalink":"http://b.nearby.ren/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://b.nearby.ren/tags/git/"}]},{"title":"gradle包含库出现的问题","slug":"gradle包含库出现的问题","date":"2016-10-21T02:41:37.000Z","updated":"2017-01-21T02:42:46.266Z","comments":true,"path":"2016/10/21/gradle包含库出现的问题/","link":"","permalink":"http://b.nearby.ren/2016/10/21/gradle包含库出现的问题/","excerpt":"","text":"Error:org.gradle.api.internal.changedetection.state.DefaultFileCollectionSnapshotter$FileCollectionSnapshotImpl cannot be cast to org.gradle.api.internal.changedetection.state.OutputFilesCollectionSnapshotter$OutputFilesSnapshotPossible causes for this unexpected error include:Gradle’s dependency cache may be corrupt (this sometimes occurs after a network connection timeout.)Re-download dependencies and sync project (requires network)The state of a Gradle build process (daemon) may be corrupt. Stopping all Gradle daemons may solve this problem.Stop Gradle build processes (requires restart)Your project may be using a third-party plugin which is not compatible with the other plugins in the project or the version of Gradle requested by the project.In the case of corrupt Gradle processes, you can also try closing the IDE and then killing all Java processes. 我直接把根目录的build删除，.gradle个文件夹也删除，然后gradle文件夹里面的版本再次提升一下版本就好了","categories":[{"name":"gradle","slug":"gradle","permalink":"http://b.nearby.ren/categories/gradle/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"},{"name":"gradle","slug":"gradle","permalink":"http://b.nearby.ren/tags/gradle/"}]},{"title":"Vuforia知识","slug":"Vuforia知识","date":"2016-10-20T02:21:47.000Z","updated":"2016-11-21T14:59:36.000Z","comments":true,"path":"2016/10/20/Vuforia知识/","link":"","permalink":"http://b.nearby.ren/2016/10/20/Vuforia知识/","excerpt":"","text":"Vuforia示例应用提供了九种应用展示，介绍主要特点和表现出基本功能 Image Targets （图像目标） 图像目标示例显示如何检测图像的目标和渲染在它上面的一个简单的3D对象。主要功能包括： 同时检测和多目标跟踪 加载和激活多个设备中的数据 激活扩展跟踪器 管理相机功能：闪灯光和连续自动对焦 Cylinder Targets(圆柱跟踪)筒形靶样品显示了如何检测的圆筒形靶和围绕圆柱体的圆周运动3D对象。主要功能包括： 检测气缸目标和跟踪 遮挡处理 激活扩展跟踪 管理相机功能：闪灯光和连续自动对焦 Multi Targets(多目标) 多目标的示例显示了如何检测一个简单的长方体形状的三维动画和周边形状的3D对象。主要功能包括： 检测与长方体形状的3D跟踪 遮挡处理 激活扩展跟踪 管理相机功能：山灯光和连续自动对焦 User Defined Targets(用户自定义目标)用户定义的目标示例显示了如何捕获和从用户选择的摄像机的视频帧运行时创建一个图像的目标。包括主要功能： 创建和管理用户的定义的图像目标 激活扩展跟踪 管理相机功能：闪灯光和连续自动对焦 Smart Terrain(智能地形) 智能地形示例应用程序演示了如何在一个目标让聪明的地形和使用重建网格渲染的内容。主要包括功能： 从已知的目标初始化 扫描表面找对象 在主要绘制网格 上主表面中找到的对象的渲染的箱 Cloud Recognition(云识别) 云Reco的示例显示了如何使用云识别服务识别位于云数据库的目标。 主要功能包括： 管理检测基于云的图像目标跟踪 激活扩展跟踪 管理相机功能：闪光灯和连续自动对焦 Text Recognition (文字识别) 文本识别样本显示在相机画面的指定区域内的动态识别英语单词。 主要功能包括 检测的英语单词和跟踪包含在默认的文字列表 管理相机功能：闪光灯 Frame Markers(帧标记) 帧标记示例演示如何检测帧标记，并呈现在上面一个简单的3D对象。 主要功能包括： 检测和多帧标记追踪 管理相机功能：闪光灯和连续自动对焦 Virtual Button(虚拟按键) 虚弥按钮示例显示了如何开发人员可以在触发时间触及或闭塞得摄像机视图时，图像的目标定义的矩形区域。样品呈现，当虚拟按钮中的一个被触发改变的颜色的3D对象。主要功能包括： 按钮遮挡事件处理 多个虚拟按钮激活 管理相机功能：闪光灯和连续自动对焦","categories":[{"name":"vuforia","slug":"vuforia","permalink":"http://b.nearby.ren/categories/vuforia/"}],"tags":[{"name":"vuforia","slug":"vuforia","permalink":"http://b.nearby.ren/tags/vuforia/"}]},{"title":"androidstudiogit设置忽略","slug":"androidstudiogit设置忽略","date":"2016-09-21T04:13:18.000Z","updated":"2017-07-18T08:23:01.996Z","comments":true,"path":"2016/09/21/androidstudiogit设置忽略/","link":"","permalink":"http://b.nearby.ren/2016/09/21/androidstudiogit设置忽略/","excerpt":"","text":"要忽略的文件-.idea文件夹-.gradle文件夹-所有文的build文件夹-所有的.iml文件-loca.properties文件 所以：跟目录的.gitignore.gradle/local.properties/.idea/workspace.xml/.idea/libraries.DS_Store/build/captures.idea*.iml module目录下的.gitignore/build*.iml","categories":[{"name":"git","slug":"git","permalink":"http://b.nearby.ren/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://b.nearby.ren/tags/git/"}]},{"title":"androidstudiosvn设置忽略","slug":"androidstudiosvn设置忽略","date":"2016-09-21T04:13:18.000Z","updated":"2017-07-18T08:23:03.797Z","comments":true,"path":"2016/09/21/androidstudiosvn设置忽略/","link":"","permalink":"http://b.nearby.ren/2016/09/21/androidstudiosvn设置忽略/","excerpt":"","text":"一、Android Studio创建的Android项目一般需要忽略1、.idea文件夹2、.gradle文件夹3、所有的build文件夹4、所有的.iml文件5、local.properties文件。方法一、在项目的.idea/workspace.xml的文件里设置1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project&gt; &lt;component name=\"ChangeListManager\"&gt; ... &lt;ignored path=\".gradle/\" /&gt; &lt;ignored path=\".idea/\" /&gt; &lt;ignored path=\"gradle/\" /&gt; &lt;ignored path=\"项目名/build/\" /&gt; &lt;ignored path=\"gradlew\" /&gt; &lt;ignored path=\"gradlew.bat\" /&gt; &lt;ignored mask=\"*.iml\" /&gt; &lt;ignored path=\"local.properties\" /&gt; &lt;ignored path=\"build/\" /&gt; &lt;ignored mask=\"*.apk\" /&gt; &lt;/component&gt; ... &lt;/project&gt;","categories":[{"name":"git","slug":"git","permalink":"http://b.nearby.ren/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://b.nearby.ren/tags/git/"}]},{"title":"springboot教程","slug":"springboot教程","date":"2016-08-16T06:06:17.000Z","updated":"2021-08-01T10:32:12.904Z","comments":true,"path":"2016/08/16/springboot教程/","link":"","permalink":"http://b.nearby.ren/2016/08/16/springboot教程/","excerpt":"","text":"Spring Boot 系列博客！","categories":[{"name":"spring","slug":"spring","permalink":"http://b.nearby.ren/categories/spring/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://b.nearby.ren/tags/springboot/"}]},{"title":"设计模式","slug":"设计模式","date":"2016-08-08T02:37:35.000Z","updated":"2021-08-01T10:33:57.001Z","comments":true,"path":"2016/08/08/设计模式/","link":"","permalink":"http://b.nearby.ren/2016/08/08/设计模式/","excerpt":"","text":"24种设计模式 代理模式在某些情况下，我们不希望或是不能直接访问对象 A，而是通过访问一个中介对象 B，由 B 去访问 A 达成目的，这种方式我们就称为代理。这里对象 A 所属类我们称为委托类，也称为被代理类，对象 B 所属类称为代理类。 优点 隐藏委托类的实现解耦，不改变委托类代码的情况下做一些额外处理，比如添加初始判断及其他公共操作根据程序运行前代理类是否已经存在，可以将代理分为静态代理和动态代理。 代理类在程序运行前已存在的代理方式称为静态代理。代理类在程序运行前未存在的代理、运行时由程序动态生成的代理方式称为动态代理。 静态代理 由开发人员编写或是编译器生成代理类的方式属于静态代理。 动态代理 三步骤: 1.新建委托类public interface Operate { public void operateMethod1(); public void operateMethod2(); public void operateMethod3(); } public class OperateImpl implements Operate { @Override public void operateMethod1() { System.out.println(&quot;Invoke operateMethod1&quot;); sleep(110); } @Override public void operateMethod2() { System.out.println(&quot;Invoke operateMethod2&quot;); sleep(120); } @Override public void operateMethod3() { System.out.println(&quot;Invoke operateMethod3&quot;); sleep(130); } private static void sleep(long millSeconds) { try { Thread.sleep(millSeconds); } catch (InterruptedException e) { e.printStackTrace(); } } }2.实现InvocationHandler接口，这是负责连接代理类与委托类的中间类必须实现的接口public class TimingInvocationHandler implements InvocationHandler { private Object target; public TimingInvocationHandler() {} public TimingInvocationHandler(Object target) { this.target = target; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { long start = System.currentTimeMillis(); Object obj = method.invoke(target, args); System.out.println(method.getName() + &quot; cost time is:&quot; + (System.currentTimeMillis() - start)); return obj; } } 3.通过Proxy类新建代理类对象 public class Main { public static void main(String[] args) { // create proxy instance TimingInvocationHandler timingInvocationHandler = new TimingInvocationHandler(new OperateImpl()); Operate operate = (Operate)(Proxy.newProxyInstance(Operate.class.getClassLoader(), new Class[] {Operate.class},timingInvocationHandler)); // call method of proxy instance operate.operateMethod1(); System.out.println(); operate.operateMethod2(); System.out.println(); operate.operateMethod3(); } } 应用场景 作用：目标函数值之间的耦合比如在 Dao 中，每次数据库操作都需要开启事务，而且在操作的时候需要关注权限。一般写法是在 Dao 的每个函数中添加相应逻辑，造成代码冗余，耦合度高。使用动态代理前伪代码如下： Dao { insert() { 判断是否有保存的权限； 开启事务； 插入； 提交事务； } delete() { 判断是否有删除的权限； 开启事务； 删除； 提交事务； } }使用动态代理的伪代码如下：使用动态代理，组合每个切面的函数，而每个切面只需要关注自己的逻辑就行，达到减少代码，松耦合的效果 invoke(Object proxy, Method method, Object[] args) throws Throwable { 判断是否有权限； 开启事务； Object ob = method.invoke(dao, args)； 提交事务； return ob; } 6.基于 REST 的 Android 端网络请求框架 Retrofit作用：简化网络请求操作。一般情况下每个网络请求我们都需要调用一次HttpURLConnection或者HttpClient进行请求，或者像 Volley 一样丢进等待队列中，Retrofit 极大程度简化了这些操作，示例代码如下： public interface GitHubService { @GET(&quot;/users/{user}/repos&quot;) List&lt;Repo&gt; listRepos(@Path(&quot;user&quot;) String user); } RestAdapter restAdapter = new RestAdapter.Builder().setEndpoint(&quot;https://api.github.com&quot;).build(); GitHubService service = restAdapter.create(GitHubService.class); 以后我们只需要直接调用 List&lt;Repo&gt; repos = service.listRepos(&quot;octocat&quot;); 设计模式汇总","categories":[{"name":"java","slug":"java","permalink":"http://b.nearby.ren/categories/java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://b.nearby.ren/tags/设计模式/"}]},{"title":"Java面向对象16种设计原则","slug":"Java面向对象16种设计原则","date":"2016-07-12T08:51:40.000Z","updated":"2021-08-01T10:35:10.573Z","comments":true,"path":"2016/07/12/Java面向对象16种设计原则/","link":"","permalink":"http://b.nearby.ren/2016/07/12/Java面向对象16种设计原则/","excerpt":"","text":"一 类的设计原则 1 依赖倒置原则－Dependency Inversion Principle (DIP)2 里氏替换原则－Liskov Substitution Principle (LSP)3 接口分隔原则－Interface Segregation Principle (ISP)4 单一职责原则－Single Responsibility Principle (SRP)5 开闭原则－The Open-Closed Principle (OCP) 二 包的设计原则 6 重用发布等价原则－Release ReuseEquivalency Principle (REP)7 无环依赖原则－The AcyclicDependencies Principle (ADP)8 稳定依赖原则－The StableDependencies Principle (SDP)9 稳定抽象等价原则－The StableAbstractions Principle (SAP)10 共同封闭原则－The CommonClosure Principle (CCP)11 全部重用原则－The Common Reuse Principle (CRP) 三 扩展原则 12 迪米特法则 －Least Knowledge Principle (LKP)13 黑盒原则－ BBP(Black Box Principle)14 缺省抽象原则 －DAP(Default Abstraction Principle)15 接口设计原则 －IDP(Interface Design Principle)16 不要构造具体的超类原则 －DCSP(Don’t Concrete SupperclassPrinciple) Dependency Inversion Principle (DIP) - 依赖倒置原则 依赖：在程序设计中，如果一个模块a使用或调用了另一个模块b，我们称模块a依赖模块b。高层模块与低层模块：往往在一个应用程序中，我们有一些低层次的类，这些类实现了一些基本的或初级的操作，我们称之为低层模块；另外有一些高层次的类，这些类封装了某些复杂的逻辑，并且依赖于低层次的类，这些类我们称之为高层模块。 依赖倒置原则的2个重要方针： 高层模块不应该依赖于低层模块，二者都应该依赖于抽象 抽象不应该依赖于细节，细节应该依赖于抽象 为什么叫做依赖倒置（Dependency Inversion）呢？ 面向对象程序设计相对于面向过程（结构化）程序设计而言，依赖关系被倒置了。因为传统的结构化程序设计中，高层模块总是依赖于低层模块。 问题的提出： Robert C. Martin在原文中给出了“Bad Design”的定义： 系统很难改变，因为每个改变都会影响其他很多部分。 当你对某地方做一修改，系统的看似无关的其他部分都不工作了。 系统很难被另外一个应用重用，因为你很难将要重用的部分从系统中分离开来。 导致“Bad Design”的很大原因是“高层模块”过分依赖“低层模块”。一个良好的设计应该是系统的每一部分都是可替换的。如果“高层模块”过分依赖“低层模块”，一方面一旦“低层模块”需要替换或者修改，“高层模块”将受到影响；另一方面，高层模块很难可以重用。 比如，一个Copy模块，需要把来自Keyboard的输入复制到Print，即使对Keyboard和Print的封装已经做得非常好，但如果Copy模块里直接使用Keyboard与Print，Copy任很难被其他应用环境（比如需要输出到磁盘时）重用。 问题的解决： 为了解决上述问题，Robert C. Martin提出了OO设计的Dependency Inversion Principle (DIP) 原则。DIP给出了一个解决方案：在高层模块与低层模块之间，引入一个抽象接口层。High Level Classes（高层模块） –&gt; Abstraction Layer（抽象接口层） –&gt; Low Level Classes（低层模块）抽象接口是对低层模块的抽象，低层模块继承或实现该抽象接口。这样，高层模块不直接依赖低层模块，高层模块与低层模块都依赖抽象接口层。当然，抽象也不依赖低层模块的实现细节，低层模块依赖（继承或实现）抽象定义。 Robert C. Martin给出的DIP方案的类的结构图： PolicyLayer–&gt;MechanismInterface(abstract)–MechanismLayer–&gt;UtilityInterface(abstract)–UtilityLayer类与类之间都通过Abstract Layer来组合关系。 Liskov Substitution Principle (LSP) - 里氏替换原则 所有引用基类的地方必须能透明地使用其子类的对象。也就是说，只有满足以下2个条件的OO设计才可被认为是满足了LSP原则：A 不应该在代码中出现if/else之类对子类类型进行判断的条件。以下代码就违反LSP定义。 if (obj typeof Class1) { do something } else if (obj typeof Class2) { do something else } B 子类应当可以替换父类并出现在父类能够出现的任何地方，或者说如果我们把代码中使用基类的地方用它的子类所代替，代码还能正常工作。 里氏替换原则LSP是使代码符合开闭原则的一个重要保证。同时LSP体现了： 1） 类的继承原则：如果一个继承类的对象可能会在基类出现地方出现运行错误，则该子类不应该从该基类继承，或者说，应该重新设计它们之间的关系。2）动作正确性保证：从另一个侧面上保证了符合LSP设计原则的类的扩展不会给已有的系统引入新的错误。 类的继承原则： Robert C. Martin举了Rectangle和Square的例子。这里沿用这个例子，但用Java语言对其加以重写，并忽略了某些细节只列出下面的精要部分来说明 里氏替换原则 对类的继承上的约束。 class Rectangle { double width; double height; public double getHeight() { return height; } public void setHeight(double height) { this.height = height; } public double getWidth() { return width; } public void setWidth(double width) { this.width = width; } } class Square extends Rectangle { public void setHeight(double height) { super.setHeight(height); super.setWidth(height); } public void setWidth(double width) { super.setHeight(width); super.setWidth(width); } } class Rectangle { double width; double height; public double getHeight() { return height; } public void setHeight(double height) { this.height = height; } public double getWidth() { return width; } public void setWidth(double width) { this.width = width; } } class Square extends Rectangle { public void setHeight(double height) { super.setHeight(height); super.setWidth(height); } public void setWidth(double width) { super.setHeight(width); super.setWidth(width); } } 这里Rectangle是基类，Square从Rectangle继承。这种继承关系有什么问题吗？ 假如已有的系统中存在以下既有的业务逻辑代码： void g(Rectangle r) { r.setWidth(5); r.setHeight(4); if (r.getWidth() * r.getHeight() != 20) { throw new RuntimeException(); } } 则对应于扩展类Square，在调用既有业务逻辑时： Rectangle square = new Square(); g(square);时会抛出一个RuntimeException异常。这显然违反了LSP原则。 动作正确性保证： 因为LSP对子类的约束，所以为已存在的类做扩展构造一个新的子类时，根据LSP的定义，不会给已有的系统引入新的错误。Design by Contract 根据Bertrand Meyer提出的Design by Contract（DBC：基于合同的设计）概念的描述，对于类的一个方法，都有一个前提条件以及一个后续条件，前提条件说明方法接受什么样的参数数据等，只有前提条件得到满足时，这个方法才能被调用；同时后续条件用来说明这个方法完成时的状态，如果一个方法的执行会导致这个方法的后续条件不成立，那么此方法也不应该正常返回。 现在把前提条件以及后续条件应用到继承子类中，子类方法应该满足：１）前提条件不强于基类．２）后续条件不弱于基类． 换句话说，通过基类的接口调用一个对象时，用户只知道基类前提条件以及后续条件。因此继承类不得要求用户提供比基类方法要求的更强的前提条件，亦即，继承类方法必须接受任何基类方法能接受的任何条件（参数）。同样，继承类必须顺从基类的所有后续条件，亦即，继承类方法的行为和输出不得违反由基类建立起来的任何约束，不能让用户对继承类方法的输出感到困惑。这样，我们就有了基于合同的LSP，基于合同的LSP是LSP的一种强化。 在很多情况下，在设计初期我们类之间的关系不是很明确，LSP则给了我们一个判断和设计类之间关系的基准：需不需要继承，以及怎样设计继承关系。 Interface Segregation Principle (ISP) - 接口分隔原则 不能强迫用户去依赖那些他们不使用的接口。换句话说，使用多个专门的接口比使用单一的总接口总要好。它包含了2层意思：1）接口的设计原则：接口的设计应该遵循最小接口原则，不要把用户不使用的方法塞进同一个接口里。 如果一个接口的方法没有被使用到，则说明该接口过胖，应该将其分割成几个功能专一的接口。2）接口的依赖（继承）原则：如果一个接口a依赖（继承）另一个接口b，则接口a相当于继承了接口b的方法，那么继承了接口b后的接口a也应该遵循上述原则：不应该包含用户不使用的方法。 反之，则说明接口a被b给污染了，应该重新设计它们的关系。 如果用户被迫依赖他们不使用的接口，当接口发生改变时，他们也不得不跟着改变。换而言之，一个用户依赖了未使用但被其他用户使用的接口，当其他用户修改该接口时，依赖该接口的所有用户都将受到影响。这显然违反了开闭原则，也不是我们所期望的。 下面我们举例说明怎么设计接口或类之间的关系，使其不违反ISP原则。假如有一个Door，有lock，unlock功能，另外，可以在Door上安装一个Alarm而使其具有报警功能。用户可以选择一般的Door，也可以选择具有报警功能的Door。 有以下几种设计方法： ISP原则的违反例： 方法一：在Door接口里定义所有的方法。图：但这样一来，依赖Door接口的CommonDoor却不得不实现未使用的alarm()方法。违反了ISP原则。 方法二：在Alarm接口定义alarm方法，在Door接口定义lock，unlock方法，Door接口继承Alarm接口。 跟方法一一样，依赖Door接口的CommonDoor却不得不实现未使用的alarm()方法。违反了ISP原则。遵循ISP原则的例： 方法三：通过多重继承实现Adapter设计模式的实现。第2）种方案更具有实用性。这种设计遵循了ISP设计原则。 方法四：通过委托实现在Alarm接口定义alarm方法，在Door接口定义lock，unlock方法。接口之间无继承关系。CommonDoor实现Door接口，AlarmDoor有2种实现方案：1）同时实现Door和Alarm接口。2）继承CommonDoor，并实现Alarm接口。该方案是继承方式的小结Interface Segregation Principle (ISP)从对接口的使用上为我们对接口抽象的颗粒度建立了判断基准：在为系统设计接口的时候，使用多个专门的接口代替单一的胖接口。 Single Responsibility Principle (SRP) - 单一职责原则 永远不要让一个类存在多个改变的理由。换句话说，如果一个类需要改变，改变它的理由永远只有一个。如果存在多个改变它的理由，就需要重新设计该类。 SRP（Single Responsibility Principle）原则的核心含意是：只能让一个类有且仅有一个职责。这也是单一职责原则的命名含义。 为什么一个类不能有多于一个以上的职责呢？ 如果一个类具有一个以上的职责，那么就会有多个不同的原因引起该类变化，而这种变化将影响到该类不同职责的使用者（不同用户）：1，一方面，如果一个职责使用了外部类库，则使用另外一个职责的用户却也不得不包含这个未被使用的外部类库。2，另一方面，某个用户由于某原因需要修改其中一个职责，另外一个职责的用户也将受到影响，他将不得不重新编译和配置。这违反了设计的开闭原则，也不是我们所期望的。 职责的划分既然一个类不能有多个职责，那么怎么划分职责呢？Robert.C Martin给出了一个著名的定义：所谓一个类的一个职责是指引起该类变化的一个原因。如果你能想到一个类存在多个使其改变的原因，那么这个类就存在多个职责。 Single Responsibility Principle (SRP)的原文里举了一个Modem的例子来说明怎么样进行职责的划分，这里我们也沿用这个例子来说明一下： SRP违反例： Modem.java interface Modem { public void dial(String pno); //拨号 public void hangup(); //挂断 public void send(char c); //发送数据 public char recv(); //接收数据 } 咋一看，这是一个没有任何问题的接口设计。但事实上，这个接口包含了2个职责：第一个是连接管理（dial, hangup）；另一个是数据通信（send, recv）。很多情况下，这2个职责没有任何共通的部分，它们因为不同的理由而改变，被不同部分的程序调用。所以它违反了SRP原则。 下面的类图将它的2个不同职责分成2个不同的接口，这样至少可以让客户端应用程序使用具有单一职责的接口：让ModemImplementation实现这两个接口。我们注意到，ModemImplementation又组合了2个职责，这不是我们希望的，但有时这又是必须的。通常由于某些原因，迫使我们不得不绑定多个职责到一个类中，但我们至少可以通过接口的分割来分离应用程序关心的概念。事实上，这个例子一个更好的设计应该是这样的，如图：小结Single Responsibility Principle (SRP)从职责（改变理由）的侧面上为我们对类（接口）的抽象的颗粒度建立了判断基准：在为系统设计类（接口）的时候应该保证它们的单一职责性。 The Open-Closed Principle (OCP) - 开闭原则 开闭原则（OCP：Open-Closed Principle）是指在进行面向对象设计（OOD：Object Oriented Design）中，设计类或其他程序单位时，应该遵循： 对扩展开放（open） 对修改关闭（closed） 开闭原则是判断面向对象设计是否正确的最基本的原理之一。 根据开闭原则，在设计一个软件系统模块（类，方法）的时候，应该可以在不修改原有的模块（修改关闭）的基础上，能扩展其功能（扩展开放）。A 扩展开放：某模块的功能是可扩展的，则该模块是扩展开放的。软件系统的功能上的可扩展性要求模块是扩展开放的。 B 修改关闭：某模块被其他模块调用，如果该模块的源代码不允许修改，则该模块修改关闭的。软件系统的功能上的稳定性，持续性要求是修改关闭的。 这也是系统设计需要遵循开闭原则的原因：1）稳定性。开闭原则要求扩展功能不修改原来的代码，这可以让软件系统在变化中保持稳定。2）扩展性。开闭原则要求对扩展开放，通过扩展提供新的或改变原有的功能，让软件系统具有灵活的可扩展性。遵循开闭原则的系统设计，可以让软件系统可复用，并且易于维护。 开闭原则的实现方法为了满足开闭原则的 对修改关闭（closed for modification） 原则以及扩展开放（open for extension） 原则，应该对软件系统中的不变的部分加以抽象，在面向对象的设计中，A 可以把这些不变的部分加以抽象成不变的接口，这些不变的接口可以应对未来的扩展；B 接口的最小功能设计原则。根据这个原则，原有的接口要么可以应对未来的扩展；不足的部分可以通过定义新的接口来实现；C 模块之间的调用通过抽象接口进行，这样即使实现层发生变化，也无需修改调用方的代码。 接口可以被复用，但接口的实现却不一定能被复用。接口是稳定的，关闭的，但接口的实现是可变的，开放的。可以通过对接口的不同实现以及类的继承行为等为系统增加新的或改变系统原来的功能，实现软件系统的柔软扩展。 简单地说，软件系统是否有良好的接口（抽象）设计是判断软件系统是否满足开闭原则的一种重要的判断基准。现在多把开闭原则等同于面向接口的软件设计。 开闭原则的相对性软件系统的构建是一个需要不断重构的过程，在这个过程中，模块的功能抽象，模块与模块间的关系，都不会从一开始就非常清晰明了，所以构建100%满足开闭原则的软件系统是相当困难的，这就是开闭原则的相对性。但在设计过程中，通过对模块功能的抽象（接口定义），模块之间的关系的抽象（通过接口调用），抽象与实现的分离（面向接口的程序设计）等，可以尽量接近满足开闭原则。 Release Reuse Equivalency Principle (REP) - 重用发布等价原则 包的内部关系方面（聚合性）的原则，重用粒度等价于发布粒度。重用主要是从用户的观点来看的。对用户来说，使用某个发布单位（组件，类，类群等），如果作者因为某种原因对其作了修改而发布了一个新的版本，用户会期望在升级为新版本之后，不会影响到原系统的正常运作。也就是说，对于一个可重用（能供其它用户或系统使用）的元素（组件，类，类群等），作者应该承诺新版本能够兼容旧版本。否则，用户将拒绝使用该元素。 Robert C. Martin给出的对重用的定义： 代码可以看作为可重用的代码，当且仅当： 它的使用者（下称用户）无需看它的源代码 用户只需联结静态库或包含动态库 当库发生改变（错误纠正，功能增强）时，用户只需要得到一个新的版本便能集成到原有的系统 怎么做到重用呢？一个组件要做到能够重用，它必须有一个得到良好设计的结构，它所包含所有元素必须也是可以重用的。因为如果一个为重用而设计的发布单位里，包含了不可重用的元素，当不可重用的元素发生改变时，用户也不得不改变原有系统以适应新的版本。这显然违反了重用的定义规则。也就是说，一个为重用目的而设计的发布单位里，不能包含不可重用的元素；如果包含了不可重用的元素，它将变得不可重用。 发布单位当用户使用的重用组件被作者修改后，用户希望得到通知，然后决定是否升级或升级的时机。为了能使升级后的系统也能正常运作，用户也希望作者有一个规范的发布，包括版本号，类库的说明等等。一旦用户决定升级新版本，不管这些修改是否影响到用户，用户也不得不包含新版本所包含的所有类库。 REP规定重用粒度不能小于发布粒度，所有重用元素也必须被一起发布。 发布粒度可以为包（组件）或类等实体，但一个应用往往包含了很多类，所以，具有更大的尺度的包（组件）更加适合作为发布粒度。 重用发布等价原则为我们指明了包的设计方针：一个包中的元素（类）要么都可重用，要么都不可重用。 小结重用发布等价原则（REP）从用户观点的角度上为我们规范了包设计的原则：在设计包时，包中应该包含的元素要么都可以重用，要么都不可以重用。 The Acyclic Dependencies Principle (ADP) - 无环依赖原则 包之间的依赖结构必须是一个直接的无环图形（DAG）。也就是说，在依赖结构中不允许出现环（循环依赖）。换成另一个说法是： 包间依赖不能是一个环状形式。包间关系方面（耦合性）的原则 包的依赖如果一个包A 中的类引用了包B中的类，我们称包A依赖包B。“依赖”在具体的程序语言中表现为，如果A依赖B，C/C++语言则在A包的文件/类中通过#include语句包含B包中的文件/类；Java语言则A包的类中通过import语句引入B包中的类。 图1（包A依赖包B）虚线表示一种依赖关系，箭头表示依赖的方向，箭头所在的一侧就是被依赖的包。 包的循环依赖我们上面讨论了并用图形表示了包之间的依赖关系。如果存在2个或2个以上的包，它们之间的依赖关系图出现了环状，我们就称包之间存在循环依赖关系。也就是说它们的依赖结构图根据箭头的方向形成了一个环状的闭合图形。如图：图2：包的循环依赖如图：A依赖B，B依赖C，C依赖A，形成了一个环状依赖。包的非循环依赖原则包是一个比较合适的发布粒度，当修改了包中的代码（类，模块等）并发布新的版本时，我们需要把该包以及它所依赖的其它包一起发布。发布之后，还需要验证系统是否能在新发布的版本下正常运作。如果多个包之间形成了循环依赖，比如如图2，A依赖B，B依赖C，C依赖A，我们修改了B并需要发布B的一个新的版本，因为B依赖C，所以发布时应该包含C，但C同时又依赖A，所以又应该把A也包含进发布版本里。也就是说，依赖结构中，出现在环内的所有包都不得不一起发布。它们形成了一个高耦合体，当项目的规模大到一定程度，包的数目变多时，包与包之间的关系便变得错综复杂，各种测试也将变得非常困难，常常会因为某个不相关的包中的错误而使得测试无法继续。而发布也变得复杂，需要把所有的包一起发布，无疑增加了发布后的验证难度。 循环依赖的打破方法如果包的依赖形成了环状结构，怎么样打破这种循环依赖呢？有2种方法可以打破这种循环依赖关系：第一种方法是创建新的包，第二种方法是使用DIP（依赖倒置原则）和ISP（接口分隔原则）设计原则。 方法一：创建新的包比如对于图2这种依赖结构： 图2：包的循环依赖 包C要依赖包A，必定A中包含有A，C共通使用的类，把这些共同类抽出来放在一个新的包D里。这样就把C依赖A变成了C依赖D以及A依赖D，从而打破了循环依赖关系。如图： 这样，包的依赖关系就从A-&gt;B-&gt;C-&gt;A变成了：A-&gt;B-&gt;C-&gt;DA-&gt;D 方法二：DIP与ISP设计原则ISP（接口分隔原则）可以剔除美用到的接口。DIP（依赖倒置原则）在类的调用之间引入抽象层。 如图,，包A依赖包B（因为包A中的类U使用了包B中的类X）；反过来，包B又依赖包A（因为包B中的类Y使用了包A中的类V） 包A，包B之间就形成了一种循环依赖。 我们使用DIP设计原则为V抽象一个接口IVforY，并把该接口放在B包中。这样就把Y对V的调用转化为：V继承IVforYY调用IVforY如图： 这样一来，包B中的类就不依赖任何包A中的类了。小结无环依赖原则（ADP）为我们解决包之间的关系耦合问题。在设计包结构时，不能有循环依赖。 The Stable Dependencies Principle (SDP) - 稳定依赖原则 一个设计中的包之间的依赖应该朝着稳定的方向进行。一个包只应该依赖那些比自己更稳定的包。换成另一个说法是： 朝着稳定的方向进行依赖。包之间的关系方面（耦合性）的原则。 包的依赖如果一个包A 中的类引用了包B中的类，我们称包A依赖包B。“依赖”在具体的程序语言中表现为，如果A依赖B，C/C++语言则在A包的文件/类中通过#include语句包含B包中的文件/类；Java语言则A包的类中通过import语句引入B包中的类。图1（包A依赖包B）虚线表示一种依赖关系，箭头表示依赖的方向，箭头所在的一侧就是被依赖的包。 包的稳定依赖原则包应该依赖比自己更稳定的包。因为如果依赖一个不稳定的包，那么当这个不稳定的包发生变化时，本身稳定的包也不得不发生变化，变得不稳定了。 所谓稳定，在现实生活中是指一个物体具有稳固不变的属性使它很难发生变化。应用到软件概念上，我们认为一个软件是稳定的，是因为这个软件很难发生改变，或更确切地说，是不需要发生改变。一个设计良好，能应对各种变化不需要修改的软件当然是稳定的了，但事实上，往往一个软件常常需要对应某个事先没有预测到的用户需求而不得不发生改变，当这种改变发生时，能把修改控制在最小的范围之内，并能稳定的工作（包括软件本身以及依赖它的其它软件实体等），我们也会认为该软件是相对稳定的。 怎么样让一个软件足够稳定呢？一个确切的方法是，让大量其它软件的包依赖它。一个包被很多其他包依赖是非常稳定的，这是因为被依赖的包为了协调其他包必须做很多的工作来对应各种变化（责任的负担者）。图1：稳定的包X我们认为X是稳定的，因为： X被很多其他包依赖。相当于责任担当着。 X没有依赖别的包，它是独立的。 相反，下面列出了一个非常不稳定的包Y，如图： 图2：不稳定的包Y我们认为Y是不稳定的，因为： Y没有被其他的包所依赖。不是责任的担当着。 Y依赖很多别的包。包的稳定性的判断原则可以通过下面的方法来判断一个包的稳定系数：Ca：Afferent Coupling。向心耦合。依赖该包（包含的类）的外部包（类）的数目（i.e. incoming dependencies）。Ce： Efferent Coupling。离心耦合。被该包依赖的外部包的数目（i.e. outgoing dependencies）。I： Instability。不稳定性。I=Ce/(Ce+Ca)。它的值处于[0，1]之间。如图1，X的Ce=0，所以不稳定性I=0，它是稳定的。相反，如图2，Y的Ce=3，Ca=0，所以它的不稳定性I=1，它是不稳定的。 SDP要求一个包的不稳定性I要大于它所依赖的包的不稳定性。换句话说，沿着依赖的方向，包的不稳定性应该逐渐降低，稳定性应该逐渐升高。 稳定依赖原则（SDP）为我们解决包之间的关系耦合问题。在设计包结构时，包应该只依赖比自己更稳定的包。 The Stable AbstractionsPrinciple (SAP) - 稳定抽象等价原则 最稳定的包应该是最抽象的包。不稳定的包应该是具体的包。包的抽象程度跟它的稳定性成正比。稳定的包应该是抽象的包。 包的稳定抽象等价原则 我们在The Stable Dependencies Principle (SDP) - OO设计的稳定依赖原则 一文中谈到了包的稳定性：不容易改变的包应该具有更好的稳定性。 一个包的抽象程度越高，它的稳定性就越高。反之，它的稳定性就越低。一个稳定的包必须是抽象的，反之，不稳定的包必须是具体的。稳定的包的构成抽象类或接口通过子类继承扩展行为，这表示抽象类或接口比它们的子类更具有稳定性。总之，为了构成稳定的包，应该提高包内的抽象类或接口的比率；它们的子类可以放在另一个不稳定的包内，该包依赖上述稳定的包，从而遵循了稳定依赖原则（SDP）。 理想的体系结构应该是：不稳定的（容易改变的）包处于上层 它们是具体的包实现稳定的（不容易改变的）包处于下层 不容易改变，但容易扩展 接口比实现（具体的运行代码）在内在特性上更具有稳定性图1：遵循稳定依赖原则（SDP）的理想的体系结构 小结稳定抽象等价原则（SAP）为我们解决包之间的关系耦合问题。在设计包结构时，稳定的包应该是抽象的（由抽象类或接口构成），不稳定的包应该是具体的（由具体的实现类构成）。 The Common ClosurePrinciple (CCP) - 共同封闭原则 一个包中所有的类应该对同一种类型的变化关闭。一个变化影响一个包，便影响了包中所有的类。一个更简短的说法是：一起修改的类，应该组合在一起（同一个包里）。包的内部关系方面（聚合性）的原则 如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。CCP原则就是把因为某个同样的原因而需要修改的所有类组合进一个包里。如果2个类从物理上或者从概念上联系得非常紧密，它们通常一起发生改变，那么它们应该属于同一个包。 CCP跟开闭原则（OCP: Open Closed Principle） 有着很深的渊源关系，CCP的“关闭”（closure）就是OCP所提倡的：classes should be closed for modification but open for extension. 类应该对修改关闭，对扩展开放。但我们知道，100%的“关闭”是不现实的，我们在设计系统时，只能尽量地保持对大多数可预见的修改关闭。CCP延伸了OCP的“关闭”概念，当因为某个原因需要修改时，把需要修改的范围限制在一个最小范围内的包里。CCP原则帮助我们决定哪些类应该被放到同一个包里。 小结共同封闭原则（CCP）从软件功能的角度上为我们规范了包设计的一个原则：在设计包时，相互之间紧密关联的类应该放在同一包里。 The Common Reuse Principle (CRP) - 全部重用原则 包的所有类被一起重用。如果你重用了其中的一个类，就重用全部。换成另一个比较浅显易懂的说法：没有被一起重用的类不应该被组合在一起。CRP原则帮助我们决定哪些类应该被放到同一个包里。包的内部关系方面（聚合性）的原则 依赖一个包就是依赖这个包所包含的一切。当一个包发生了改变，并发布新的版本，使用这个包的所有用户都必须在新的包环境下验证他们的工作，即使被他们使用的部分没有发生任何改变。因为如果包中包含有未被使用的类，即使用户不关心该类是否改变，但用户还是不得不升级该包并对原来的功能加以重新测试。 “不能强迫用户去依赖那些他们不使用的接口”，把这个概念应用到更广范围的包上，就是CRP的基本理念：不要把用户不使用的类一起组合进包里。 CRP与REP一样，都是从方便用户重用的角度去设计包，重用者是他们的受益者，CCP则让系统的维护者受益。CCP让包尽可能大（CCP原则加入功能相关的类），CRP则让包尽可能小（CRP原则剔除不使用的类）。它们的出发点不一样，但不相互冲突。CRP保证了包的内部具有很高的聚合性。 全部重用原则（CRP）从用户的角度上为我们规范了包设计的一个原则：在设计包时，相互之间没有紧密关联的类不应该放在同一包里。 Least Knowledge Principle (LKP) -迪米特法则 迪米特法则（Law of Demeter，LoD）也称为最少知识原则（Least Knowledge Principle，LKP）。一个对象应该对其他对象有最少的了解。通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的public方法，我就调用这么多，其他的一概不关心。 含义：只和朋友交流朋友类的定义是这样的：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，而出现在方法体内部的类不属于朋友类。下面的代码在方法体内部依赖了其他类，这严重违反迪米特法则 public class Teacher { public void commond(GroupLeader groupLeader) { List&lt;Girl&gt; listGirls = new ArrayList&lt;Girl&gt;(); for (int i = 0; i &lt; 20; i++) { listGirls.add(new Girl()); } groupLeader.countGirls(listGirls); } } 方法是类的一个行为，类竟然不知道自己的行为与其他类产生了依赖关系，这是不允许的。正确的做法是： public class Teacher { public void commond(GroupLeader groupLeader) { groupLeader.countGirls(); } } public class GroupLeader { private List&lt;Girl&gt; listGirls; public GroupLeader(List&lt;Girl&gt; _listGirls) { this.listGirls = _listGirls; } public void countGirls() { System.out.println(&quot;女生数量是：&quot; + listGirls.size()); } } 注意：一个类只和朋友交流，不与陌生类交流，不要出现getA().getB().getC().getD()这种情况（在一种极端情况下允许出现这种访问，即每一个点号后面的返回类型都相同），类与类之间的关系是建立在类间的，而不是方法间，因此一个方法尽量不引入一个类中不存在的对象，当然，JDK API提供的类除外。朋友间也是有距离的一个类公开的public属性或方法越多，修改时涉及的面也就越大，变更引起的风险扩散也就越大。因此，为了保持朋友类间的距离，在设计时需要反复衡量：是否还可以再减少public方法和属性，是否可以修改为private、package-private（包类型，在类、方法、变量前不加访问权限，则默认为包类型）、protected等访问权限，是否可以加上final关键字等。注意：迪米特法则要求类“羞涩”一点，尽量不要对外公布太多的public方法和非静态的public变量，尽量内敛，多使用private、package-private、protected等访问权限。 是自己的就是自己的如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，就放置在本类中。 谨慎使用Serializable 最后，迪米特法则的核心观念就是类间解耦，弱耦合，只有弱耦合了以后，类的复用率才可以提高。 Principle –纵览 ----类原则 ---- 1.单一职责原则 -Single Responsibility Principle(SRP)就一个类而言，应该仅有一个引起它变化的原因。(职责即为“变化的原因”。)2.开放-封闭原则 - OpenClose Principle(OCP)软件实体（类、模块、函数等）应该是可以扩展的，但是不可修改。(对于扩展是开放的,对于更改是封闭的.关键是抽象.将一个功能的通用部分和实现细节部分清晰的分离开来.开发人员应该仅仅对程序中呈现出频繁变化的那些部分作出抽象.拒绝不成熟的抽象和抽象本身一样重要. )3.里氏替换原则 -Liskov Substitution Principle(LSP)子类型(subclass)必须能够替换掉它们的基类型(superclass)。4.依赖倒置原则(IoCP) 或 依赖注入原则 -Dependence Inversion Principle(DIP)抽象不应该依赖于细节。细节应该依赖于抽象。(Hollywood原则: “Don’t call us, we’ll call you”.程序中所有的依赖关系都应该终止于抽象类和接口。针对接口而非实现编程。任何变量都不应该持有一个指向具体类的指针或引用。任何类都不应该从具体类派生。任何方法都不应该覆写他的任何基类中的已经实现了的方法。)5.接口隔离原则(ISP)不应该强迫客户依赖于它们不用的方法。接口属于客户，不属于它所在的类层次结构。(多个面向特定用户的接口胜于一个通用接口。) —-包内聚原则 —- 6.重用发布等价原则(REP)重用的粒度就是发布的粒度。7.共同封闭原则(CCP)包中的所有类对于同一类性质的变化应该是共同封闭的。一个变化若对一个包产生影响，则将对该包中的所有类产生影响，而对于其他的包不造成任何影响。8.共同重用原则(CRP)一个包中的所有类应该是共同重用的。如果重用了包中的一个类，那么就要重用包中的所有类。(相互之间没有紧密联系的类不应该在同一个包中。)—-包耦合原则9.无环依赖原则(ADP)在包的依赖关系图中不允许存在环。10.稳定依赖原则(SDP)朝着稳定的方向进行依赖。应该把封装系统高层设计的软件（比如抽象类）放进稳定的包中，不稳定的包中应该只包含那些很可能会改变的软件（比如具体类）。11.稳定抽象原则(SAP)包的抽象程度应该和其稳定程度一致。(一个稳定的包应该也是抽象的，一个不稳定的包应该是抽象的. ) —-其它扩展原则—- 12.BBP(Black Box Principle)黑盒原则多用类的聚合，少用类的继承。13.DAP(Default Abstraction Principle)缺省抽象原则在接口和实现接口的类之间引入一个抽象类,这个类实现了接口的大部分操作.14.IDP(Interface Design Principle)接口设计原则规划一个接口而不是实现一个接口。15.DCSP(Don’t Concrete Supperclass Principle)不要构造具体的超类原则避免维护具体的超类。16.迪米特法则一个类只依赖其触手可得的类。","categories":[{"name":"java","slug":"java","permalink":"http://b.nearby.ren/categories/java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://b.nearby.ren/tags/设计模式/"}]},{"title":"ANDROID SUPPORT兼容包详解","slug":"ANDROID SUPPORT兼容包详解","date":"2016-07-08T01:19:18.000Z","updated":"2021-08-01T10:34:55.366Z","comments":true,"path":"2016/07/08/ANDROID SUPPORT兼容包详解/","link":"","permalink":"http://b.nearby.ren/2016/07/08/ANDROID SUPPORT兼容包详解/","excerpt":"","text":"Support Library 我们都知道Android一些SDK比较分裂，为此google官方提供了Android Support Library package 系列的包来保证高版本sdk开发的向下兼容性, 所以你可能经常看到v4，v7，v13这些数字，首先我们就来理清楚这些数字的含义，以及它们之间的区别。 support-v4用在API lever 4(即Android 1.6)或者更高版本之上。它包含了相对更多的内容，而且用的更为广泛，例如：Fragment，NotificationCompat，LoadBroadcastManager，ViewPager，PageTabStrip，Loader，FileProvider 等 Gradle引用方法： compile ‘com.android.support:support-v4:21.0.3’ support-v7这个包是为了考虑API level 7(即Android 2.1)及以上版本而设计的，但是v7是要依赖v4这个包的，v7支持了Action Bar以及一些Theme的兼容。 Gradle引用方法: compile ‘com.android.support:appcompat-v7:21.0.3’support-v13这个包的设计是为了API level 13(即Android 3.2)及更高版本的，一般我们都不常用，平板开发中能用到，这里就不过多介绍了。 Theme 回到知乎上的这个问题，我们来介绍下各种Theme的概念。 Hoho Theme在4.0之前Android可以说是没有设计可言的，在4.0之后推出了Android Design，从此Android在设计上有了很大的改善，而在程序实现上相应的就是Holo风格，所以你看到有类似 Theme.Holo.Light、 Theme.Holo.Light.DarkActionBar 就是4.0的设计风格，但是为了让4.0之前的版本也能有这种风格怎么办呢？这个时候就不得不引用v7包了，所以对应的就有 Theme.AppCompat.Light、 Theme.AppCompat.Light.DarkActionBar，如果你的程序最小支持的版本是4.0，那么可以不用考虑v7的兼容。 Material Design Theme今年的5.0版本，Android推出了Material Design的概念，这是在设计上Android的又一大突破。对应的程序实现上就有 Theme.Material.Light、 Theme.Material.Light.DarkActionBar等，但是这种风格只能应用在在5.0版本的手机，如果在5.0之前应用Material Design该怎么办呢？同样的引用appcompat-v7包，这个时候的Theme.AppCompat.Light、 Theme.AppCompat.Light.DarkActionBar就是相对应兼容的Material Design的Theme。 注意事项 gradle引用appcompat-v7包的时候就不需要引用v4了，因为v7里默认包含了v4包；compile ‘com.android.support:appcompat-v7:21.0.3’ 中的21代表API level 21推出的兼容包，所以如果你引用的是21之前的版本，则默认这些Theme.AppCompat.Light是Holo风格的，从21开始的版本默认是Material风格使用appcompat之后，你的所有的Activity应该继承自ActionBarActivity，而ActionBarActivity继承自FragmentActivity，所以放心的使用Fragment；","categories":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"}]},{"title":"Android之Lru算法","slug":"Android之Lru算法","date":"2016-06-18T12:45:21.000Z","updated":"2017-01-18T09:08:56.262Z","comments":true,"path":"2016/06/18/Android之Lru算法/","link":"","permalink":"http://b.nearby.ren/2016/06/18/Android之Lru算法/","excerpt":"","text":"Lru： LRU是Least Recently Used 的缩写，翻译过来就是“最近最少使用”，LRU缓存就是使用这种原理实现，简单的说就是缓存一定量的数据，当超过设定的阈值时就把一些过期的数据删除掉，比如我们缓存10000条数据，当数据小于10000时可以随意添加，当超过10000时就需要把新的数据添加进来，同时要把过期数据删除，以确保我们最大缓存10000条，那怎么确定删除哪条过期数据呢，采用LRU算法实现的话就是将最老的数据删掉。 1.）初始化MemoryCache 这里内存缓存的是Drawable 而不是Bitmap 理由是Drawable相对Bitmap来说有很大的内存优势 int maxMemory = (int) Runtime.getRuntime().maxMemory();//获取系统分配给应用的总内存大小 int mCacheSize = maxMemory / 8;//设置图片内存缓存占用八分之一 mMemoryCache = new LruCache(mCacheSize) { //必须重写此方法，来测量Bitmap的大小 @Override protected int sizeOf(String key, Drawable value) { if (value instanceof BitmapDrawable) { Bitmap bitmap = ((BitmapDrawable) value).getBitmap(); return bitmap == null ? 0 : bitmap.getByteCount(); } return super.sizeOf(key, value); } }; 2.）添加一个Drawable到内存缓存 /** * 添加Drawable到内存缓存 * * @param key * @param drawable */ private void addDrawableToMemoryCache(String key, Drawable drawable) { if (getDrawableFromMemCache(key) == null &amp;&amp; drawable != null) { mMemoryCache.put(key, drawable); } } 3.）从内存缓存中获取一个Drawable /** * 从内存缓存中获取一个Drawable * * @param key * @return */ public Drawable getDrawableFromMemCache(String key) { return mMemoryCache.get(key); } 4.）从内存缓存中移除一个Drawable /** * 从内存缓存中移除 * * @param key */ public void removeCacheFromMemory(String key) { mMemoryCache.remove(key); } 5.）清空内存缓存 /** * 清理内存缓存 */ public void cleanMemoryCCache() { mMemoryCache.evictAll(); } 其实Lru缓存机制本质上就是存储在一个LinkedHashMap存储，为了保障插入的数据顺序，方便清理。 基于DiskLruCache实现磁盘缓存： DiskLruCache类并不是谷歌官方实现，需要自行下载，下载地址：https://github.com/JakeWharton/DiskLruCache 1.）初始化DiskLruCache File cacheDir = context.getCacheDir();//指定的是数据的缓存地址 long diskCacheSize = 1024 * 1024 * 30;//最多可以缓存多少字节的数据 int appVersion = DiskLruUtils.getAppVersion(context);//指定当前应用程序的版本号 int valueCount = 1;//指定同一个key可以对应多少个缓存文件 try { mDiskCache = DiskLruCache.open(cacheDir, appVersion, valueCount, diskCacheSize); } catch (Exception ex) { } 2.）写入一个文件到磁盘缓存 /** * 添加Bitmap到磁盘缓存 * * @param key * @param value */ private void addBitmapToDiskCache(String key, byte[] value) { OutputStream out = null; try { DiskLruCache.Editor editor = mDiskCache.edit(key); if (editor != null) { out = editor.newOutputStream(0); if (value != null &amp;&amp; value.length &gt; 0) { out.write(value); out.flush(); editor.commit(); } else { editor.abort(); } } mDiskCache.flush(); } catch (IOException e) { e.printStackTrace(); } finally { DiskLruUtils.closeQuietly(out); } } 3.）从磁盘缓存中读取Drawable /** * 从磁盘缓存中获取一个Drawable * * @param key * @return */ public Drawable getDrawableFromDiskCache(String key) { try { DiskLruCache.Snapshot snapShot = mDiskCache.get(key); if (snapShot != null) { InputStream is = snapShot.getInputStream(0); Bitmap bitmap = BitmapFactory.decodeStream(is); Drawable drawable = DiskLruUtils.bitmap2Drawable(bitmap); //从磁盘中读取到之后 加入内存缓存 addDrawableToMemoryCache(key, drawable); return drawable; } } catch (IOException e) { e.printStackTrace(); } return null; } 4.）从磁盘缓存中移除 /** * 从磁盘缓存中移除 * * @param key */ public void removeCacheFromDisk(String key) { try { mDiskCache.remove(key); } catch (Exception e) { } } 5.）清空磁盘缓存 /** * 清理磁盘缓存 */ public void cleanDiskCache() { try { mDiskCache.delete(); } catch (Exception e) { } } 图片下载过程： 接下来实例中用到了一点RxJava的知识有不了解RxJava的请自行了解一下。 1.）采用异步方式操作磁盘缓存和网络下载， 内存缓存可以在主线程中操作 public void disPlay(final ImageView imageView, String imageUrl) { //生成唯一key final String key = DiskLruUtils.hashKeyForDisk(imageUrl); //先从内存中读取 Drawable drawableFromMemCache = getDrawableFromMemCache(key); if (drawableFromMemCache != null) { imageView.setImageDrawable(drawableFromMemCache); return; } Observable.just(imageUrl) .map(new Func1() { @Override public Drawable call(String imageUrl) { // 参数类型 String //从磁盘中读取 Drawable drawableFromDiskCache = getDrawableFromDiskCache(key); if (drawableFromDiskCache != null) { return drawableFromDiskCache; } //网络下载 return download(imageUrl); // 返回类型 Drawable } }) .subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程 .observeOn(AndroidSchedulers.mainThread()) // 指定 Subscriber 的回调发生在主线程 .subscribe(new Action1() { @Override public void call(Drawable drawable) { // 参数类型 Drawable imageView.setImageDrawable(drawable); } }); } 2.）下载图片过程以及处理 private Drawable download(String imageUrl) { HttpURLConnection urlConnection = null; ByteArrayOutputStream bos = null; InputStream ins = null; try { final URL url = new URL(imageUrl); urlConnection = (HttpURLConnection) url.openConnection(); ins = urlConnection.getInputStream(); bos = new ByteArrayOutputStream(); int b; while ((b = ins.read()) != -1) { bos.write(b); } bos.flush(); byte[] bytes = bos.toByteArray(); Bitmap bitmap = DiskLruUtils.bytes2Bitmap(bytes); String key = DiskLruUtils.hashKeyForDisk(imageUrl); Drawable drawable = DiskLruUtils.bitmap2Drawable(bitmap); //加入内存缓存 addDrawableToMemoryCache(key, drawable); //加入磁盘缓存 addBitmapToDiskCache(key, bytes); return drawable; } catch (IOException e) { e.printStackTrace(); } finally { if (urlConnection != null) { urlConnection.disconnect(); } DiskLruUtils.closeQuietly(bos); DiskLruUtils.closeQuietly(ins); } return null; }","categories":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"},{"name":"glide","slug":"glide","permalink":"http://b.nearby.ren/tags/glide/"}]},{"title":"Android应用防止被截图或者录屏","slug":"Android应用防止被截图或者录屏","date":"2016-06-17T12:31:28.000Z","updated":"2021-07-24T08:42:38.598Z","comments":true,"path":"2016/06/17/Android应用防止被截图或者录屏/","link":"","permalink":"http://b.nearby.ren/2016/06/17/Android应用防止被截图或者录屏/","excerpt":"","text":"Activity创建时设置WindowManager.LayoutParams.FLAG_SECURE属性，该属性能防止屏幕被截图和录制。以下为修复代码示例：12345678public class DemoActivity extends Activity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE); setContentView(R.layout.main); &#125; &#125; 即在Activity onCreate方法中，setContenView调用前设置getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);若是所有Activity需要设置该属性，那么可以在BaseActivity中设置，然后其他Activity继承即可","categories":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"},{"name":"glide","slug":"glide","permalink":"http://b.nearby.ren/tags/glide/"}]},{"title":"Android之Glide缓存","slug":"Android之Glide缓存","date":"2016-06-17T12:31:28.000Z","updated":"2017-01-18T09:26:35.941Z","comments":true,"path":"2016/06/17/Android之Glide缓存/","link":"","permalink":"http://b.nearby.ren/2016/06/17/Android之Glide缓存/","excerpt":"","text":"GlideModule使用： GlideModule 是一个抽象方法，全局改变 Glide 行为的一个方式，通过全局GlideModule 配置Glide，用GlideBuilder设置选项，用Glide注册ModelLoader等。 自定义一个GlideModulepublic class MyGlideModule implements GlideModule {@Override public void applyOptions (Context context, GlideBuilder builder){ }}@Override public void registerComponents(Context context, Glide glide){ }} &lt; mainfest …&gt; &lt; application …&gt; &lt; meta-date android:name=”com.mypackage.MyGlideModule” android:value=”GlideModule” /&gt; &lt; / application&gt; &lt; / manifest&gt; 添加混淆处理 -keepnames class com.mypackage.MyGlideModule # or more generally: #-keep public class * implements com.bumptech.glide.module.GlideModule 多个GlideModule冲突问题 GlideModule不能指定调用顺序，所以应该避免不同的GlideModule之间有冲突的选项设置，可以考虑将所有的设置都放到一个GlideModule里面，或者排除掉某个manifest文件的某个Module，代码如下：&lt; meta-data android:name=”com.mypackage.MyGlideModule” tools:node=”remove” / &gt; GlideBuilder设置选项： 设置Glide内存缓存大小 int maxMemory = (int)Runtime.getRuntime().maxMemory();//获取系统分配给应用的总内存大小int memoryCacheSize = maxMemory / 8 ;//设置图片内存缓存占用八分之一//设置缓存大小builder.setMemoryCache(new LruResourceCache(memoryCacheSize)); 获取默认的内存使用计算函数 MemorySizeCalculator calculator = new MemorySizeCalcylator(context); int defauleMemoryCacheSize = calculator.getMemoryCacheSize(); int defaultBitmapPoolSize = calculator.getBitmapPoolSize(); 设置Glide磁盘缓存大小 File cacheDir = context.getExternalCacheDir();//指定的是数据缓存地址 int disCacheSize = 1024 1024 30 ;//最多可以缓存多少字节的数据 //设置磁盘缓存大小 builder.setDiskCache(new DiskLruCacheFactory(cacheDir.getPath(),”glide”,diskCacheSize));也可以通过如下两种方式//存放在data/data/xxxx/cache/builder.setDiskCache(new InternalCacheDiskCacheFactory(context, “glide”, diskCacheSize));//存放在外置文件浏览器builder.setDiskCache(new ExternalCacheDiskCacheFactory(context, “glide”, diskCacheSize)); 设置图片解码格式//设置图片解码格式builder.setDecodeFormat(DecodeFormat.PREFER_ARGB_8888); 设置缓存内存大小//设置BitmapPool缓存内存大小builder.setBitmapPool(new LruBitmapPool(memoryCacheSize)); 设置一个用来检索cache中没有的Resource的ExecutorService为了使缩略图请求正确工作，实现类必须把请求根据Priority优先级排好序。builder.setDiskCacheService(ExecutorService service);builder.setResizeService(ExecutorService service); 使用ModelLoader自定义数据源：例如我们使用了七牛云存储，要根据不同的要求请求不同尺寸不同质量的图片，这时我们就可以使用自定义数据源 定义处理URL接口 public interface IDataModel { String buildDataModelUrl (int width , int height ); } 实现处理URL接口 public class JpgDataModel implements IDataModel { private String dataModelUrl ; public JpgDataModel (String dataModelUrl){ this.dataModelUrl = dataModelUrl; } @Override public String buildDataModelUrl(int width , int height ){ return String.format( “%s?imageView2/1/w/%d/h/%d/format/jpg”, dataModelUrl, width, height); } } public class WebpDataModel implements IDataModel { private String dataModelUrl ; public WebpDataModel (String dataModelUrl){ this.dataModelUrl = dataModelUrl; } @Override public String buildDataModelUrl(int width , int height ){ return String.format( “%s?imageView2/1/w/%d/h/%d/format/webp”, dataModelUrl, width, height); } } 实现ModelLoader public class MyDataLoader extends BaseGlideUrlLoader { public MyDataLoader(Context context) { super(context); } public MyDataLoader(ModelLoader urlLoader) { super(urlLoader, null); } @Overrideprotected String getUrl(IDataModel model, int width, int height) { return model.buildDataModelUrl(width, height); } /* /public static class Factory implements ModelLoaderFactory { @Override public ModelLoader build(Context context, GenericLoaderFactory factories) { return new MyDataLoader(factories.buildModelLoader(GlideUrl.class, InputStream.class)); } @Override public void teardown() { } }} 根据不同的要求采用不同的策略加载图片 //加载jpg图片 Glide.with(this).using(new MyDataLoader(this)).load(new JpgDataModel(imageUrl)).into(imageView); //加载webp图片 Glide.with(this).using(new MyDataLoader(this)).load(new WebpDataModel(imageUrl)).into(imageView); 如何跳过.using() public class MyGlideModule implements GlideModule { @Override public void registerComponents(Context context, Glide glide) { glide.register(IDataModel.class, InputStream.class, new MyUrlLoader.Factory()); } } 上面的实现跳过using() //加载jpg图片 Glide.with(this).load(new JpgDataModel(imageUrl)).into(imageView); //加载webp图片 Glide.with(this).load(new WebpDataModel(imageUrl)).into(imageView); 使用signature()实现自定义cacheKey： Glide 以 url、viewwidth、viewheight、屏幕的分辨率等做为联合key，官方api中没有提供删除图片缓存的函数，官方提供了signature()方法，将一个附加的数据加入到缓存key当中，多媒体存储数据，可用MediaStoreSignature类作为标识符，会将文件的修改时间、mimeType等信息作为cacheKey的一部分，通过改变key来实现图片失效相当于软删除。 1.使用StringSignature Glide.with(this).load(yourFileDataModel).signature(new StringSignature(“1.0.0”)).into(imageView); 2.使用MediaStoreSignature Glide.with(this) .load(mediaStoreUri).signature(new MediaStoreSignature(mimeType, dateModified, orientation)).into(view); 3.使用自定义Signature public class IntegerVersionSignature implements Key { private int currentVersion; public IntegerVersionSignature(int currentVersion) { this.currentVersion = currentVersion; } @Override public boolean equals(Object o) { if (o instanceof IntegerVersionSignature) { IntegerVersionSignature other = (IntegerVersionSignature) o; return currentVersion = other.currentVersion; } return false; } @Override public int hashCode() { return currentVersion; } @Override public void updateDiskCacheKey(MessageDigest md) { messageDigest.update(ByteBuffer.allocate(Integer.SIZE).putInt(signature).array()); }}","categories":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"},{"name":"glide","slug":"glide","permalink":"http://b.nearby.ren/tags/glide/"}]},{"title":"Android Studio --“Cannot resolve symbol” 解决办法","slug":"Android Studio --“Cannot resolve symbol” 解决办法","date":"2016-06-17T12:31:28.000Z","updated":"2021-07-24T08:42:21.525Z","comments":true,"path":"2016/06/17/Android Studio --“Cannot resolve symbol” 解决办法/","link":"","permalink":"http://b.nearby.ren/2016/06/17/Android Studio --“Cannot resolve symbol” 解决办法/","excerpt":"","text":"Android Studio 无法识别同一个 package 里的其他类，将其显示为红色，但是 compile 没有问题。鼠标放上去后显示 “Cannot resolve symbol XXX”，重启 Android Studio，重新 sync gradle，Clean build 都没有用。 多半是因为 Android Studio 之前发生了错误，某些 setting 出了问题。解决方法如下：点击菜单中的 “File” -&gt; “Sync Project with Gradle Files”语法就会正确的高亮了。点击菜单中的 “File” -&gt; “Invalidate Caches / Restart”，然后点击对话框中的 “Invalidate and Restart”，清空 cache 并且重启。语法就会正确的高亮了。","categories":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"}]},{"title":"Android之初识Glide","slug":"Android之初识Glide","date":"2016-06-16T12:00:30.000Z","updated":"2017-01-18T09:26:42.321Z","comments":true,"path":"2016/06/16/Android之初识Glide/","link":"","permalink":"http://b.nearby.ren/2016/06/16/Android之初识Glide/","excerpt":"","text":"Glide简介： Glide 是 Google 员工的开源项目， Google I/O 上被推荐使用，一个高效、开源、Android设备上的媒体管理框架，它遵循BSD、MIT以及Apache 2.0协议发布。Glide具有获取、解码和展示视频剧照、图片、动画等功能，它还有灵活的API，这些API使开发者能够将Glide应用在几乎任何网络协议栈里。创建Glide的主要目的有两个，一个是实现平滑的图片列表滚动效果，另一个是支持远程图片的获取、大小调整和展示。 gitHub地址：https://github.com/bumptech/glide Glide特点 使用简单 可配置度高，自适应程度高 支持常见图片格式Jpg png gif webp 支持多种数据源网络、本地、资源、Assets 等 高效缓存策略支持Memory和Disk图片缓存 默认Bitmap格式采用RGB_565内存使用至少减少一半 生命周期集成根据Activity/Fragment生命周期自动管理请求 高效处理Bitmap使用Bitmap Pool使Bitmap复用，主动调用recycle回收需要回收的Bitmap，减小系统回收压力 Glide简单使用 添加引用 build.gradle 中添加配置 compile ‘com.github.bumptech.glide:glide:3.7.0’ 设置绑定生命周期我们可以更加高效的使用Glide提供的方式进行绑定，这样可以更好的让加载图片的请求的生命周期动态管理起来 Glide.with(Context context);// 绑定Context Glide.with(Activity activity);// 绑定Activity Glide.with(FragmentActivity activity);// 绑定FragmentActivity Glide.with(Fragment fragment);// 绑定Fragment 简单的加载图片实例 Glide.with(this).load(imageUrl).into(imageView); 设置加载中以及加载失败图片api里面对placeholder()、error()函数中有多态实现 用的时候可以具体的熟悉一下 Glide.with(this).load(imageUrl).placeholder(R.mipmap.ic_launcher).error(R.mipmap.ic_launcher).into(imageView); 设置跳过内存缓存 Glide.with(this).load(imageUrl).into(imageView); 设置下载优先级 Glide.with(this).load(imageUrl).priority(Priority.NORMAL).into(imageView); 设置缓存策略 Glide.with(this).load(imageUrl).diskCacheStrategy(DiskCacheStrategy.ALL).into(imageView); 策略解说：all:缓存源资源和转换后的资源none:不作任何磁盘缓存source:缓存源资源result：缓存转换后的资源 设置加载动画api也提供了几个常用的动画：比如crossFade() Glide.with(this).load(imageUrl).animate(R.anim.item_alpha_in).into(imageView); R.anim.item_alpha_in &lt; ? xml version=”1.0” encoding=”utf-8”?&gt; &lt; set xmlns:android=”http://schemas.android.com/apk/res/android&quot;&gt; &lt; alpha android:duration=”500” android:fromAlpha=”0.0” android:toAlpha=”1.0”/&gt; &lt;/ set&gt; 设置缩略图支持这样会先加载缩略图 然后在加载全图 Glide.with(this).load(imageUrl).thumbnail(0.1f).into(imageView); 设置加载尺寸 Glide.with(this).load(imageUrl).override(800, 800).into(imageView); 设置动态转换 Glide.with(this).load(imageUrl).centerCrop().into(imageView); api提供了比如：centerCrop()、fitCenter()等函数也可以通过自定义Transformation，举例说明：比如一个人圆角转化器 public class GlideRoundTransform extends BitmapTransformation{private float radius = 0f;public GlideRoundTransform(Context context) { this(context, 4); }public GlideRoundTransform(Context context, int dp) { super(context); this.radius = Resources.getSystem().getDisplayMetrics().density * dp; }@Overrideprotected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) { return roundCrop(pool, toTransform);}private Bitmap roundCrop(BitmapPool pool, Bitmap source) { if (source == null) return null; Bitmap result = pool.get(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888); if (result == null) { result = Bitmap.createBitmap(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888); } Canvas canvas = new Canvas(result); Paint paint = new Paint(); paint.setShader(new BitmapShader(source, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP)); paint.setAntiAlias(true); RectF rectF = new RectF(0f, 0f, source.getWidth(), source.getHeight()); return result; } @Overridepublic String getId() { return getClass().getName() + Math.round(radius); }} Glide.with(this).load(imageUrl).transform(new GlideRoundTransform(this)).into(imageView); 设置要加载的内容 项目中有很多需要先下载图片然后再做一些合成的功能，比如项目中出现的图文混排，该如何实现目标下 Glide.with(this).load(imageUrl).centerCrop().into(new SimpleTarget() { @Override public void onResourceReady(GlideDrawable resource, GlideAnimation&lt;? super GlideDrawable&gt; glideAnimation) { imageView.setImageDrawable(resource); } });Glide.with(this).load(imageUrl).transform(new GlideRoundTransform(this)).into(imageView); 设置监听请求接口 Glide.with(this).load(imageUrl).listener(new RequestListener() { @Override public boolean onException(Exception e, String model, Target target, boolean isFirstResource) { return false; } @Override public boolean onResourceReady(GlideDrawable resource, String model, Target target, boolean isFromMemoryCache, boolean isFirstResource) { //imageView.setImageDrawable(resource); return false; }}).into(imageView); 设置监听的用处 可以用于监控请求发生错误来源，以及图片来源 是内存还是磁盘 14.设置动态GIF加载方式 Glide.with(this).load(imageUrl).asBitmap().into(imageView);//显示gif静态图片 Glide.with(this).load(imageUrl).asGif().into(imageView);//显示gif动态图片 15.缓存的动态清理 Glide.get(this).clearDiskCache();//清理磁盘缓存 需要在子线程中执行 Glide.get(this).clearMemory();//清理内存缓存 可以在UI主线程中进行","categories":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"},{"name":"glide","slug":"glide","permalink":"http://b.nearby.ren/tags/glide/"}]},{"title":"前段UI框架","slug":"前段Ui框架","date":"2016-06-08T08:03:12.000Z","updated":"2019-03-28T03:06:26.739Z","comments":true,"path":"2016/06/08/前段Ui框架/","link":"","permalink":"http://b.nearby.ren/2016/06/08/前段Ui框架/","excerpt":"十个前段UI优秀框架Bootstrap 首先说 Bootstrap，估计你也猜到会先说或者一定会有这个( 呵呵了 )，这是说明它的强大之处，拥有框架一壁江山的势气。自己刚入道的时候本着代码任何一个字母都得自己敲出来挡我者废的决心，来让自己成长。结果受到周围各种基友的引诱开始了 Bootstrap 旅程。本人虽然是个设计+前端的万里有一的人才，但是老天只让我会用 PS 和各种设计工具却不给我跟设计妹子一样的审美，所以这也是我最初选择 Bootstrap 的原因之一，它让我做出来的东西好歹能在妹子面前装个逼，不过时间长了难免觉得 Bootstrap 美的让人烦躁， 但好在它的每个版本都会有很大的改变，不会让人觉得自己做的网站会跟很多网站撞脸。Bootstrap 的用法及其简单( 这也可能就是 Bootstrap 作者阅攻城士无数，了解他们痛的结果 )，以至于是个小前端都可以快速上手，几乎没什么学习成本。 官网：http://getbootstrap.com/ Github：https://github.com/twbs/bootstrap/ 作者：Mark Otto 和Jacob Thornton Star：118,264 总结：Bootstrap 最大的优势就是它非常流行，流行就代表你有问题就有很多人帮你解决问题，就代表装逼它就是利器，还有就是界面比较和谐，容易上手，关注它的童鞋应该发现最新 V4 版也开始支持 FlexBox 布局，这是非常好的升级体验。 劣势是 class 命名不够语义化，并且各种缩写，以至于我离了文档就是个菜，最近开始整混合 APP，选框架的时候首选就是它，但之前搞 PC 一直没注意，后来搞混合右键属性看它的时候，瞬间一阵凉风袭来，Bootstrap 好小，小到我只好选择别的框架。","text":"十个前段UI优秀框架Bootstrap 首先说 Bootstrap，估计你也猜到会先说或者一定会有这个( 呵呵了 )，这是说明它的强大之处，拥有框架一壁江山的势气。自己刚入道的时候本着代码任何一个字母都得自己敲出来挡我者废的决心，来让自己成长。结果受到周围各种基友的引诱开始了 Bootstrap 旅程。本人虽然是个设计+前端的万里有一的人才，但是老天只让我会用 PS 和各种设计工具却不给我跟设计妹子一样的审美，所以这也是我最初选择 Bootstrap 的原因之一，它让我做出来的东西好歹能在妹子面前装个逼，不过时间长了难免觉得 Bootstrap 美的让人烦躁， 但好在它的每个版本都会有很大的改变，不会让人觉得自己做的网站会跟很多网站撞脸。Bootstrap 的用法及其简单( 这也可能就是 Bootstrap 作者阅攻城士无数，了解他们痛的结果 )，以至于是个小前端都可以快速上手，几乎没什么学习成本。 官网：http://getbootstrap.com/ Github：https://github.com/twbs/bootstrap/ 作者：Mark Otto 和Jacob Thornton Star：118,264 总结：Bootstrap 最大的优势就是它非常流行，流行就代表你有问题就有很多人帮你解决问题，就代表装逼它就是利器，还有就是界面比较和谐，容易上手，关注它的童鞋应该发现最新 V4 版也开始支持 FlexBox 布局，这是非常好的升级体验。 劣势是 class 命名不够语义化，并且各种缩写，以至于我离了文档就是个菜，最近开始整混合 APP，选框架的时候首选就是它，但之前搞 PC 一直没注意，后来搞混合右键属性看它的时候，瞬间一阵凉风袭来，Bootstrap 好小，小到我只好选择别的框架。AUI 第三个是最近刚起来的AUI，虽然作者声称是专为APICloud开发者设计的一套UI框架，但实际它还是解决了很多移动前端开发的普遍问题，是主要面向混合开发的 CSS 框架。看起来作者比较猖狂，各种高级 CSS3 遍地使用，这让我也不得不去查查这些个 CSS3 的兼容性。不负众望果然选的都是兼容不错的属性，哈哈了一顿激动从前辈手上大胆认识了几个好东西，并且框架还提供了聊天界面、计数列表等组件，解决了很多复杂的让我骂娘的布局，现在可以直接拿走就用。 Github：https://github.com/liulangnan/aui 官网：http://www.auicss.com/ 作者：流浪男 Star：682 总结：这个框架对我来说有个优点就是纯 CSS 框架，自己以前也就用过 Pure，自己有点 JS 能力，如果不是复杂的效果，找个纯 CSS 框架自己随便改改就可以，而现在 CSS3 也已经能够做到动画，效率、质量、高效全兼顾，所以还是选择了这种 CSS 框架。有一点觉得不满的是这框架的文档真的好那什么，说好的高大上呢。 Amaze UI 第二个介绍的是妹子UI，最初使用它是因为本尊遇到了一个爱纠结细节设计士，有一次她跟我的字体较上真了，结果一句顶万句的 BOOS 夸了她，我只好根据她的想法去解决，结果最后找到了Amaze UI 框架( 我不介意你叫我懒淫 )，按照官方的话说就是 “基于社区开源项目构建的一个跨屏前端框架，以移动优先，从小屏到大屏，最终实现所有屏幕适配，适应移动互联潮流” 。但其实我就是看中它能解决国内浏览器存在的跨屏适配和兼容性问题。 官网：http://amazeui.org/ Github：https://github.com/amazeui/amazeui 所属公司：云适配 Star：10,817 总结：Amaze UI 总的来说就是加入更多符合中国市场特性的元素，框架对跨屏、适配都做了的比较好的处理并且准备一了一系列的常用的网页组件，为减少搞兼容、适配各种敲键盘的加班狗们的工作时间做了不小的贡献。，框架还对中文排版优化，兼容中国本土主流浏览器、轻量化，不仅适用于桌面端，还更更适合移动端、包含一些封装好的Widgets。不过自也就我感觉 Amaze UI 文档是否有点太那什么了，比如 “人们不会在乎jQuery的那点流量。”，说实的在这真没啥，不过我从来不会说出来( 哈哈 )，代码和设计上感觉没太多突出的点。 Frozen UI 有段时间看到 QQ 瞬间高大上了，后来四处打听，原来 QQ 客服端也用了 混合开发，其中QQ会员前端用的是 Frozen UI，并且这套框架开源，欣喜若狂耐不住心里的寂寞直接上手试了一遍，初体验感觉基础样式效果简单色调清爽，有个比较活跃的社区所以组件什么的也比较丰富。 Github：https://github.com/frozenui/frozenui 官网：http://frozenui.github.io/ 作者： QQVIP FD Team Star：2,307 总结：如果拿 Frozen UI 配合一些如 APICloud 用来做混合 APP 感觉就太酷了，或者原生的火鸡们拿去嵌套在应用中做前端开发，这个框架对 android 2.3 +、ios 4.0 + 做了兼容，或者拿来做 Web App 也是极好的选择，劣势的话从 UI 层面就可以看到了，谁让它是出生在QQ会员前端的呢。 Frozen UI 第三个是Frozen UI，有段时间看到 QQ 瞬间高大上了，后来四处打听，原来 QQ 客服端也用了 HTML 混合开发，其中QQ会员前端就是用的 Frozen UI，并且这套框架开源，欣喜若狂耐不住心里的寂寞直接上手三下五除二试了一遍就开始试用，初体验的就是基础样式效果简单色调清爽，有个比较活跃的社区所以组件什么的也比较丰富。 Github：https://github.com/frozenui/frozenui 官网：http://frozenui.github.io/ 作者： QQVIP FD Team Star：1,067 总结：如果拿 Frozen UI 配合一些如 APICloud 用来做混合 APP 感觉就太酷了，或者原生的火鸡们拿去嵌套在应用中做前端开发，并且这个框架对 android 2.3 +、ios 4.0 + 做了兼容，或者拿来做 Web app 也是极好的选择，不过要是放在微信里比这更合适的 WeUI 框架更是首选了，劣势的话从 UI 层面就可以看到了，谁让它是出生在QQ会员前端的呢。 WeUIi 第四个是WeUI和同 FrozenUI都属于 差不多的 WeUi了，也是一个比较专一的框架，WeUI应该说比FrozenUI前者更专一，话说连个官网都不搞，所有答疑都在 gitHub Issues 解决了，这个框架极其简单，体积当然就不用说了，模块也就 7 个左右，不过体量虽然小做的却不错，口碑看 star 就够了，框架从 16/1/23 发版至今 github star 超过 7K,不过也不排除用户没地方发泄所以都跑到 git 上来，哈哈。 Github：https://github.com/weui/weui DEMO：http://weui.github.io/weui/ Star：16,573 总结：看完微信设计团队设计的这套 DEMO，二话不说如果要做微信公众，这个二话不说必然是首选了。框架不好的地方简而言之就是框架本身应该就没考虑过让用户用到非微信的场景之下。 SUI “SUI 是一套基于bootstrap开发的前端组件库，同时它她也是一套设计规范。通过SUI，可以非常方便的设计和实现精美的页面”。 果然还是直接引用官方给的枯燥无味广告要节省自己的脑细胞( 囧… )，当然了就像广告说的，如果你之前用过 Bootstrap， 那么可以轻松转向 SUI，这可能就是淘宝给前端屌丝们的福利了。。 Github：https://github.com/sdc-alibaba/sui 官网：http://sui.taobao.org/sui/docs/index.html Star：120 AUI 第六个是最近刚起来的最近刚起来的 AUI，虽然作者声称是专为APICloud开发者设计的一套UI框架，但实际它还是解决了很多移动前端开发的普遍问题，是它主要面向混合开发的 CSS 框架。，所以看起来作者比较猖狂，各种高级 CSS3 遍地使用，这也使得我不得不去查查这些个 CSS3 的兼容性。不负众望果然选的都是兼容不错的属性，哈哈了一顿激动从前辈手上大胆认识了几个好东西，并且框架还提供了聊天界面、计数列表等组件，解决了很多复杂的让我骂娘的布局，现在可以直接拿走就用。 Github：https://github.com/liulangnan/aui 官网：http://www.auicss.com/ 作者：流浪男 Star：319 总结：这个框架对我来说有个优点就是纯 CSS 框架，自己以前也就用过 Pure，自己有点 js 能力，如果不是复杂的效果自己找个纯 CSS 框架自己随便改改就能达到效果，而现在 CSS3 也已经能够做到各种动画，效率、质量、高效各种一顿考虑所以还是选择了这种 CSS 框架。而一直觉得不满的是这框架的文档真的好那什么，说好的高大上呢。 MUI 曾经一直使用 Android 系统的我，后来见到 IOS，果断移情别恋了，不知道为什么苹果每次调整系统我都特别喜欢，后来一段时间因为缺设计我专门模仿 IOS 系统做 UI，但始终不能够做到很好，无意间就发现了 MUI 这个框架，这个框架给我的吸引之处就是它的 UI 是以 IOS 为主体设计的，当然它也补充了android特有UI样式。并且MUI官方声称用来开发深入以后发现拿它做 APP 还能够提高用户使用流畅度，然后便试着更深入的了解和使用一段时间。 官网：http://dev.dcloud.net.cn/mui/ Github：https://github.com/dcloudio/mui Star：7,580 总结：就像之前说的这个框架是以两大系统为参照来封装UI组件，框架自身还有一个较为活跃的社区，不太好的地方这也是我特别关注的一点，关于开发应用的流畅度，我当然知道这是 H5 目前的劣势，但是看到官网给的描述，还是抱着期待的心理试试看能否提升，然而它其实还是需要是借助 Webview来提升，而不是框架本身。 Semantic UI 倒数第三个是 Semantic UI，接触这个框架还是因为 Bootstrap，Semantic UI 刚上线 github 就受到大量开发者的关注，以至于很多人拿它俩对比各种挑刺各种夸，是好是坏不能单凭别人三句四句就抬起手指开始赞，用了以后感觉 UI 上跟 Bootstrap 没太多的区别，不过代码命名规范上却相差甚大，本人认为 Semantic UI 是不是就想做的不一样，它的命名全是采用复合的方式，类名特别的离散，用的时候你得很小心自己扩展或者新增的 class 命名与它的类名冲突。 官网：http://www.semantic-ui.cn/ Github：https://github.com/semantic-org/semantic-ui/ Star：38,191 Foundation Foundation 算是框架界的元老啦，都说框架去的早，而这个框架一直到现在依然这么的热门，如果你比较介意 Bootstrap 开发撞脸的尴尬事情，那么你可以考虑使用 Foundation 。即使你使用预定义的 UI 元素, 也不会与其他网站太像，就像官方说的给开发者更灵活的框架体验。 官网：http://foundation.zurb.com/ Github：https://github.com/zurb/foundation-sites Star：26,659 UiKit UIkit是YOOtheme团队开发的，在许多WordPress主题中都有应用(也就是如果你是个 WordPress 爱好者，那么这个框架应该比较适合深究)，并且框架能够通过GUI编辑器和手动编辑，所以它提供了一个灵活、强大的自定义机制。框架借助LESS、jQuery、normalize.css及FontAwesome开源项目的独有特点，整合成了这么一款轻量级、模块化的前端框架。 官网：http://www.getuikit.com/Github：https://github.com/uikit/uikit作者：YOOtheme Star：11,037 Pure 终于最后一个了，我和你一样好开森 (～￣▽￣)～)，这个框架是我在做管理系统时接触的，选择使用也是因为框架小巧，并且是纯 CSS，没有太多的牵扯，好用来与其他框架快速结合使用。 官网：http://purecss.io/ Github：https://github.com/yahoo/pure/ Star：17,196","categories":[{"name":"web","slug":"web","permalink":"http://b.nearby.ren/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://b.nearby.ren/tags/web/"}]},{"title":"androidstudio项目目录结构解析","slug":"androidstudio项目目录结构解析","date":"2016-04-10T02:35:56.000Z","updated":"2017-07-18T08:19:48.230Z","comments":true,"path":"2016/04/10/androidstudio项目目录结构解析/","link":"","permalink":"http://b.nearby.ren/2016/04/10/androidstudio项目目录结构解析/","excerpt":"","text":"首先先上图 大家看到的是android studio 创建的项目清单【图方便，就用完整的项目来做示例 - - 】app/build app模块build编译输出的目录( 关于上传svn或github需要忽略的文件待会说明)app/build.gradle (主要配置 编译sdk版本、编译工具 、包名、sdk最低支持版本、目标sdk版本、app版本号、app版本名称、ndk等等)app/app.iml app模块的配置文件(Intellij模块文件，很重要但是基本不用管，大家都知道Intellij是AndroidStudio的亲妈的嘛，所以有这个文件是正常的)app/proguard-rules.pro app模块proguard文件(混淆配置文件,主要用于打包签名apk配置混淆代码[是否混淆是可选的])build.gradle 项目的build.gradle编译文件，主要就是申明仓库地址和版本号settings.gradle定义项目包含哪些模块[指引用了哪些外库]local.properties 配置SDK/NDKnearby.iml 项目的配置文件External Libraries 项目依赖的Lib, 编译时自动下载的 AndroidStudio自动忽略 现在的AndroidStudio已经很智能了，当创建项目的时候自动给我们创建了一个 上传svn或git需要忽略的文件如下： .gitignore 并给我们忽略了一些文件 *.iml .gradle /local.properties /.idea/workspace.xml /.idea/libraries .DS_Store /build /captures 手动忽略 1、.idea文件 2、.gradle文件夹 3、所有的build文件夹 4、所有的.iml文件 5、local.properties文件","categories":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"}]},{"title":"一秒钟看懂SaaS、CRM、OA、ERP、HR、进销存","slug":"一秒钟看懂SaaS、CRM、OA、ERP、HR、进销存","date":"2016-03-28T01:37:48.000Z","updated":"2017-07-18T08:21:29.550Z","comments":true,"path":"2016/03/28/一秒钟看懂SaaS、CRM、OA、ERP、HR、进销存/","link":"","permalink":"http://b.nearby.ren/2016/03/28/一秒钟看懂SaaS、CRM、OA、ERP、HR、进销存/","excerpt":"","text":"自2014年以来，SaaS、CRM、OA、ERP、HR、APM、进销存、财务系统等，这些名词大量出现在微信朋友圈、电视楼宇广告和千百万融资资讯中。它们到底是什么意思？相互之间又有什么区别？在这个飞速发展的互联网时代，再不知道这些可就OUT了！ SaaS、CRM、OA、ERP、HR、进销存究竟是什么？ SaaS模式就像用自来水 2015年被媒体和IT从业人员称为SaaS元年。什么是SaaS呢？SaaS是Software-as-a-Service（软件即服务）的简称，“软件即服务”，简单理解也就是“按需租用别人提供的软件服务”，它是一种软件交付模式。SaaS这个说法是区别于以往软件购买和交付方式而提出的。 在以往，如果你的公司需要使用一款软件来管理财务记账，作为公司管理者，你需要向软件提供公司说明需求、支付购买软件的费用并提供安装软件的硬件环境，然后软件公司就会上门安装调试软件，调试完后就可以正式投入使用了。 这里有一个很显著的特点是，软件都安装在你指定的地方，你拥有100%的管控权，相应的，你后续还需要继续投入人员和资源来维护系统的正常运行。 SaaS的模式就不一样了，在客户还没有到来之前，软件提供公司就自己提服务器、数据库等硬件，把软件安装发布好，这样作为软件使用方的你就变得轻松很多，一上来就可以直接进行体验，体验之后，你觉得哪些功能合适你的，就挑选出来，按月支付比较低廉的费用就可以正式使用了。后续的升级、维护也由软件公司负责。简而言之，SaaS模式就是软件提供公司事先把所有的软件相关工作都归类准备好了，用户直接过来挑选自己需要的用就OK了。 业内有一个很恰当的比喻：一开始的时候，各家都是自己挖井抽水蓄水，挖井抽水蓄水的技术是有专业的公司提供，但总的来说喝水这个事情是自家管自家的，这是传统软件的供水模式。在SaaS模式下，挖井抽水蓄水净水修水管这些工作对使用方来说都是透明的，你有需要的时候就打开水龙头取水就OK了，然后每月自来水公司会过来跟你结算。同样的，优缺点很明显，优点是按需用水省事了，成本变低了，缺点是水由水务公司完全控制，供水稳定性、供水质量取决于水务公司实力。 CRM是什么呢？追踪客户的 CRM是英文Customer Relationship Management （客户关系管理）的简称。这个比较好理解，就是用来管理客户的。 一般来说，CRM客户管理系统由客户信息管理、销售过程自动化（SFA）、营销自动化（MA）、客户服务与支持（CSS）管理、客户分析（CA）系统这5大主要功能模块组成。 通俗一点说，CRM系统特别是移动CRM系统能帮助你及你的同事很方便地记录客户信息、跟踪分析新老客户、挖掘潜在客户。 OA是什么呢？管办公室活动的 OA是Office Automation（办公自动化）的简称，本来OA涵盖的范围非常广泛，基本上所有和办公相关的系统都可以称作是OA，但现在大都数公司都把OA系统定义为企业内部的协作沟通系统，一般提供的功能有流程审批（请假报销等）、即时沟通、文档管理、内部论坛、任务管理、会议管理、通讯录、问卷调查等。 ERP是什么呢？生产制造一条龙全包 ERP是Enterprise Resource Planning（企业资源计划）的简称，从字面上理解，各企业的资源、计划相关的管理都可以算在ERP的范畴里，比如员工、生产、制造、财务、销售、采购、仓储、分销、质量等等，只要是用于企业管理的软件都属于ERP的范畴。由于越来越多的细分系统的出现，行业内人们为了做区分，一般把功能比较全面（往往包含从原料到生产到仓储到销售一系列）的偏生产制造的管理系统才定义为ERP系统，而其中某项细分功能的系统虽然原则上属于ERP，但一般不称为ERP。 HR软件是什么？管员工的 HR软件是human resource software（人力资源软件）的简称，就是用来管理人事相关的系统，比如招聘管理、职工管理、劳动合同、奖惩管理、办公用品、培训管理、绩效管理、考勤管理、社保管理等。 什么是进销存？ 进销存是指企业管理过程中采购（进货）→入库（库存）→销售（销货）的三个管理过程。这三个过程是一般企业特别是中小商户的核心经营过程，用来管理这三个过程的系统就是进销存系统，简称进销存。 什么是财务系统？ 财务系统是指专门用于完成会计工作的管理系统。财务系统一般包含：总账管理、固定资产管理、资金管理、客户及应收应付管理、报表管理、财务分析、核算系统等。 SaaS、CRM、OA、ERP、HR、进销存、财务系统的区别在哪里？ SaaS是一种软件交付（交易）模式，以这种“按需租用”模式提供服务的软件称为SaaS，目前大部分的软件都采取这种模式，也就是说大部分的OA、ERP、HR、进销存、财务系统都可以叫作SaaS软件。由于ERP系统覆盖的链条很长，一般需要深度定制，所以比较少是以SaaS提供的。 现在的CRM、OA、HR、进销存、财务系统一般都以SaaS方式提供，CRM更专注于销售方面的管理，OA更专注于企业内部的协作沟通，HR更专注于人力管理，进销存专注于仓库相关的管理、财务系统专注资产、预算相关的管理。 由于它们涉及到企业不同时间段、不同角色、不同业务等各个方面，同时也因为各企业的规模、经营方式几乎完全不同，所以目前没有哪一款产品能囊括CRM、OA、HR、进销存等这些功能，目前市面上的产品能还处于在自己专注的领域深耕发展的阶段。 当然为了更快地拉开同竞争对手的差距，它们往往选择开放相互对接的方式，比较钉钉这些OA系统就提供了开放平台，用于对接进销存、财务系统。 CRM、OA、ERP、HR、进销存、财务系统目前有哪些代表产品？ CRM的标杆是美国的Salesforce，国内有纷享逍客、销售易、红圈营销、八百客等。 OA在国内有钉钉、云之家、今目标、微信企业号、企业微信（即将上线）这几个产品，有很多稍微大一点的企业内部会自建OA系统，等内部使用实施成熟后也会开放出来供外部使用。 ERP和财务系统，素来有“南金蝶北用友”之称，这两家拿下中国大部分市场份额，SAP则是全球最成功是ERP厂商，据称85%的世界500强公司都有使用SAP系统，但这套系统非常昂贵非常复杂，不适用于中小企业。 HR。有北森、dayHR、金柚等，由于单纯的HR系统很容易被OA或进销存击穿，现在的HR往往做得非常深，人才评测、招聘等都会涉及。 进销存系统，有管家婆、智慧记、云销城、秦丝生意通等，在采购、销售、库存这三个最核心的管理环节需求会非常强烈，但对于操作速度要求很高，一般软件很难满足，所以目前来说进销存的普及率还不到8%。 2016年CRM、OA、ERP、HR、进销存、财务系统的趋势是怎么样的？ 1、SaaS化。对于提供方而言标准化的SaaS产品更具有爆发性，对于消费方而言SaaS具有低成本、随时随地接入访问这些特性，再加上IT基础设施、安全技术等方面的成熟，SaaS将成为以后最主要的软件模式。 2、移动化。金蝶创始人徐少春在发布云之家的时候，把笔记本直接扔进垃圾桶了，说以后只使用手机办公，这虽然是一个噱头，但确实说明移动办公是个大趋势。 3、垂直化。前面说过，不同规模、不同阶段、不同行业的企业对企业应用的需求千差万别，企业内部中不同岗位、不同时段、不同职别的员工对企业应用的需求同样也千差万别，往往需要垂直细分到具体的行业才有可能做精，做更好的体验。 4、免费化。SaaS化、竞争白热化、周边资源可整合、软件边际成本趋零等这些原因会使得免费的企业级应用会越来越多。 5、合纵连横化。条件成熟，创业公司有机会崛起，BAT头巨头大举进入，在这个巨大的看似类似却又碎片化的领域，接下来我们会看到一场场合纵连横的好戏会不断上演。 6、更普及。以前信息化系统成本很高，往往只有大企业才有能力使用，现在条件成熟，投资机构热钱及创业者的热情投入，企业级应用空前繁荣，企业无论大小都能选择一款适合自己的应用。 涨姿势：几个概念 企业级应用。是指为商业组织、企业服务的应用系统，业内一般称为To B类应用，用于区别对个人类的应用（To C）。 APM是Application Performance Management &amp; Monitoring（应用性能管理 &amp; 监控）的简称，是用来监控和管理应用软件是否有效运行的，为上面据说的系统提供相关的监控。 EIP 是Enterprise Information Portal（企业信息门户）的简称，当一公司把前面所提到的OA、进销存、财务等等系统都使用上之后，使用人员需要在各个系统之间来回切换，非常麻烦低效，于是EIP就出现了，它就是把各种应用系统统一集成到一个入口系统中，在一平台时管理各个业务。 客服系统可以说是CRM系统的延伸，主要提供在线客服聊天、机器人客服、帮助文档、客户反馈等功能。 原文地址","categories":[],"tags":[]},{"title":"android开发的经验教训","slug":"android开发的经验教训","date":"2016-03-11T02:19:45.000Z","updated":"2016-12-21T09:05:34.246Z","comments":true,"path":"2016/03/11/android开发的经验教训/","link":"","permalink":"http://b.nearby.ren/2016/03/11/android开发的经验教训/","excerpt":"","text":"在添加任何第三方party之前，请三思：这真的是一个成熟的项目吗？ 如果一个东西用户看不到，就不要绘制它！ 除非真的需要，否则别使用数据库； 达到65k方法数限制来的非常快，真的，非常快！不过 multidexing 可以拯救你; RxJava 是 AsyncTasks 以及其它杂碎的最佳替代者； Retrofit 可能是现在最佳的网络请求库； 使用 Retrolambda来简化你的代码； 把 RxJava 和 Retrofit 以及 Retrolambda 结合起来会让你酷炸天！ 我使用 EventBus而且它也很好，但是我并不会用太多，因为这样代码库会变得凌乱； 包名按照功能来，而不是按分层来; 把所有东西都移到 application thread之外； lint 可以帮助你优化布局与布局树，这样你就能识别出那些可能已经被移除的冗余的View； 如果你在使用gradle，使用一切可能的方式去加速它； 对builds做profile reports，以便知道什么占据了编译时间； 使用一个 有名的 架构； 测试时比较花时间，但是一旦你找到诀窍它可以比不使用测试更快、更健壮; 使用 依赖注入 让你的app更模块化，从而更易于测试； 收听 fragmented podcast 将会让你受益； 千万别用私人邮箱作为你安卓市场的发布者账号; 总是使用恰当的输入类型； Use analytics to find usage patterns and isolate bugs; 关注最新的 libraries（使用dryrun 来快速查看它们的的效果） 你的service应该做你所需的事情，并且尽快死去； 使用 Account Manager 来提示登录用户名和邮箱地址； 使用CI（持续集成）来构建和发布你的beta和产品apk； 不要运行自己的CIserver，维护server是费时的事情，因为磁盘空间，安全问题，更新server以防止SSL攻击等等原因。使用circleci, travis 或者 shippable, 它们便宜，而且你也可以少担心一些事情； Automate your deployments to the playstore; 如果一个library很大而你只需要使用其中的一部分功能，你应该寻找一个更小的来替代（比如依靠proguard ）； 不要使用多于实际需要的module。从零开始编译一个module或者仅仅是检查上个module是否最新所需要的时间几乎是加载 binary .jar/.aar依赖的4倍以上； 开始考虑用SVG来替代PNG ； Make library abstraction classes, it’ll be way easier to switch to a new library if you only need to switch in one place (e.g.AppLogger.d(“message”) can contain Log.d(TAG, message) and later realise that Timber.d(message) is a better option); 监控你的连接情况以及连接类型（wifi之下更新更多数据？）； 监控你的电源和电量（在充电的时候更新更多的数据？电量低的时候暂停更新？）； 一个用户界面就如一个笑话那样，如果你需要解释，那么证明它并不够好； Tests are great for performance: Write slow (but correct) implementation then verify optimizations don’t break anything with tests. 原文：Building Android Apps — 30 things that experience made me learn the hard way。","categories":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"}]},{"title":"Flex布局教程链接","slug":"Flex布局教程链接","date":"2016-03-09T08:03:12.000Z","updated":"2019-03-28T03:06:46.813Z","comments":true,"path":"2016/03/09/Flex布局教程链接/","link":"","permalink":"http://b.nearby.ren/2016/03/09/Flex布局教程链接/","excerpt":"","text":"Flex布局教程链接[语法篇]http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?^%$[实例篇]http://www.ruanyifeng.com/blog/2015/07/flex-examples.html","categories":[{"name":"web","slug":"web","permalink":"http://b.nearby.ren/categories/web/"}],"tags":[{"name":"h5","slug":"h5","permalink":"http://b.nearby.ren/tags/h5/"}]},{"title":"设计模式中类的关系","slug":"设计模式中类的关系","date":"2016-02-24T07:28:13.000Z","updated":"2017-07-18T08:15:59.870Z","comments":true,"path":"2016/02/24/设计模式中类的关系/","link":"","permalink":"http://b.nearby.ren/2016/02/24/设计模式中类的关系/","excerpt":"","text":"在Java以及其他的面向对象设计模式中，类与类之间主要有6种关系，他们分别是：依赖、关联、聚合、组合、继承、实现。他们的耦合度依次增强。 依赖（Dependence）依赖关系的定义为：对于两个相对独立的对象，当一个对象负责构造另一个对象的实例，或者依赖另一个对象的服务时，这两个对象之间主要体现为依赖关系。定义比较晦涩难懂，但在java中的表现还是比较直观的：类A当中使用了类B，其中类B是作为类A的方法参数、方法中的局部变量、或者静态方法调用。类上面的图例中：People类依赖于Book类和Food类，Book类和Food类是作为类中方法的参数形式出现在People类中的。 代码样例： 123456789public class People &#123;public void read(Book book)&#123; System.out.println(\"读的书是\"+book.getName()); &#125;&#125; 关联（Association）单项关联：双向关联： 对于两个相对独立的对象，当一个对象的实例与另一个对象的一些特定实例存在固定的对应关系时，这两个对象之间为关联关系。关联关系分为单向关联和双向关联。在java中，单向关联表现为：类A当中使用了类B，其中类B是作为类A的成员变量。双向关联表现为：类A当中使用了类B作为成员变量；同时类B中也使用了类A作为成员变量。 代码样例： 123456789101112131415public class Son &#123; Father father = new Father(); System.out.println(\"从\"+father.getName()+\"获得礼物\"); &#125;public class Father &#123; Son son = new Son(); System.out.println(\"从\"+son.getName()+\"获得礼物\")&#125; 聚合（Aggregation） 聚合关系是关联关系的一种，耦合度强于关联，他们的代码表现是相同的，仅仅是在语义上有所区别：关联关系的对象间是相互独立的，而聚合关系的对象之间存在着包容关系，他们之间是“整体-个体”的相互关系。 代码样例：1234567891011121314151617181920212223242526272829303132public class People&#123; Car car; House house; public void setCar(Car car)&#123; this.car = car; &#125; public void setHouse(House house)&#123; this.house = house;&#125; public void driver()&#123; System.out.println(\"车型号:\"+car.getType()); &#125; public void sleep()&#123; System.out.println(\"我在房子里睡觉:\"+house.getAddress()); &#125;&#125; 组合（Composition） 相比于聚合，组合是一种耦合度更强的关联关系。存在组合关系的类表示“整体-部分”的关联关系，“整体”负责“部分”的生命周期，他们之间是共生共死的；并且“部分”单独存在时没有任何意义。在下图的例子中，People与Soul、Body之间是组合关系，当人的生命周期开始时，必须同时有灵魂和肉体；当人的生命周期结束时，灵魂肉体随之消亡；无论是灵魂还是肉体，都不能单独存在，他们必须作为人的组成部分存在。 123456789101112131415161718192021222324252627public class People&#123; Soul soul; Body body; public People(Soul soul,Body body)&#123; this.soul = soul; this.body = body; &#125; public void study()&#123; System.out.println(\"学习要灵魂:\"+soul.getName()); &#125; public void eat()&#123; System.out.println(\"吃饭需要身体:\"+body.getName()); &#125;&#125; 继承（GeneraliZation） 继承表示类与类（或者接口与接口）之间的父子关系。在java中，用关键字extends表示继承关系。UML图例中，继承关系用实线+空心箭头表示，箭头指向父类。 实现（Implementation） 表示一个类实现一个或多个接口的方法。接口定义好操作的集合，由实现类去完成接口的具体操作。在java中使用implements表示。UML图例中，实现关系用虚线+空心箭头表示，箭头指向接口。","categories":[{"name":"java","slug":"java","permalink":"http://b.nearby.ren/categories/java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://b.nearby.ren/tags/设计模式/"}]},{"title":"service详解","slug":"service详解","date":"2016-01-18T06:00:17.000Z","updated":"2021-10-03T03:02:14.357Z","comments":true,"path":"2016/01/18/service详解/","link":"","permalink":"http://b.nearby.ren/2016/01/18/service详解/","excerpt":"","text":"android server 详解 Service的种类： 一、Service的种类 本地服务， Local Service用于应用程序内部。在Service可以调用Context.startService()启动，调用Context.stopService()结束。在内部可以调用Service.stopSelf()或Service.stopSelfResult()来自己停止。无论调用了多少次startService()，都只需调用一次stopService()来停止。 远程服务， Remote Service用于android系统内部的应用程序之间。可以定义接口并把接口暴露出来，以便其他应用进行操作。客户端建立到服务对象的连接，并通过那个连接来调用服务。调用Context.bindService()方法建立连接，并启动，以调用Context.unbindService()关闭连接。多个客户端可以绑定至同一个服务。如果服务此时还没有加载，bindService()会先加载它。 提供给可被其他应用复用，比如定义一个天气预报服务，提供与其他应用调用即可。 二、生命周期 1). 被启动的服务的生命周期：如果一个Service被某个Activity 调用 Context.startService方法启动，那么不管是否有Activity使用bindService绑定或unbindService解除绑定到该Service，该Service都在后台运行。如果一个Service被startService 方法多次启动，那么onCreate方法只会调用一次，onStart将会被调用多次（对应调用startService的次数），并且系统只会创建Service的一个实例（因此你应该知道只需要一次stopService调用）。该Service将会一直在后台运行，而不管对应程序的Activity是否在运行，直到被调用stopService，或自身的stopSelf方法。当然如果系统资源不足，android系统也可能结束服务。 2). 被绑定的服务的生命周期：如果一个Service被某个Activity 调用 Context.bindService 方法绑定启动，不管调用 bindService调用几次，onCreate方法都只会调用一次，同时onStart方法始终不会被调用。当连接建立之后，Service将会一直运行，除非调用Context.unbindService 断开连接或者之前调用bindService 的 Context 不存在了（如Activity被finish的时候），系统将会自动停止Service，对应onDestroy将被调用。 3).被启动又被绑定的服务的生命周期：如果一个Service又被启动又被绑定，则该Service将会一直在后台运行。并且不管如何调用，onCreate始终只会调用一次，对应startService调用多少次，Service的onStart便会调用多少次。调用unbindService将不会停止Service，而必须调用 stopService 或 Service的 stopSelf 来停止服务。 4).当服务被停止时清除服务：当一个Service被终止（1、调用stopService；2、调用stopSelf；3、不再有绑定的连接（没有被启动））时，onDestroy方法将会被调用，在这里你应当做一些清除工作，如停止在Service中创建并运行的线程。 特别注意： 你应当知道在调用 bindService 绑定到Service的时候，你就应当保证在某处调用 unbindService解除绑定（尽管Activity被finish的时候绑定会自动解除，并且Service会自动停止） 你应当注意 使用 startService 启动服务之后，一定要使用stopService停止服务，不管你是否使用bindService。 同时使用 startService 与 bindService 要注意到，Service的终止，需要unbindService与stopService同时调用，才能终止 Service，不管 startService 与bindService 的调用顺序，如果先调用 unbindService 此时服务不会自动终止，再调用 stopService之后服务才会停止，如果先调用 stopService 此时服务也不会终止，而再调用 unbindService 或者 之前调用bindService 的 Context 不存在了（如Activity 被 finish 的时候）之后服务才会自动停止。 当在旋转手机屏幕的时候，当手机屏幕在“横”“竖”变换时，此时如果你的 Activity 如果会自动旋转的话，旋转其实是 Activity的重新创建，因此旋转之前的使用 bindService 建立的连接便会断开（Context 不存在了），对应服务的生命周期与上述相同 在 sdk 2.0 及其以后的版本中，对应的 onStart 已经被否决变为了 onStartCommand，不过之前的 onStart任然有效。这意味着，如果你开发的应用程序用的 sdk 为 2.0 及其以后的版本，那么你应当使用 onStartCommand 而不是onStart。 例子： public class ServiceDemo extends Service { public static final String TAG = &quot;ServiceDemo&quot; ; public static final String ACTION = &quot;com.demo.SERVICE_DEMO&quot;; /** * onBind 是 Service 的虚方法，因此我们不得不实现它。 * 返回 null，表示客服端不能建立到此服务的连接，所以不会调用onServiceConnected。 */ @Override public IBinder onBind(Intent intent) { Log.i(TAG, this.toString() + &quot; ServiceDemo onBind&quot;); return null; } @Override public void onCreate() { Log.i(TAG, this.toString() + &quot; ServiceDemo onCreate&quot;); super.onCreate(); } @Override public void onStart(Intent intent, int startId) { Log.i(TAG, this.toString() + &quot; ServiceDemo onStart&quot;); super.onStart(intent, startId); } @Override public int onStartCommand(Intent intent, int flags, int startId) { Log.i(TAG, this.toString() + &quot; ServiceDemo onStartCommand&quot;); return super.onStartCommand(intent, flags, startId); } @Override public boolean onUnbind(Intent intent) { Log.i(TAG, this.toString() + &quot; ServiceDemo onUnbind&quot;); return super.onUnbind(intent); } @Override public void onDestroy() { Log.i(TAG, this.toString() + &quot; ServiceDemo onDestroy&quot;); super.onDestroy(); } } &lt;!-- android:exported 这个属性用于指示该服务是否能够被其他应用程序组件调用或跟它交互。 如果设置为true，则能够被调用或交互，否则不能。设置为false时， 只有同一个应用程序的组件或带有相同用户ID的应用程序才能启动或绑定该服务。--&gt; &lt;service android:name=&quot;.ServiceDemo&quot; android:exported=&quot;false&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.demo.SERVICE_DEMO&quot; /&gt; &lt;category android:name=&quot;android.intent.category.default&quot; /&gt; &lt;/intent-filter&gt; &lt;/service&gt; 通过Context.startService(Intent)方法启动service或者Context.bindService方法来绑定service public class MainActivity extends ActionBarActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.btn_bindService).setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { bindService(new Intent(ServiceDemo.ACTION), conn, BIND_AUTO_CREATE); } }); findViewById(R.id.btn_unbindService).setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { unbindService(conn); } }); findViewById(R.id.btn_startService).setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { startService(new Intent(ServiceDemo.ACTION)); } }); findViewById(R.id.btn_stopService).setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { stopService(new Intent(ServiceDemo.ACTION)); } }); } ServiceConnection conn = new ServiceConnection() { public void onServiceConnected(ComponentName name, IBinder service) { Log.i(ServiceDemo.TAG, service.toString() + &quot; onServiceConnected&quot;); } public void onServiceDisconnected(ComponentName name) { Log.i(ServiceDemo.TAG, &quot;onServiceDisconnected&quot;); } }; @Override protected void onDestroy() { super.onDestroy(); } } 日志输出： 上面的截图是点击绑定服务时输出的。可以看出，只调用了onCreate方法和onBind方法，当重复点击绑定服务时，没有再输出任何日志，并且不报错。onCreate方法是在第一次创建Service时调用的，而且只调用一次。另外，在绑定服务时，给定了参数BIND_AUTO_CREATE，即当服务不存在时，自动创建，如果服务已经启动了或者创建了，那么只会掉调用onBind方法。当解除绑定的时，可以看出，Service调用onUnbind和onDestroy销毁了服务。上面的截图是在多次点击启动服务时输出的。可以看出，在第一次点击时，因为Service还未创建，所以调用了onCreate方法，紧接着调用了onStartCommand和onStart方法。当再次点击启动服务时，仍然调用了onStartCommand和onStart方法，所以，在Service中做任务处理时需要注意这点，因为一个Service可以被重复启动。当点停止服务的时，Service只是执行onDestroy方法，跟绑定还是有点小区别。这里说一下，平常使用多的是startService方法，可以把一些耗时的任务放到后台去处理，当处理完成后，可以通过广播来通知前台。而onBind方法更多的是结合AIDL来使用，这样一个应用可以通过绑定服务获得的IBinder来拿到后台的接口，进而调用AIDL中定义的方法，进行数据交换等。 三、Local 与 Remote 服务绑定 1) Local 服务绑定：Local 服务的绑定较简单，首先在 Service 中我们需要实现 Service 的抽象方法 onBind，并返回一个实现 IBinder 接口的对象。 Service 中的代码： public class LocalService extends Service{ public static final String TAG = &quot;LocalService&quot; ; public static final String ACTION = &quot;com.demo.LOCAL_SERVICE&quot;; public SimpleBinder sBinder; public class SimpleBinder extends Binder{ public LocalService getService(){ return LocalService.this; } public int add(int a, int b){ return a + b; } } @Override public void onCreate() { super.onCreate(); // 创建 SimpleBinder sBinder = new SimpleBinder(); } @Override public IBinder onBind(Intent intent) { // 返回 SimpleBinder 对象 Log.i(TAG, &quot;LocalService onBind&quot;); return sBinder; } @Override public boolean onUnbind(Intent intent) { Log.i(TAG, &quot;LocalService onUnbind&quot;); return super.onUnbind(intent); } } &lt;service android:name=&quot;.LocalService&quot; android:exported=&quot;false&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.demo.LOCAL_SERVICE&quot; /&gt; &lt;category android:name=&quot;android.intent.category.default&quot; /&gt; &lt;/intent-filter&gt; &lt;/service&gt; public class LocalActivity extends ActionBarActivity { private ServiceConnection sc; private boolean isBind; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_local); sc = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { Log.i(LocalService.TAG, &quot;onServiceConnected&quot;); LocalService.SimpleBinder sBinder = (LocalService.SimpleBinder)service; Log.i(LocalService.TAG, &quot;3 + 5 = &quot; + sBinder.add(3, 5)); } @Override public void onServiceDisconnected(ComponentName name) { Log.i(LocalService.TAG, &quot; onServiceDisconnected&quot;); } }; findViewById(R.id.btn_bindService).setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { bindService(new Intent(LocalService.ACTION), sc, Context.BIND_AUTO_CREATE); isBind = true; } }); findViewById(R.id.btn_unbindService).setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { if(isBind){ unbindService(sc); isBind = false; } } }); } } 在 Activity 中，我们通过 ServiceConnection 接口来取得建立连接 与 连接意外丢失的回调。bindService有三个参数，第一个是用于区分 Service 的Intent 与 startService 中的 Intent 一致，第二个是实现了 ServiceConnection 接口的对象，最后一个是 flag 标志位。有两个flag，BIND_DEBUG_UNBIND 与 BIND_AUTO_CREATE，前者用于调试（详细内容可以查看javadoc 上面描述的很清楚），后者默认使用。unbindService 解除绑定，参数则为之前创建的 ServiceConnection 接口对象。另外，多次调用 unbindService 来释放相同的连接会抛出异常，因此我创建了一个 boolean 变量来判断是否 unbindService 已经被调用过。 运行结果： 在绑定服务的时候，需要一个服务连接对象，ServiceConnection，服务一旦连接，就会调用onServiceConnected方法，我们可以在这个方法里面返回我们的本地服务对象，具体看代码；而在服务断开时候会调用onServiceDisconnected方法，我们可以清理一些服务资源。 2) Remote 服务绑定：之前所谈的Service属于Local Service，即Service和Client在同一进程内（即同一application内），Service的生命周期服从进程的生命周期。在实际应用上，有时希望Service作为后台服务，不仅被同一进程内的activity使用，也可被其他进程所使用。 通常每个应用程序都在它自己的进程内运行，但有时需要在进程之间传递对象（IPC通信），你可以通过应用程序UI的方式写个运行在一个不同的进程中的service。在android平台中，一个进程通常不能访问其它进程中的内存区域。所以，他们需要把对象拆分成操作系统能理解的简单形式，以便伪装成对象跨越边界访问。编写这种伪装代码相当的枯燥乏味，好在android为我们提供了AIDL工具可以来做这件事。 AIDL(android接口描述语言)是一个IDL语言，它可以生成一段代码，可以使在一个android设备上运行的两个进程使用内部通信进程进行交互。如果你需要在一个进程中(例如在一个Activity中)访问另一个进程中(例如一个Service)某个对象的方法，你就可以使用AIDL来生成这样的代码来伪装传递各种参数。 Android提供AIDL（Android Interface Definition Language）工具帮助IPC之间接口的建立，大大地简化了开发者视图。通过下面的步骤实现client和service之间的通信：1）定义AIDL接口 ，Eclipse将自动为Service建立接口IService2）Client连接Service，连接到IService暴露给Client的Stub，获得stub对象；换句话，Service通过接口中的Stub向client提供服务，在IService中对抽象IService.Stub具体实现。3）Client和Service连接后，Client可向使用本地方法那样，简单地直接调用IService.Stub里面的方法。下面的例子给出client从提供定时计数的Remote Service，称为TestRemoteService，中获得服务的例子。 步骤1：通过AIDL文件定义Service向client提供的接口，ITestRemoteService.aidl文件如下 interface ITestRemoteService { int getCounter(); } 我们在src的目录下添加一个ITestRemoteService.aidl文件，语法和java的相同。在这个例子中Service很简单，只提供计数器的值，故在接口中我们定义了int getCounter( )。 AIDL文件很简单，Eclipse会根据文件自动生成相关的一个java interface文件，不过没有显示出来，如果直接使用命令行工具会帮助生成java文件。 步骤2：Remote Service的编写，通过onBind()，在client连接时，传递stub对象。 TestRemoteService.java文件如下： //Service提供一个定时计数器，采用Runnable的方式实现。 public class TestRemoteService extends Service{ private Handler serviceHandler = null; private int counter = 0; private TestCounterTask myTask = new TestCounterTask(); public void onCreate() { super.onCreate(); showInfo(&quot;remote service onCreate()&quot;); } public void onDestroy() { super.onDestroy(); serviceHandler.removeCallbacks(myTask); //停止计数器 serviceHandler = null; showInfo(&quot;remote service onDestroy()&quot;); } public void onStart(Intent intent, int startId) { // 开启计数器 super.onStart(intent, startId); serviceHandler=new Handler(); serviceHandler.postDelayed(myTask, 1000); showInfo(&quot;remote service onStart()&quot;); } //步骤2.1：具体实现接口中暴露给client的Stub，提供一个stub inner class来具体实现。 private ITestRemoteService.Stub stub= new ITestRemoteService.Stub() { //步骤2.1：具体实现AIDL文件中接口的定义的各个方法。 public int getCounter() throws RemoteException { showInfo(&quot;getCounter()&quot;); return counter; } }; //步骤2.2：当client连接时，将触发onBind()，Service向client返回一个stub对象， //由此client可以通过stub对象来访问Service，本例中通过stub.getCounter()就可以获得计时器的当前计数。 //在这个例子中，我们向所有的client传递同一stub对象。 public IBinder onBind(Intent arg0) { //我们特别跟踪了stub对象的地址，可以在client连接service中看看通过ServiceConnection传递给client showInfo(&quot;onBind() &quot; + stub); return stub; } //用Runnable使用定时计数器，每10秒计数器加1。 private class TestCounterTask implements Runnable{ public void run() { ++ counter; serviceHandler.postDelayed(myTask,10000); showInfo(&quot;running &quot; + counter); } } //showInfo() 帮助我们进行信息跟踪，更好了解Service的运行情况 private void showInfo(String s){ System.out.println(&quot;[&quot; +getClass().getSimpleName()+&quot;@&quot; + Thread.currentThread().getName()+ &quot;] &quot; + s); } } 步骤3：Client和Service建立连接，获得stub，ServiceTest4.java代码如下 public class ServiceTest4 extends Activity{ //步骤3.1 定义接口变量 private ITestRemoteService remoteService = null; private boolean isStarted = false; //步骤3.1 定义连接变量，实现ServiceConnection接口 private CounterServiceConnection conn = null; protected void onCreate(Bundle savedInstanceState) { //5个button分别触发startService( )，stopService( ) , //bindService( ), releaseService( )和invokeService( )， //下面两行，一行是显示从Service中获得的计数值，一行显示状态。 } private void startService(){ Intent i = new Intent(); //我的这个包里面还有层次，如*.part1、*.part2,etc i.setClassName(&quot;com.wei.android.learning&quot;, &quot;com.wei.android.learning.part5.TestRemoteService&quot;); //和之前的local service一样，通过intent开启Service，触发onCreate()[if Service没有开启]-&gt;onStart() startService(i); isStarted = true; updateServiceStatus(); } private void stopService(){ Intent i = new Intent(); i.setClassName(&quot;com.wei.android.learning&quot;,&quot;com.wei.android.learning.part5.TestRemoteService&quot;); stopService(i); //触发Service的 onDestroy()[if Service存在] isStarted = false; updateServiceStatus(); } //步骤3.3：bindService( )通过一个实现ServiceConnection接口的类于Service之间建立连接， //注意到里面的参数Context.BIND_AUTO_CREATE，触发onCreate()[if Service不存在] –&gt; onBind(). private void bindService(){ if(conn == null){ conn = new CounterServiceConnection(); Intent i = new Intent(); i.setClassName(&quot;com.wei.android.learning&quot;,&quot;com.wei.android.learning.part5.TestRemoteService&quot;); bindService(i, conn,Context.BIND_AUTO_CREATE); updateServiceStatus(); } } private void releaseService(){ if(conn !=null){ unbindService(conn); //断开连接，解除绑定 conn = null; updateServiceStatus(); } } private void invokeService(){ if(conn != null){ try{ //一旦client成功绑定到Service，就可以直接使用stub中的方法。 Integer counter =remoteService.getCounter(); TextView t = (TextView)findViewById(R.id.st4_notApplicable); t.setText(&quot;Counter value : &quot; + Integer.toString(counter)); }catch(RemoteException e){ Log.e(getClass().getSimpleName(),e.toString()); } } } //步骤3.2 class CounterServiceConnection实现ServiceConnection接口， //需要具体实现里面两个触发onServiceConnected()和onServiceDisconnected() private class CounterServiceConnection implements ServiceConnection{ @Override public void onServiceConnected(ComponentName name, IBinder service) { // 从连接中获得stub对象，根据我们的跟踪，remoteService就是service中的stub对象 remoteService = ITestRemoteService.Stub.asInterface(service); showInfo(&quot;onServiceConnected()&quot; + remoteService); } @Override public void onServiceDisconnected(ComponentName name) { remoteService = null; updateServiceStatus(); showInfo(&quot;onServiceDisconnected&quot;); } } private void updateServiceStatus() { TextView t = (TextView)findViewById( R.id.st4_serviceStatus); t.setText( &quot;Service status: &quot;+(conn == null ? &quot;unbound&quot; : &quot;bound&quot;)+ &quot;,&quot;+ (isStarted ? &quot;started&quot; : &quot;not started&quot;; )); } private void showInfo(String s){ System.out.println(&quot;[&quot; +getClass().getSimpleName()+&quot;@&quot; + Thread.currentThread().getName()+ &quot;] &quot; + s); } } 注意： Service.onBind如果返回null，则调用 bindService 会启动 Service，但不会连接上 Service，因此 ServiceConnection.onServiceConnected 不会被调用，但你任然需要使用 unbindService 函数断开它，这样 Service 才会停止。 其它： 1、在什么情况下使用 startService 或 bindService 或 同时使用startService 和 bindService 如果你只是想要启动一个后台服务长期进行某项任务那么使用 startService 便可以了。如果你想要与正在运行的 Service 取得联系，那么有两种方法，一种是使用 broadcast ，另外是使用 bindService ，前者的缺点是如果交流较为频繁，容易造成性能上的问题，并且 BroadcastReceiver 本身执行代码的时间是很短的（也许执行到一半，后面的代码便不会执行），而后者则没有这些问题，因此我们肯定选择使用 bindService（这个时候你便同时在使用 startService 和 bindService 了，这在 Activity 中更新 Service 的某些运行状态是相当有用的）。另外如果你的服务只是公开一个远程接口，供连接上的客服端（android 的 Service 是C/S架构）远程调用执行方法。这个时候你可以不让服务一开始就运行，而只用 bindService ，这样在第一次 bindService 的时候才会创建服务的实例运行它，这会节约很多系统资源，特别是如果你的服务是Remote Service，那么该效果会越明显（当然在 Service 创建的时候会花去一定时间，你应当注意到这点）。 2、在 AndroidManifest.xml 里 Service 元素的常见选项 android:name，服务类名 android:label，服务的名字，如果此项不设置，那么默认显示的服务名则为类名 android:icon，服务的图标 android:permission，申明此服务的权限，这意味着只有提供了该权限的应用才能控制或连接此服务 android:process，表示该服务是否运行在另外一个进程，如果设置了此项，那么将会在包名后面加上这段字符串表示另一进程的名字 android:enabled，如果此项设置为 true，那么 Service 将会默认被系统启动，不设置默认此项为 false android:exported，表示该服务是否能够被其他应用程序所控制或连接，不设置默认此项为 false 3、Service 与 Thread 的区别 很多时候，你可能会问，为什么要用 Service，而不用 Thread 呢，因为用 Thread 是很方便的，比起 Service 也方便多了，下面我详细的来解释一下。 1). Thread：Thread 是程序执行的最小单元，它是分配CPU的基本单位。可以用 Thread 来执行一些异步的操作。 2). Service：Service 是android的一种机制，当它运行的时候如果是Local Service，那么对应的 Service 是运行在主进程的 main 线程上的。如：onCreate，onStart 这些函数在被系统调用的时候都是在主进程的 main 线程上运行的。如果是Remote Service，那么对应的 Service 则是运行在独立进程的 main 线程上。因此请不要把 Service 理解成线程，它跟线程半毛钱的关系都没有！ 既然这样，那么我们为什么要用 Service 呢？其实这跟 android 的系统机制有关，我们先拿 Thread 来说。Thread 的运行是独立于 Activity 的，也就是说当一个 Activity 被 finish 之后，如果你没有主动停止 Thread 或者 Thread 里的 run 方法没有执行完毕的话，Thread 也会一直执行。因此这里会出现一个问题：当 Activity 被 finish 之后，你不再持有该 Thread 的引用。另一方面，你没有办法在不同的 Activity 中对同一 Thread 进行控制。 举个例子：如果你的 Thread 需要不停地隔一段时间就要连接服务器做某种同步的话，该 Thread 需要在 Activity 没有start的时候也在运行。这个时候当你 start 一个 Activity 就没有办法在该 Activity 里面控制之前创建的 Thread。因此你便需要创建并启动一个 Service ，在 Service 里面创建、运行并控制该 Thread，这样便解决了该问题（因为任何 Activity 都可以控制同一 Service，而系统也只会创建一个对应 Service 的实例）。 因此你可以把 Service 想象成一种消息服务，而你可以在任何有 Context 的地方调用 Context.startService、Context.stopService、Context.bindService，Context.unbindService，来控制它，你也可以在 Service 里注册 BroadcastReceiver，在其他地方通过发送 broadcast 来控制它，当然这些都是 Thread 做不到的。 4、拥有service的进程具有较高的优先级 官方文档告诉我们，Android系统会尽量保持拥有service的进程运行，只要在该service已经被启动(start)或者客户端连接(bindService)到它。当内存不足时，需要保持，拥有service的进程具有较高的优先级。 1). 如果service正在调用onCreate,onStartCommand或者onDestory方法，那么用于当前service的进程则变为前台进程以避免被killed。 2). 如果当前service已经被启动(start)，拥有它的进程则比那些用户可见的进程优先级低一些，但是比那些不可见的进程更重要，这就意味着service一般不会被killed. 3). 如果客户端已经连接到service (bindService),那么拥有Service的进程则拥有最高的优先级，可以认为service是可见的。 4). 如果service可以使用startForeground(int, Notification)方法来将service设置为前台状态，那么系统就认为是对用户可见的，并不会在内存不足时killed。 如果有其他的应用组件作为Service,Activity等运行在相同的进程中，那么将会增加该进程的重要性。 5、注意事项 Service的onCreate的方法只会被调用一次，就是你无论多少次的startService又 bindService，Service只被创建一次。如果先是bind了，那么start的时候就直接运行Service的onStart方法，如果先是start，那么bind的时候就直接运行onBind方法。如果你先bind上了，就stop不掉了，只能先UnbindService, 再StopService,所以是先start还是先bind行为是有区别的。 Android中的服务和windows中的服务是类似的东西，服务一般没有用户操作界面，它运行于系统中不容易被用户发觉，可以使用它开发如监控之类的 程序。 服务不能自己运行，需要通过调用Context.startService()或Context.bindService()方法启动服务。 这两个方法都可以启动Service，但是它们的使用场合有所不同。使用startService()方法启用服务，调用者与服务之间没有关连，即使调用者退出了，服务仍然运行。使用bindService()方法启用服务，调用者与服务绑定在了一起，调用者一旦退出，服务也就终止，大有“不求同 时生，必须同时死”的特点。 如果打算采用Context.startService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onStart()方法。如果调用startService()方法前服务已经被创建，多次调用startService()方法并不会导致多次 创建服务，但会导致多次调用onStart()方法。采用startService()方法启动的服务，只能调用Context.stopService()方法结 束服务，服务结束时会调用onDestroy()方法。 如果打算采用Context.bindService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onBind()方法。这个时候调用者和服务绑定在一起，调用者退出了，系统就会先调用服务的onUnbind()方法，接着调用onDestroy()方法。如果调用bindService()方法前服务已经被绑定，多次调用bindService()方法并不会导致多次创建服务及绑定(也就是说onCreate()和onBind()方法并不会被多次调用)。 如果调用者希望与正在绑定的服务解除绑定，可以调用unbindService()方法，调用该方法也会导致系统调用服务的 onUnbind()–&gt;onDestroy()方法. 原文地址：http://aswang.iteye.com/blog/1424309","categories":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/categories/android/"}],"tags":[{"name":"service","slug":"service","permalink":"http://b.nearby.ren/tags/service/"}]},{"title":"淘汰","slug":"淘汰","date":"2015-12-17T01:24:27.000Z","updated":"2017-07-18T08:22:25.344Z","comments":true,"path":"2015/12/17/淘汰/","link":"","permalink":"http://b.nearby.ren/2015/12/17/淘汰/","excerpt":"","text":"陈奕迅 - 淘汰曲 : 周杰伦 词：周杰伦 我说了 所有的谎你全都相信简单的 我爱你你却老不信你书里的剧情我不想上演因为我喜欢 喜剧收尾 我试过 完美放弃的确很踏实醒来了梦散了你我都走散了情歌歌词何必押韵就算我是K歌之王也不见得把 爱情唱得完美 只能说我输了也许是你怕了我们的回忆 没有皱褶你却用离开烫下句点只能说我认了你的不安赢得你信任我却得到你 安慰的淘汰 我试过完美放弃的确很踏实醒来了梦散了你我都走散了情歌歌词何必押韵就算我是K歌之王也不见得把 爱情唱得完美 只能说我输了也许是你怕了我们的回忆 没有皱褶你却用离开烫下句点只能说我认了你的不安赢得你信任我却得到你 安慰的淘汰 只能说我输了也许是你怕了我们的回忆 没有皱褶你却用离开烫下句点只能说我认了你的不安赢得你信任我却得到你 安慰的淘汰","categories":[{"name":"文字","slug":"文字","permalink":"http://b.nearby.ren/categories/文字/"}],"tags":[{"name":"歌曲","slug":"歌曲","permalink":"http://b.nearby.ren/tags/歌曲/"}]},{"title":"offce 001","slug":"offce001","date":"2015-12-14T04:12:55.000Z","updated":"2021-08-01T02:47:15.905Z","comments":true,"path":"2015/12/14/offce001/","link":"","permalink":"http://b.nearby.ren/2015/12/14/offce001/","excerpt":"","text":"View的绘制流程、Activity、Window、View的关系Activity启动时创建Window、ViewRoot并建立关联，流程如下：1234567891011121314151617181920212223class ActivityThread &#123; // startActivity最终会调用到这里 fun handleLaunchActivity()&#123; // 1. performLaunchActivity() 创建activity // 2. activity.attach() 内部创建了PhoneWindow // 3. activity.onCreate() -&gt; setContentView，实际调用window的对应方法，创建DecorView &#125; fun handleResumeActivity()&#123; // 1. activity.onResume() // 2. 获取activity的window对象，添加DecorView到WindowManagerGlobal中 // 3. WindowManagerGlobal.addView(DecorView)时，创建了ViewRootImpl，所有view绘制的工作都是 // ViewRootImpl来调度，在这里才建立了ViewRootImpl和View的关联 &#125;&#125;class ViewRoot &#123;// ViewRoot添加view后，会执行ViewRoot.requestLayout// scheduleTraversals -&gt; 在消息队列中插入一个同步消息屏障,保证UI优先绘制 // -&gt; 通过choreographer提交绘制任务，同时向底层请求sync信号，// -&gt; 在下一次信号到来时JNI回调doTraversal，并移除屏障消息// -&gt; doTraversal中调用了performMeasure、performLayout和performDraw进行测量、布局和绘制流程&#125; MeasureSpec是一个32位int值，高2位表示测量模式，后30位表示在该模式下的测量值，一个view的MeasureSpec由自己的LayoutParams和父View的MeasureSpec共同决定。测量过程实际是递归的测量子view后再设置自己的尺寸。 onCreate、onResume中能否获取到View的宽高，为什么？由于View的measure过程和Activity的生命周期方法不是同步执行的，如果View还没有测量完毕，那么获得的宽/高就是0。所以在onCreate、onStart、onResume中均无法正确得到某个View的宽高信息。解决方式如下： 1.view.post(runnable)，注意这里handler.post(runnable)是不行的，View.post会先判断attachInfo是否为空，如果为空就放到一个等待执行的队列中，等待View被添加（dispatchAttachedToWindow）之后才执行，这时测量已经完毕了，如果不为空，表示View已经被添加，就调用attachInfo中的Handler来post任务，所以是一定能获取到的。注意api23以下和以上的逻辑不一样： Api23以下：调用的ViewRootImpl.getRunQueue().post()，执行时机是doTraversa()中，这个方法又是在下一个同步信号来的时候调用的，参考屏幕刷新机制。 Api23以上：调用的是getRunQueue().post() ，它的执行时机是View被添加之后执行，如果View只是创建出来没有被添加，那将一直得不到执行。 2.使用ViewTreeObserver 卡顿原理、屏幕刷新机制、卡顿监控卡顿的根本原因：view在16ms内不能完成绘制造成掉帧，常见造成掉帧的原因又有：1.主线程有耗时操作（合理使用线程来执行耗时任务）2.View本身太复杂、嵌套过多导致绘制超过16ms（优化View的层级、合理使用include、ViewStub标签）3.内存抖动造成频繁GC，例如循环内部创建对象，onDraw中创建对象等。（优化内存泄漏、对一些需要频繁创建的对象采用对象池技术） 屏幕刷新机制：1.基于handler消息队列，如BlockCanary，handler分发消息前后都会打印日志，可以自定义Printer，计算Looper两次获取消息的时间差，如果时间太长就说明Handler处理时间过长，直接把堆栈信息打印出来，就可以定位到耗时代码2.代码插桩，在方法的前后插入计时代码来监控执行时间，缺点是包增大，无法监控系统方法，并且需要过滤简单方法3.循环插入空消息到消息队列，监控这个消息的处理时间，例如每隔1秒插入一条空消息，如果这条消息处理时间间隔大于一定时间，则认为发生了卡顿 RxJava的原理Rxjava每个操作符会生成一个新的Observable,同时持有上游事件源和下游Observer，最终在subscribeActual中实现自己的操作逻辑，并连接上下游。Rxjava有点像观察者模式和责任链模式的结合，普通的观察者模式一般是被观察者通知多个观察者，而Rxjava则是被观察者通知第一个Obsever,接下来Observer依次通知下一个节点的Observer，形成一个“观察链”，将观察者模式进行了一种类似链式的变换，每个节点又会执行它不同的“职责”。 1.SubscribeOn节点在订阅的时候，将它的上游节点的subscribe操作，以runnable的形式交给调度器在执行，在io调度器就是一个线程池，他影响的是事件源的发射行为，如果多次subscribeOn相当后一次subscribeOn把上一次subscribeOn行为在线程池里执行了一次，最终就只有最上边的一个起作用；2.observeOn会将它下游的Observer放到切换的线程中执行，因此observeOn影响的是它的下游，多次调用影响的是这次到下一次observeOn之间的代码； Rxjava中调度器Schedulers.io()：无边界线程池作为支撑的一个Scheduler，线程可以无限增长，它适用于非CPU密集的I/O工作，比如访问文件系统、执行网络调用、访问数据库等Schedulers.computation()：用于执行CPU密集的工作，比如处理大规模的数据集、图像处理等等。它由一个有界的线程池作为支撑，线程的最大数量就是可用的处理器数量Schedulers.newThread()：这个Scheduler 每次都会创建一个全新的线程来完成一组工作Schedulers.single()：只有一个线程作为支撑，只能按照有序的方式执行任务Schedulers.from(Executor executor)我们可以使用它创建自定义的SchedulerAndroidSchedulers.mainThread()：Android主线程调度器 事件分发机制事件传递的顺序：Activity-&gt;Window-&gt;DecorView dispatchTouchEvent中： 1.判断是否需要拦截事件的标记intercepted123456789101112131415// 如果是down事件或者mFirstTouchTarget不为空if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; // 判断disallowIntercept标记 // 如果允许拦截则调用onInterceptTouchEvent intercepted = onInterceptTouchEvent(ev); &#125; else &#123; // 有disallowIntercept标记，不拦截 intercepted = false; &#125;&#125; else &#123; // 已有mFirstTouchTarget或者不是down时间，直接拦截 intercepted = true;&#125; 2.尝试分发事件：如果第一步不需要拦截，并且不是cancel状态，分发给子view 12345if (!canceled &amp;&amp; !intercepted) &#123; // 遍历子view，判断坐标是否在view范围内并且view没有处于动画状态 // 满足条件则交给子view的dispatchTouchEvent来处理 // 如果子view处理了事件，则把子view赋值给mFirstTouchTarget&#125; 3.再次分发事件：判断firstTouchTarget是否为空，如果为空表示没有子view处理事件，则间接的交给自己的onTouchEvent来处理，为空则直接交给firstTouchTarget处理12345if (mFirstTouchTarget == null) &#123; // 没有子view处理事件，交给自己的onTouchEvent处理&#125; else &#123; // 直接交给mFirstTouchTarget处理后续事件&#125; 4.onTouchListener ：如果有onTouchListener则优先交给onTouchListener处理，onTouchListener返回true则onTouchEvent将不会调用5.cancel事件：父视图先不拦截，然后在 MOVE 事件中重新拦截，此时子 View 会接收到一个 CANCEL 事件，例如move出子view范围，或者scrollView中事件首先传递给子view，如果滑动则会被拦截。 LeakCanary原理首先java的四种引用，强、软、弱、虚四种引用，配合ReferenceQueue使用，在构造弱引用时传入ReferenceQueue，在垃圾回收之前，会将引用放入队列中，可以通过队列中是否有对象的引用来判断对象是否被回收； 具体就是在Application中注册ActivityLifecycleCallbacks监听activity的生命周期，在onDestory的时候，新建一个弱引用传入队列，在线程空闲的时候，会尝试清除队列的弱引用，如果成功则没有发生泄漏，如果失败，则尝试GC，GC之后再次尝试清除弱引用，如果失败则发生了内存泄漏 Fragment也类似，在Activity创建时获取到FragmentManager注册一个fragmentLifecycleCallbacks，然后观察fragment； Retrofit原理核心原理：在createService时，创建一个Api接口的动态代理，在loadServiceMethod方法先查找缓存，没有找到则解析Api接口，解析包括两部分，一个是方法上的注解，包括url、Header、请求参数等，第二个是方法的返回类型和参数类型，也就是CallAdapter和ConverAdapter CallAdapter用于把结果适配成Rxjava、kotlin协程等返回类型 ConverAdapter用于把参数转化为json或者其他格式传输。 loadServiceMethod完毕后，实际上是把请求组装成一个OkHttpCall，用okhttp来进行具体的请求。 OkHttp原理优点：连接池技术复用连接，可以降低延迟，无缝支持gzip减少数据量，支持http2以及SPDY多路复用技术 责任链设计模式：用来处理相关事务责任的一条执行链，执行链上有多个节点，每个节点都有机会（条件匹配）处理请求事务，如果某个节点处理完了就可以根据实际业务需求传递给下一个节点继续处理或者返回处理完毕 请求流程：1.构建request2.通过dispatcher执行请求，dispatcher内部包含三个队列：同步请求队列、异步等待队列和异步执行队列，对于同步请求，直接添加到同步请求队列执行，异步请求则添加到等待队列中，然后判断请求数是否大于最大请求数、以及同一个主机的最大请求数，如果可以执行，则提升到执行队列进行执行3.无论是同步请求还是异步请求，最终都调用到getResponseWithInterceptorChain方法，核心就是拦截器链，包含了7大拦截器，分别负责不同的功能，每一个拦截器都可以自己处理请求，然后直接返回或者交给下一节点来处理。 自定义拦截器 RetryAndFollowUpInterceptor：重试和重定向拦截器 BridgeInterceptor：用来设置一些必要的header CacheInterceptor：处理缓存 ConnectInterceptor：负责建立服务器连接，优先从连接池中找到可用连接(soket连接是否可用，是否超时等，如不可用则会从连接池中移除)，否则打开一个新的连接 自定义网络拦截器 CallServerInterceptor：最后一个拦截器，用于真正发送网络请求，返回response 为什么要组件化，怎么实现？了解的路由框架痛点：在业务开发中，各个业务模块依赖关系复杂，耦合严重，造成app编译缓慢、不能并行开发、组件复用性不高的问题。通过组件化改造，可以对各个模块进行了业务隔离，使模块可以单独编译运行，降低耦合度，提高了开发和调试效率。 组件拆分：应用入口：一个空壳app，提供应用的启动页面 支撑业务组件：网络请求、图片加载等一些支撑服务 通用业务模块：例如支付、推送、地图等sdk，封装后对外提供调用接口 应用业务组件：具体的业务，可以提出来作为一个单独应用的功能模块，两两之间不互相依赖 模块间的通信，需要引入路由框架，主流路由框架大概分为两种ARouter：路由表+接口下沉的方式，在编译期间通过注解处理器扫描目标类，然后解析参数生成路由表，模块服务通过接口下沉的方式，把接口定义在公共库中，具体实现类在业务模块中，在编译时通过扫描字节码发现实现类，然后通过ASM等字节码修改技术完成服务的注册； CC：组件总线的方式，类似于EventBus发送消息一样，直接找到目标组件，发送一条指令执行对应操作，通过gradle的Transform API:在编译时(dex/proguard之前)扫描当前要打包到apk中的所有类 ，然后通过ASM技术修改字节码，生成代码完成组件的注册； android优化的数据结构：SparseArray、ArrayMapSparseArray的key只能为int，双列数组结构，优化了自动装箱的过程，并且会自动排序，查找采用二分查找，在数据量不大的情况下效率高 ArrayMap和SparseArray类似，但是key可以是对象，存储的时候存储通过key的hash值排序，也采用二分查找； 进程间通信的方式1.广播 2.Messenger，封装的Binder，可以执行简单的串行通信。 3.ContentProvider，适用于进程间的数据共享，可以进行操作权限的控制，如数据库的读写等。 4.Socket，适用于网络通信，用于传输原始的字节流，两次拷贝、效率低于binder 5.Binder，适用于复杂的进程通信，功能强大，CS架构，底层基于内存映射，只进行一次拷贝，所以效率高，可以验证通信的进程id，所以比socket更安全。 AIDL和Binder机制AIDL实际上是一套快速实现Binder通信的工具，通过定义AIDL接口，系统会自动生成一个类实现IInterface接口，内部包含Stub和Proxy两个内部类。服务端继承Stub提供服务。 关键类和方法Stub：服务端通过继承Stub，实现定义的接口来提供服务 Proxy：服务端对象的本地代理，客户端通过它来间接调用服务端接口的方法 asInterface：客户端调用，将binder对象转化为AIDL接口类型对象，如果和服务端在同一进程，返回Stub对象本身，否则返回Stub.proxy代理对象 asBinder：返回binder对象 onTransact：运行在服务端binder线程池，客户端请求时，远程请求会被系统封装后交给此方法处理 transact：运行在客户端，客户端发起请求时线程挂起，调用到服务端onTransact，等待其返回后才继续执行 Binder机制基于C/S架构，包括Server、Client、ServiceManager和Binder驱动，其中Binder驱动运行在内核空间，其他的运行在用户空间 ServiceManager负责服务管理，服务端向ServiceManager注册后，客户端可以向ServiceManager查询获取到目标服务的引用 Binder驱动：负责进程之间的Binder通信的建立，基于内存映射技术，传统的通信方式需要将数据从用户空间拷贝到内核空间，然后从内核空间拷贝到目标进程的用户空间，需要两次拷贝，Binder驱动可以建立用户空间内存和内核空间内存的一个映射， 只需要一次拷贝，非常高效。 kotlin的扩展方法是怎么实现的，inline关键字的作用扩展方法编译成java后，实际上是一个 public static的静态方法，传入了对象实例和参数Inline关键字修饰的函数是内联函数，用于优化函数调用的压栈操作，相当于在编译期间把内联函数的代码拷贝到函数调用处，可以提升性能，但是增加了代码量 Handler机制关键类：Handler：用于发送消息和处理消息，发送消息就是将消息对象放入当前线程的MessageQueue中，然后Looper轮询到消息后交给自己处理，构造时需要传入Looper或者自动获取当前线程的Looper Looper：轮询器，一个线程只能有一个Looper，用于从消息队列中轮询消息，然后交给对应的Handler处理 MessageQueue：消息队列，是一个阻塞队列，当没有消息是线程会被阻塞，等待有消息时唤醒线程 Message：消息对象，采用了对象池技术，可以避免对象的频繁创建开销 消息的发送和轮询发送消息：最终都会调用MessageQueue的enqueueMessage中，如果队列中没有消息或者消息的发送时间小于第一个消息，则直接放入队列头部，否则则根据时间插入到队列中的合适位置，同时会刷新needWeak标记，然后判断needWeak，如果需要唤醒，调用naviteWeak唤醒Looper。 获取消息：核心方法为MessageQueue的next，首先调用nativePollOnce，这个方法是一个native阻塞方法（通过监控文件描述符的io操作来实现），新消息放入队列时，会调用naviteWeak来唤醒。唤醒之后，如果是消息屏障就先处理异步消息，否则判断消息执行时间是否到达来返回消息或者进入下一个循环继续阻塞。 IdleHandler：在消息队列空闲的时候，会尝试执行IdleHandler的任务 消息屏障机制：当messageQueue取出屏障消息时，会开启循环，找到下一个异步消息执行，相当于阻塞了同步消息而优先执行异步消息，Android中所有UI绘制都是异步消息，可以保证UI绘制任务优先执行。 postDelay怎么保证消息的顺序发送消息时会对消息队列按执行时间进行排序，如果没有消息或者当前消息执行时间小于队列的第一条消息，则直接插入到表头，否则会插入到合适的位置，保证delay时间长的不会阻塞住时间短的。 Activity启动流程1.Luancher 进程通过binder向AMS发起startActivity请求2.AMS收到请求， ActivityStarter解析flag，启动模式等，ActivityStack处理activity栈3.然后AMS通过socket调用到Zygote，fork新的app进程4.app进程创建后，再通过binder向AMS发起attachApplication请求5.AMS通过binder调用发送scheduleLaunchActivity到app进程6.APP进程的binder线程ApplicationThread接收到请求，通过handler发送LAUNCH_ACTIVITY消息到主线程7.ActivityThread接收到消息，执行到handleLaunchActivity，开始Activity的生命周期应用第一次启动时，zygote进程fork出应用进程后，AMS会保存一个ProcessRecord信息（包名+进程uid），下一次启动判断这个ProcessRecord已经存在的话，就不会再新建进程，这就属于应用内打开Activity的过程了 APK打包流程 1.打包资源文件，生成R.java文件2.处理aidl文件，生成相应的Java文件3.编译项目源代码，生成class文件（所有的Java代码，包括R.java和.aidl文件）4.转换所有的class文件，生成classes.dex文件5.打包生成APK文件6.对APK文件进行签名7.对签名后的APK文件进行对齐处理。对齐的主要过程是将APK包中所有的资源文件距离文件起始偏移为4字节整数倍，这样通过内存映射访问apk文件时的速度会更快。对齐的作用就是减少运行时内存的使用 APK安装流程：1.拷贝阶段：通过PMS通过handler发送一个安装消息，包含一些安装的参数，PackageHandler收到消息后通过隐式intent绑定到拷贝的service。检查apk安装路径，包的状态，然后拷贝至/data/app包名下2.装载阶段：installPackageLI，PackageParser解析AndroidManifest文件，解析四大组件等信息3.验证apk的签名信息4.执行 dex 优化，实际为 dex2oat 操作，用来将 apk 中的 dex 文件转换为 oat 文件5.安装apk，创建data目录，安装成功则更新权限等信息6.发送成功广播，安装失败则删除安装包和缓存 Android系统启动流程1.开机加载BootLoader，加载Linux内核2.启动Init进程3.读取init.rc配置文件，启动几个关键进程，包括Zygote、ServiceManager、SurfaceFlinger和MediaServer4.zygote进程启动java runntime，然后fork出sytem_server进程5.sytem_server启动AMS、WMS、电源管理、等等系统服务，并通过Binder注册到ServiceManager。6.启动Launcher显示桌面 Webview的漏洞1.4.2版本的addJavascriptInterface 造成的远程代码执行漏洞，当JS拿到Android这个对象后，就可以调用Android对象中所有的方法，包括系统类（java.lang.Runtime 类），从而执行任意代码 4.2版本以上通过对调用的方法添加JavascriptInterface注解避免漏洞 4.2以下采用url拦截或者js弹窗拦截的方式进行交互，不能采用对象映射 2.密码明文存储3.域控制不严问题，允许导出的WebActivity未关闭file协议，可以外部启动并加载恶意file协议的文件，从而访问私有文件，所以不需要使用file协议的，需要关闭 Dalvik与ART的区别1.Dalvik：即时编译，应用每次运行都需要通过即时编译器（JIT）将字节码转换为机器码，所以运行效率相对ART较低。由于不需要预编译，所以安装过程较快2.ART ：应用在第一次安装的时候，字节码就会预编译（AOT）成机器码，这样的话，虽然设备和应用的首次启动（安装慢了）会变慢，但是以后每次启动执行的时候，都可以直接运行，因此运行效率会提高3.ART占用空间比Dalvik大（字节码变为机器码之后，可能会增加10%-20%）4.预编译也可以明显改善电池续航，从而减少了 CPU 的使用频率，降低了能耗。 热修复和插件化原理java类加载机制 双亲委托机制：如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载 Java的类加载器分为：根加载器（加载java核心类）、扩展类加载器（加载jre扩展目录）、应用类加载器（加载classPath指定目录的类，自定义类加载器一般继承此加载器） Android的类加载器：根加载器、BaseDexClassLoader、PathClassLoader（加载安装到系统的APK）、DexClassLoader（加载指定目录的dex和apk） 热修复和插件化的区别热修复：替换bug的类，需要把修复类抢先于bug类进行加载，让bug类得不到加载。通过反射修改DexClassLoader中DexPathList的dexElements数组，将需要加载的dex添加到数组前面。 插件化：运行未安装的插件apk的代码，不涉及到抢先加载，只需要将dex加载到dexElements中 热修复的CLASS_ISPREVERIFIED问题热修复是需要修复有bug的类，所以需要把dex放在数组的前端抢先加载补丁类，在虚拟机启动的时候，在verify选项被打开的时候，如果static方法、private方法、构造函数等，其中直接引用到的类都在同一个dex文件中，那么该类就会被打上CLASS_ISPREVERIFIED标志，且一旦类被打上CLASS_ISPREVERIFIED标志其他dex就不能再去替换这个类。​ 为了阻止类被打上CLASS_ISPREVERIFIED标志，先将一个预备好的hack.dex加入到dexElements的第一项，让后面的dex的所有类都引用hack.dex其中的一个类。 常见热修复框架Tinker实际上是类加载方案的升级，它增加了dex的差分算法，再将差分dex与apk中的classex.dex做合并，在运行bug类之前抢先加载补丁。 tinker差分算法：dexDiff , 新旧dex先排序，然后定义两个指针依次往下挪，如果old&gt;new，则一定是新增，如果old&lt;\\new，则是删除，如果相等，则索引可能不同，需要记录索引的变化，最后如果相同的索引既有删除又有新增，则优化为replace操作。资源差分则采用BSDiff。 美团Robust，Instant Run方案，用代码插桩的方式，在每个方法中插入一段开关代码，如果需要修复，则走入if判断，执行补丁中的同名类的同名方法 插件化方案插件化主要是加载新的功能模块，最主要的功能除了加载类，还需要加载资源和生命周期的管理。 资源加载：通过反射AssetManager ，将资源所在路径添加到AssetManager的path中，然后创建一个Resource，hook住activity替换mResources实现资源的访问。具体分为两种： 1.合并式：插件资源合并到主工程，插件和主工程可以直接访问资源，合并资源会造成资源id冲突，所以需要修改aapt源码，id格式为0xPPTTNNNN，在编译期修改高两位PP段，不同插件使用不同的PP段标识。修改resources.arsc文件，该文件列出了资源id到具体资源路径的映射，相当于一个索引。 2.独立式：插件只访问插件内部的资源，不能共享，也不会冲突。 生命周期的管理：没有在清单文件中注册过的Activity不能启动，现在的主流做法是预留各种启动模式的代理Activity占坑，然后通过hook住mInstrumentation对象，在启动插件Activity时替换intent为代理的Activity，从而绕过AMS的验证，系统以为是启动的代理Activity，然后真正启动时，需要还原原先的Intent，启动插件Activity，同时hook替换mResources，这样就实现了生命周期管理 #VirtualApk原理如何加载插件类：（类加载机制）插件创建ClassLoader，父类加载器是宿主的classloader，这样插件可以反射访问到宿主的类。 然后判断COMBINE_CLASSLOADER标记，如果COMBINE_CLASSLOADER为true，则会把dex插入到父类加载器的elements后边，使宿主可以访问插件的类。如果为false表示宿主与插件隔离，宿主不能访问插件。不论true或false，插件都可以访问宿主。 DroidPlugin是采用隔离模式，插件的classloader的父类加载器是BootClassLoader，所以相互都不能访问。 如何加载资源：1.COMBINE_CLASSLOADER为true：把插件资源添加到宿主Resources的AssetsManager的资源路径中去。编译时过滤宿主和插件中的重复资源，然后修改R和资源表文件，让插件中只保留新的资源。存在的问题： 2.宿主和插件开发可能是并行的，过滤资源时候如果依赖的是1.0的宿主，在1.1中资源发生了变化，插件就会找不到资源，滴滴是让public.xml让宿主资源id不可变来实现。如果宿主和插件有相同名字的资源，例如都有一个about字符串，由于资源过滤，插件的会被过滤掉。 activity的启动：hook系统instrumentation，判断如果启动的是插件的类，则通过预埋的activity绕过ams对activity的验证，然后在真正启动activity的时候，还原intent来启动目标类，这样目标类就有正常的生命周期了 service的启动：hook系统ActivityManager，创建一个动态代理来替换系统中的单例对象，实际上启动LocalService来代理目标服务的生命周期。 广播：解析清单文件，把注册的静态广播转换为动态广播。 启动activity时的问题 在创建插件的ClassLoader时，有一个COMBINE_CLASSLOADER标记用来设置是否要讲插件的dex插入到宿主的dex数组中，让宿主可以访问插件的类。COMBINE_CLASSLOADER标记为false时，宿主不能访问到插件类源码instrumentation中handleMessage处理启动activity时，给intent的extras设置了宿主的类加载器，如果extra中有一个插件中才有的序列化对象，读取extra时反序列化会出错，就会抛出找不到类异常。到现在版本仍未解决。解决方案：直接用一个新的intent包装原始的intent来替换，intent是parcelable的。 RecyclerView缓存1.mAttachedScrap和mChangedScrap，用于缓存屏幕内的ViewHolder，例如下拉刷新后，屏幕内的ViewHolder需要刷新数据2.mCachedViews，移除屏幕之外的，默认缓存两个，因为接下来可能马上往回滑动，再次使用到3.ViewCacheExtension，预留的一个缓存扩展，暂时没有用到4.RecycledViewPool，缓存屏幕外的 ViewHolder，需要重新绑定数据 RecyclerView 缓存结构，RecyclerView预取，RecyclerView局部刷新 Scrap：对应ListView 的Active View，就是屏幕内的缓存数据，就是相当于换了个名字，可以直接拿来复用 Cache ： 刚刚移出屏幕的缓存数据 ViewCacheExtension：是google留给开发者自己来自定义缓存的 RecycledViewPool：回收池，最重要答：四级缓存，有一个自定义的不用 局部刷新：notifyPositon或者nofiyview实现，可以执行动画 AsyncTask原理和缺陷实际是通过Handler+线程池实现，内部含有两个线程池，一个用于排队，一个用于真正执行任务 缺陷：执行任务的线程池是个静态的全局线程池，最大线程数为128，如果任务队列满了，然后最大线程数也满了，再提交任务会出现崩溃；解决方案为自定义线程池必须主线程初始化，内部handler获取主线程looper，否则不能正确切换到主线程。结果丢失问题：如果activity重建，例如切横竖屏，因为持有的引用是重建之前的，新的Activity无法接收到结果。内存泄漏，退出页面需要正确取消 性能优化相关卡顿优化 1.View本身绘制时间过长超过16ms造成掉帧，所以需要减少View嵌套层级，使用ViewStub和merge标签，优化过度绘制等 2.主线程执行耗时任务，合理使用线程，将耗时任务放到后台进行 3.内存抖动，会频繁触发GC，造成卡顿。使用内存分析工具优化内存使用，减少不必要对象的创建 耗电优化合理使用后台服务，合并网络请求，使用protobuf替换json进行服务端请求，cpu休眠锁等 内存优化内存泄露优化（包括常见的内存泄漏、分析方法、LeakCanrary等）、使用优化的数据结构（ArrayMap和SparseArray），对频繁创建的对象使用对象池技术，减少不必要的内存开销， 启动优化Application的attachBaseContext和onCreate，三方sdk采用线程池异步初始化，activity的onCreate中，设置布局的优化（xml的io操作、反射创建view的操作，通过异步inflater和自定义inflater.factory来优化） 1.延迟初始化非必要的库，拓展到异步启动器的设计和实现，有向无环图来解决库依赖的问题。2.给闪屏页设置图片背景避免冷启动白屏，其实不能加快启动，只是避免白屏给用户的体验不佳 apk大小优化1，开启混淆压缩代码2，压缩和混淆资源，图片压缩采用webP格式，整理Raw、assets资源3，减少非必要so库，目前主流的机型都是支持armeabi-v7a的，并且armeabi-v7a兼容armeabi4，移除未使用的资源，如图标，字符串，字体等5，一些小图像可以使用矢量图，大矢量图渲染时间很长，不适用6，减少三方库使用，避免枚举的使用7，动态下发一些资源，如换肤包，so，字体等 网络优化1.HttpDNS优化，传统DNS解析一般是用UDP的方式与DNS服务器交互，HttpDNS采用Http协议交互，绕过运营商的 LocalDNS 服务器，有效的防止了域名劫持，提高域名解析的效率2.使用缓存，需要服务端支持，或者通过OkHttp拦截器添加统一的缓存策略3.HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。在HTTP1.1中默认开启keep-alive4.数据压缩，gzip压缩，http2.0也支持header的压缩5.根据网络质量来下载不同质量的图片 View inflate流程1.先从resource中获取一个xml parser用于加载布局2.读取layout文件，调用createViewFromTag创建View3.tryCreateView中，依次判断有没有设置Factory2和Factory，如果有则调用它的createView来创建view4.如果没有factory则调用自己的createView来创建，内部是使用反射创建对象5.注意，Factory2继承Factory增加了一个创建view的方法，相当于是一个扩展，它们可以对view创建的过程进行拦截，在创建view的时候做一些事情，例如换肤功能就用到这里。 换肤的原理1.制作皮肤包apk，只包含颜色、图片等，通过网络下载到sd卡；2.通过反射构造皮肤包的AssetManager，再用此AssetManager创建Resource。3.原apk和资源包中资源名称一样，提供一个资源映射的方法，通过原来的资源id找到资源名称，然后在皮肤包中查找皮肤资源具体的值；4.通过自定义LayoutInflater传入自定义的Factory2拦截view的创建过程，查找到需要换肤的view和对应的可替换属性名(background、color、textcolor等)、属性值的类型（color\\drawable\\mipmap…）、属性值在原apk中的资源名(如color1)和资源的id，保存起来；5.点击换肤时，遍历需要换肤的view集合，调用对应的方法（setColor等等）设置新的值。 Android的startActivityForResult的实现为什么不使用回调。因为匿名内部类会持有外部类的引用，使用回调时，例如A启动B去获取result，由于某些原因原A已经被销毁了，当B设置结果返回A时，实际上A已经被系统重建，和原先的A不是同一个对象了，所以就不能正确的获取结果。 如何跨app启动activity？1.shareUserId，设置同一个shareUserId的应用可以直接启动。2.Exported 设置为true，向外部暴露activity，允许外部启动。注意：为了安全需要添加自定义权限控制，注意被暴露的有权限的app需要先被安装，否则会获取不到权限。会导致拒绝服务漏洞，例如：A启动B中的activity，往intent中添加一个序列化对象，这个对象只在A中有，B中没有这个类，如果在B中访问intent的extra，就会触发反序列化对象，由于找不到这个对象的类，造成B崩溃。处理方法：获取extra要捕获异常。3.隐式启动activity，只要intentFilter匹配成功就可以启动。 高性能日志采集传统直接读写文件的方式的缺点读写文件的IO操作，需要两次拷贝，用户空间到内核空间，内核空间再到硬盘。为了避免频繁IO，采用缓存日志到内存，达到一定量时再统一写入文件，虽然避免了频繁IO，但是可能造成crash时日志丢失。多进程也无法保证写入顺序 mmap方案：mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。mmap操作提供了一种机制，让用户程序直接访问设备内存，这种机制，相比较在用户空间和内核空间互相拷贝数据，效率更高。 mmap的回写时机：1.内存不足2.进程退出3.调用 msync 或者 munmap4.不设置 MAP_NOSYNC 情况下 30s-60s(仅限FreeBSD) 多进程写入映射同一个内存也会造成写入顺序无法保证，所以可以选择多进程映射不同的文件，每隔一段时间合并一次来解决 性能优化工具：查看方法执行时间： TraceView（影响性能）1.用Debug.startMethodTrace来打点，生成trace文件，然后用adb导出分析2.使用profiler工具，选择cpu，输出trace文件 Systrace（轻量级）1.TraceCompat.beginSection2.使用python命令导出html，查看wall time和 cpu time MAT分析内存泄露：profiler分析内存，手动触发gc，然后输出堆转储hporf文件，然后用mat分析引用链 内存抖动：使用profiler工具排查 你们项目的稳定性如何？有做过什么稳定性优化的工作？答： 我们主要优化了三项：Crash专项优化性能稳定性优化业务稳定性优化性能：全面的性能优化：启动速度、内存优化、绘制优化线下发现问题、优化为主线上监控为主Crash专项优化我们针对启动速度，内存、布局加载、卡顿、瘦身、流量、电量等多个方面做了多维的优化。 我们的优化主要分为了两个层次，即线上和线下，针对于线下呢，我们侧重于发现问题，直接解决，将问题尽可能在上线之前解决为目的。而真正到了线上呢，我们最主要的目的就是为了监控，对于各个性能纬度的监控呢，可以让我们尽可能早地获取到异常情况的报警。 同时呢，对于线上最严重的性能问题性问题：Crash，我们做了专项的优化，不仅优化了Crash的具体指标，而且也尽可能地获取了Crash发生时的详细信息，结合后端的聚合、报警等功能，便于我们快速地定位问题。 PathClassLoader与DexClassLoader有什么区别答： PathClassLoader 和 DexClassLoader 类加载器都是继承自 BaseDexClassLoadeDexClassLoader 和 PathClassLoader 构造函数DexClassLoader 和 PathClassLoader 的差异在于构造 ClassLoader 对象时，是否给父类 (BaseDexClassLoader) 传递 optimizedDirectory 参数 跨进程通信了解多少？管道了解吗？ 答：四大组件可以跨进程主要是binder机制。Android都是，平时用AIDL管道：2次拷贝？？？？？？？缓冲区有大小限制。管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。在创建时分配一个page大小的内存，缓存区大小比较有限。","categories":[{"name":"offce","slug":"offce","permalink":"http://b.nearby.ren/categories/offce/"}],"tags":[{"name":"offce","slug":"offce","permalink":"http://b.nearby.ren/tags/offce/"}]},{"title":"offce 002","slug":"offce002","date":"2015-12-13T04:10:55.000Z","updated":"2021-08-01T02:43:29.838Z","comments":true,"path":"2015/12/13/offce002/","link":"","permalink":"http://b.nearby.ren/2015/12/13/offce002/","excerpt":"","text":"垃圾回收算法标记算法：1.引用计数法2.可达性分析法(注意GC root的类型，虚拟机栈和本地方法栈引用的对象、静态对象、字节码对象) 回收算法（复制算法、标记清除、标记整理）新生代：对象存活率低，采用复制算法，堆中分为3个区域，Eden、from、to，每次分配对象都在Eden，第一次gc时，把存活对象复制到from，第二次gc把Eden和from的对象复制到to，第三次又把Eden和to的对象复制到from，依次往复。达到一定阈值时，把对象移入老年代。 老年代：对象存活率高，标记整理法 java类加载机制 双亲委托机制：如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完 成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载 Java的类加载器：根加载器（加载java核心类）、扩展类加载器（加载jre扩展目录）、应用类加载器（加载classPath指定目录的类，自定义类加载器一般继承此加载器） Android的类加载器：根加载器、BaseDexClassLoader、PathClassLoader（加载安装到系统的APK）、DexClassLoader（加载指定目录的dex和apk） java匿名内部类匿名内部类就是没有名字的内部类，（其实是有名字的，虚拟机定位这个类，编译之后会使用 外部类名$1这样的名字，数字按顺序生成）。匿名内部类的构造方法由编译器生成，参数列表包括： 外部类的引用（定义在非静态域） 捕获的外部变量（方法体中使用的外部final对象） 父类的构造参数 如果父类也是一个非静态内部类则还有父类的外部类引用。 注意： 不能继承父类或者实现接口（kotlin中是可以的） 不能定义静态变量和方法 会持有外部类的引用，可能会造成内存泄露。 拓展：lambda表达式可以替代部分匿名内部类，父类必须是接口，且只有一个方法。 java泛型擦除使用泛型可以声明集合存储的元素类型，取出元素时避免强转的操作。在java中，编译完成后泛型参数会被擦除，例如List和List编译完成后都是List类型。 java泛型为什么会被擦除： 运行时内存压力小，不同泛型的List都编译成同一个类型。泛型不擦除的语言如c#，在方法区就会真实存在各种不同的List类型，压力就会相对较大。 兼容性的问题，1.5之前是没有泛型的，java当时的用户量很大，为了向下兼容。 存在的问题：1.基本类型无法用于泛型，只能用装箱类型，例如List，装箱操作有额外的开销。2.泛型参数不能用于方法重载，因为编译完成后泛型被擦除，参数都是一样的。3.泛型类型不能当做真实的类型来使用，例如方法参数中有一个泛型T，方法中不能直接new T（），因为编译之后就是Object，不知道真实的类型。4.静态方法无法引用类的泛型，因为类的泛型在实例化的时候才知道。5.类型强转的额外开销。 泛型在特定场景可以通过反射获取，例如父类有一个泛型参数已经被确定，子类继承之后可以获取。例如gson中，解析带泛型的List，要传入一个TypeToken，实际上是new了一个子类，通过反射获取泛型类型。 如何写出线程安全的程序？线程安全的本质，可变资源在线程间共享的问题。关键：可变资源、线程共享。 线程安全三要素：原子性、可见性、有序性 所以要保证线程安全： 1.共享不可变资源，final关键字的使用。2.使用纯函数（不访问外部资源），使用ThreadLocal，不共享资源。3.使用volatile关键字保证共享资源的可见性，并禁止指令重排序。4.操作原子性（加锁保证操作的互斥性，原子类AtomicXXX的使用，CAS指令如Unsafe.compareAndSwap） Synchronized原理底层通过一个监视器monitor实现，monitor对象包含一个count计数字段和owner字段指向获取锁的线程，当线程获取monitor后，count+1，owner指向线程，监视器处于锁定状态，其他线程不能获取monitor会进入阻塞状态，当前线程释放monitor后，其他线程可以继续竞争该锁。 Java1.6之后对Synchronized进行了一些优化： 锁自旋：线程的阻塞和唤醒需要 CPU 从用户态转为核心态，例如在Synchronized代码块中调用wait方法阻塞线程，wait会释放锁，所谓自旋，就是让该线程执行一段无意义的循环指令来等待一段时间，不会被立即挂起，看当前持有锁的线程是否会很快释放锁。缺点是需要占用 CPU，锁竞争的时间比较长时不实用） 偏斜锁：如果一个线程获得了一个偏向锁，如果在接下来的一段时间中没有其他线程来竞争锁，那么持有偏向锁的线程再次进入或者退出同一个同步代码块，不需要再次进行抢占锁和释放锁的操作，一旦出现锁竞争，偏向锁会被撤销，并膨胀成轻量级锁 轻量级锁：对于一块同步代码，虽然有多个不同线程会去执行，但是这些线程是在不同的时间段交替请求这把锁对象，也就是不存在锁竞争的情况。在这种情况下，锁会保持在轻量级锁的状态，从而避免重量级锁的阻塞和唤醒操作 Synchronized可以修饰静态方法（锁对象为字节码对象）、实例方法（锁为实例对象）和代码块，无论是否发生异常虚拟机都会正常释放锁ReentrantLock发生异常时不能释放锁，所以一般需要在finaly代码块中释放锁，它包含公平锁和读写锁等用法，使用更灵活 java虚拟机内存模型 虚拟机栈：线程私有，随线程创建而创建。栈里面是一个一个“栈帧”，每个栈帧对应一次方法调用。栈帧中存放了局部变量表（基本数据类型变量和对象引用）、操作数栈、方法出口等信息。当栈调用深度大于JVM所允许的范围，会抛出StackOverflowError的错误。 本地方法栈：线程私有，这部分主要与虚拟机用到的Native方法相关，一般情况下并不需要关心这部分内容。 程序计数器：也叫PC寄存器，JVM支持多个线程同时运行，每个线程都有自己的程序计数器。倘若当前执行的是 JVM 的方法，则该寄存器中保存当前执行指令的地址；倘若执行的是native方法，则PC寄存器中为空。（PS：线程执行过程中并不都是一口气执行完，有可能在一个CPU时钟周期内没有执行完，由于时间片用完了，所以不得不暂停执行，当下一次获得CPU资源时，通过程序计数器就知道该从什么地方开始执行） 方法区：方法区存放类的信息（包括类的字节码，类的结构）、常量、静态变量等。字符串常量池就是在方法区中。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的是与Java堆区分开来。很多人都更愿意把方法区称为“永久代”（Permanent Generation）。从jdk1.7已经开始准备“去永久代”的规划，jdk1.7的HotSpot中，已经把原本放在方法区中的静态变量、字符串常量池等移到堆内存中。 堆：堆中存放的是数组（PS：数组也是对象）和对象。当申请不到空间时会抛出OutOfMemoryError。 class加载过程1.装载，将class文件加载进内存，在堆中生成class对象2.链接，验证二进制数据流（类结构是否正确），分配静态变量设置默认值（初始化时才真正赋值），将符号引用转换为直接引用3.初始化，初始化静态变量，静态代码块 java内存模型、volatile的作用内存模型 本地内存：存放的是 私有变量 和 主内存数据的副本。如果私有变量是基本数据类型，则直接存放在本地内存，如果是引用类型变量，存放的是引用，实际的数据存放在主内存。本地内存是不共享的，只有属于它的线程可以访问。 主内存：存放的是共享的数据，所有线程都可以访问。当然它也有不少其他称呼，比如 堆内存，共享内存等等。 Java内存模型规定了所有对共享变量的读写操作都必须在本地内存中进行，需要先从主内存中拿到数据，复制到本地内存，然后在本地内存中对数据进行修改，再刷新回主内存，这就导致了多线程情况下数据的可见性问题，可以使用volatile关键字来修饰 volatile变量在修改后，会立即刷新主内存的值，对所有线程可见，当volatile变量写后，线程中本地内存中共享变量就会置为失效的状态，因此线程需要从主内存中去读取该变量的最新值。 volatile还可以防止指令重排序造成的线程安全问题，例如双重校验的懒汉式单例中，不加volatile的对象编译后的指令有可能重排序成：对象引用已经被赋值不等于null了，但是对象的构造方法还没有调用完成的情况。第二个线程去判断不为空，拿到的对象还未初始化完成造成错误。 如何安全停止一个线程stop方法，被废弃。强行停止一个线程，没有资源的机会，如果正在处理任务，会留下一堆异常的数据。另一个线程再访问时就会发生错误。那么如何安全的结束呢：1、设置volatile的boolean标志位，修改标志位来判断是否继续执行还是清理现场。 2、Interrupt方法：线程内部也需要做支持，判断是否被中断，和标志位类似的处理。支持sleep等系统方法（sleep过程中中断）。判断是否中断的两个方法的区别：interrupted，静态方法，获取当前正在执行的线程是否被中断，中断之后会清空状态，重复获取就返回falseisInterrupted，线程的方法，获取当前线程的中断状态，不会被清空状态 HashMap原理底层是数组+链表的结构，默认数组长度16，加载因子0.75，在put时，（如果第一次put，会创建数组）如果元素个数大于数组长度*加载因子时，将触发扩容操作，数组长度翻倍，并重新计算hash将元素放入数组； Java1.8中，如果元素过多，数组长64，链表长度超过8，将进行树化操作，将链表转为红黑树，红黑树的节点是链表节点占用空间的两倍，提高查询效率； 如何计算元素存储的位置，如何解决hash冲突，为何数组长度必须为2的整数幂：先把key取hash值，然后进行一个二次hash，方式为(n-1)&amp;hash，这个二次hash是因为如果n正好等于2的幂，(n-1)&amp;hash相当于对n取模，这样位运算效率很高，这样就相当于把元素均匀分布到了数组中，如果数组的位置没有元素，直接保存元素，如果已经有元素了，表示发生了hash冲突，将改为链表的存储方式，把新元素放在头部（1.8中是尾插法） 为什么加载因子为0.75？设为1和0.5有什么问题？loadFactor太大，比如等于1，那么就会有很高的哈希冲突的概率，会大大降低查询速度。 loadFactor太小，比如等于0.5，那么频繁扩容没，就会大大浪费空间。 Hashtable初始化容量不一样（11），线程安全对整个数组加锁，不允许null值，数据结构一直是数组+链表，不会转换为红黑树； ConcurrentHashMap:1.5-1.7采用分段锁segment机制，不再是整个数组加锁，而是对单条或者几条链表和红黑树进行加锁。内部结构如图：segment数组，segment中类似HashMap的数组+链表。要通过hash让元素尽可能的均匀分布到不同的segment和数组中，所以对key取hash，用高位确定segment的位置，然后用低位确定数组的位置。 1.5的hash算法不好，元素多的时候会造成新加的节点分布在最后的几个桶，分布不均匀， 1.6就改善了hash算法。 1.7的优化是采用segment的懒加载机制，并用volatile的方式访问数组，保证数组的线程可见性，结合CAS指令来避免加锁。 1.8中则基于hashmap做优化，不再采用分段锁，而是对桶节点加锁，使用volatile和CAS乐观锁来实现读和写，再次提高了效率。 通过对Hashtable和ConcurrentHashMap的比较，得出一些锁优化的方法论，比如大锁不如小锁，长锁不如短锁，读写锁的分离等等 线程池原理线程池的参数1.corePoolSize：线程池大小，当向线程池提交任务时，如果线程池已创建的线程数小于corePoolSize，即便此时存在空闲线程，也会创建一个新的线程来执行任务，直到线程数大于或等于corePoolSize。（除了提交新任务来创建线程，也可以通过prestartCoreThread或prestartAllCoreThreads来提前创建核心线程）2.maximumPoolSize：线程池最大大小，当任务队列满了，且已创建的线程数小于最大线程数，则创建新线程来执行任务，如果线程池任务队列为无界队列可以忽略该参数3.keepAliveTime：线程存活时间，当线程数大于核心线程数时，线程空闲时间大于存活时间，那么这个线程将被销毁，如果线程池任务队列为无界队列可以忽略该参数4.workQueue：任务队列，用于保存等待执行任务的阻塞队列5.threadFactory：线程工厂，用于创建新线程，可以设置统一风格的线程名6.handler：线程饱和策略，当任务队列和线程池都满了，继续提交任务将执行此策略 如何配置线程池？需要看任务的类型cpu密集型需要配置较小的线程数，避免cpu过度切换反而效率低下IO密集型，线程池可以稍大，提高cpu的利用率；混合型任务则可配置两个线程池分别来执行； java自带的线程池 线程池 核心线程 最大线程 存活时间 任务队列CachedThreadPool 0 Integer.MAX_VALUE 60S SynchronousQueueFixedThreadPool n n 0 LinkedBlockingQueueSingleThreadExecutor 1 1 0 LinkedBlockingQueueScheduledThreadPool n Integer.MAX_VALUE 0 DelayWorkQueue SynchronousQueue：只能有一个元素的队列，插入和获取元素都会阻塞线程 java方法分派（多态）子类复写父类方法，调用方法调用子类还是父类？ 取决于运行时具体的调用者类型，实例是子类就调用子类的方法。 HTTPS 对称加密和非对称加密 对称加密：加密和解密使用同一个秘钥，使用对应的加密和解密算法进行加解密 非对称加密：加密和解密使用不同的秘钥，分为公钥和私钥，公钥和私钥相互可解，意思就是私钥加密的密文只有公钥可解，反之亦然。 数字签名技术​ 非对称加密在实际使用中，公钥会公开出来，私钥保存在自己手中不公开。由于私钥加密的密文只有公钥可解，那么如果有一个密文用你的公钥可以解开，那么可以说明这个密文肯定是你的私钥加密的，这就诞生了数字签名技术。​ 只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明 https的本质https的本质就是：用非对称加密的方式协商出一个对称加密的会话秘钥来进行会话 首先服务端需要有一个证书，证书包含了自己的公钥和服务端信息，如hash算法、加密算法、域名、有效期等等。此证书需要由可信任的第三方（CA机构）的私钥进行签名，实际上是对证书做一个hash，得到hash值然后签名，CA机构也可能不止一级而是一个证书链 为什么要用第三方机构来颁发证书呢？为了安全的传输自己的公钥，系统都预置了可信任的根证书，三方机构是否可信任由系统来保证 客户端如何校验CA证书1.客户端收到证书后，用证书中的公钥去解密该Hash值，得到hash-a2.客户端用证书中指定的签名算法，计算出一个hash-b，比较hash-a和hash-b3.除了校验hash值，还会校验CA证书有效期和域名等 SSL握手过程1.客户端A访问服务端B，客户端生成一个随机数1、将自己支持的SSL版本号、加密套件（包括哈希算法和加密算法）等信息发送给服务端2.服务端B收到请求，选择一个加密套件，也生成一个随机数2，将随机数和自己的证书一同返回给客户端3.客户端收到证书，校验证书是否有效（方法之前说过了），通过校验后，生成一个随机数3，用证书中的公钥加密随机数3，发送给服务端B4.服务端收到加密的随机数，用私钥解密5.服务端和客户端都有了随机数1、2、3，通过这三个随机数，生成一个对称加密的会话密钥6.服务端和客户端分别通知对方之后的会话用会话秘钥来完成，握手结束 为什么要用非对称加密来握手，而用对称加密来会话对称加密握手的话，由于双方的秘钥是一样的，相当于秘钥公开了，和没加密没有区别而会话阶段，对称加密效率较非对称高 TCP为什么要三次握手和四次挥手 “三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。例如：第一次请求由于网络拥堵没有到达服务端，客户端又发起第二次请求，正常完成了连接，传输完数据之后断开，这时第一次的请求到达了服务端，如果没有第三次握手，会直接建立一条没有用的连接，server端一直等待，浪费资源。 +“四次挥手”原因是因为tcp是全双工模式，接收到FIN时意味对方将没有数据再发来，但是自己还是可以继续发送数据。 为什么TCP是可靠的？TCP基于连接，具有以下机制： 确认和重传：接收方收到报文后就会进行确认，发送方一段时间没有收到确认就会重传。 数据校验。 数据合理分片与排序，TCP会对数据进行分片，接收方会缓存为按序到达的数据，重新排序后再提交给应用层。 流程控制：当接收方来不及接收发送的数据时，则会提示发送方降低发送的速度，防止包丢失。 拥塞控制：当网络发生拥塞时，减少数据的发送。 UDP是无连接、不安全的，每个数据包都包含接收的ip等信息，客户端只管发送，没有确认重传机制，所以速度更快，但是可能会丢包。 HTTP1.0、1.1、2.0的区别1.1和1.0： 增加新的控制缓存策略的Header，如Entity tag，If-Unmodified-Since, If-Match, If-None-Match； 增加了range请求头，允许请求资源的一部分，支持了多线程断点续传下载，优化了带宽和连接； 增加了Host头，允许一台物理服务器上存在多个虚拟主机，共享一个IP地址，通过Host来区分； 增加了keep-alive支持TCP长连接，一定程度弥补了每次请求都重新创建连接的情况； SPDY：SPDY是Http1.x版本的优化方案，包括多路复用技术、请求优先级（多路复用时，多个请求并行于共用的TCP连接，可以设置请求的优先级防止关键请求被阻塞）、header压缩和服务端推送功能；SPDY的特性并入了Http2.0中； 1.1和2.0： 支持了新的二进制格式，1.x版本只支持文本协议 多路复用技术，在HTTP/1.1协议中，同一时间针对同一域名下的请求有一定数量限制，超过限制数目的请求会被阻塞。多个请求是串行处理，当一个请求超时，后续请求就会被阻塞，而在2.0中，一个TCP连接上并行多个请求，某个请求耗时不影响其他连接； Header压缩，多个请求可以差量更新Header字段，降低流量提高效率； 服务端推送功能 三方授权方式 Basic：格式：Authorization: Basic username:password(Base64ed) Bearer：格式：Authorization: Bearer bearer token 的获取⽅式（ OAuth2 的授权流程）：1.第三⽅⽹站向授权⽅⽹站申请第三⽅授权合作，拿到 client id 和 client secret 2.⽤户在使⽤第三⽅⽹站时，点击「通过 XX (如 GitHub) 授权」按钮，第三⽅⽹站将⻚⾯跳转到授权⽅⽹站，并传⼊ client id 作为⾃⼰的身份标识 3.授权⽅⽹站根据 client id ，将第三⽅⽹站的信息和需要的⽤户权限展示给⽤户，询问⽤户是否同意授权 4.⽤户点击「同意授权」按钮后，授权⽅⽹站将⻚⾯跳转回第三⽅⽹站，并传⼊ Authorization code 作为⽤户认可的凭证。 5.第三⽅⽹站将 Authorization code 发送回⾃⼰的服务器 6.服务器将 Authorization code 和 client secret ⼀并发送给授权⽅的服务器，授权⽅返回 access token。 WebSocket和Socket的区别 WebSocket是应用层的一个持久化协议，http它一次请求和响应就断开连接，属于非持久化协议。WebSocket分为握手和数据传输两个阶段，采用http协议握手然后建立全双工的tcp连接。 Socket是传输层的一个协议抽象，包括TCP和UDP，TCP基于连接，拥有确认和重传，拥塞控制和流程控制等机制的可靠的协议。UDP则面向无连接，基于数据报，相对于TCP速度快但不可靠。 多线程下载和断点续传两个核心Header，Content-Length表示文件的总字节数，RANGE表示从某一个位置开始传输。 首先，获取到文件大小后，通过线程数来计算每个线程下载的开始位置。 然后，通过range来设置从哪个位置传输。 当暂停或者退出时，记录已下载的位置，下次恢复后从记录的位置下载。 使用RandAccessFile来保存文件，这个类的特点是可以通过移动文件指针来设置写入的位置。","categories":[{"name":"offce","slug":"offce","permalink":"http://b.nearby.ren/categories/offce/"}],"tags":[{"name":"offce","slug":"offce","permalink":"http://b.nearby.ren/tags/offce/"}]},{"title":"七友","slug":"七友","date":"2015-11-11T03:50:28.000Z","updated":"2017-01-21T02:44:31.642Z","comments":true,"path":"2015/11/11/七友/","link":"","permalink":"http://b.nearby.ren/2015/11/11/七友/","excerpt":"","text":"梁汉文 - 七友曲 : 雷颂德 词：林夕 为了她又再勉强去谈天论爱又再振作去慰解他人如难复合便尽早放开凡事看开又再讲没有情人时还可自爱忘掉或是为自己感慨笑住说沉沦那些苦海会有害 因为我坚强到利用自己的痛心转换成爱心抵我对她操心已记不起我也有权利爱人 谁人曾照顾过我的感受待我温柔吻过我伤口能得到的安慰是失恋者得救后很感激忠诚的狗谁人曾介意我也不好受为我出头碰过我的手重生者走得的都走谁人又为天使忧愁甜言蜜语没有但却有我这个好友 直到她又再告诉我重新被爱又再看透了我的将来完成任务后大可喝采无谓搭台别怪她就怪我永远难得被爱然后自虐地赞她可爱往日最彷徨那刻好彩有我在 因为我坚强到利用自己的痛心转换成爱心抵我对她操心已记不起我也有权利爱人 谁人曾照顾过我的感受待我温柔吻过我伤口能得到的安慰是失恋者得救后很感激忠诚的狗谁人曾介意我也不好受为我出头碰过我的手重生者走得的都走谁人又为天使忧愁甜言蜜语没有但却有我这个好友 白雪公主不多认命扮矮人的有太多个早有六个多我这个不多我太好心还是太傻未问过她有没有理我的感受待我温柔吻过我伤口能得到的安慰是失恋者得救后很感激忠诚的狗谁人曾介意我也不好受为我出头碰过我的手重生者走得的都走谁人又为天使忧愁甜言蜜语没有但却有我这个好友","categories":[{"name":"文字","slug":"文字","permalink":"http://b.nearby.ren/categories/文字/"}],"tags":[{"name":"歌曲","slug":"歌曲","permalink":"http://b.nearby.ren/tags/歌曲/"}]},{"title":"gradle目录解析","slug":"gradle目录解析","date":"2015-11-10T05:40:09.000Z","updated":"2017-07-18T08:16:42.350Z","comments":true,"path":"2015/11/10/gradle目录解析/","link":"","permalink":"http://b.nearby.ren/2015/11/10/gradle目录解析/","excerpt":"","text":"Gradle目录解析 Gradle 是以 Groovy 语言为基础，面向Java应用为主。基于DSL（领域特定语言）语法的自动化构建工具。Gradle这个工具集成了构建，测试，发布和其他，比如软件打包，生成注释文档等功能。之前eclipse使用ant进行软件的构建功能，需要配置一大堆的xml，但是在gradle中就不需要了。 目前主流的打包方式有ant,maven,gradle。gradle是近几年发展起来的自动化构建工具，解决ant构建上的繁琐代码。比如在ant上发布多渠道的包，你需要自己写脚本替换渠道名称，而在gradle中就不需要了。已经内建支持多渠道打包。 Gradle的文件结构 ./build.gradle ./gradle.properties ./gradlew ./gradlew.bat ./local.properties ./setting.gradle ./XXX.iml ./app/build.gradle ./app/app.iml ./app/proguard-rules.pro ./builld.gradle 和 ./app/build.grade gradle项目自动编译的时候要读取的配置文件。比如指定项目的依赖包等。build.grade有两个，一个是全局的，一个是在模块里面。全局的build.grade主要设置的是声明仓库源，gradle的版本号说明等。 ./build.gradle buildscript { repositories { // 声明仓库源，比如我们构建了一个安卓的库，现在想要把库上传到jcenter中供别人一起使用，则可以上传到jcenter中 // 具体上传步骤见：http://www.jcodecraeer.com/a/anzhuokaifa/Android_Studio/2015/0227/2502.html jcenter() } dependencies { // 说明gradle的版本号 classpath &apos;com.android.tools.build:gradle:1.3.0&apos; // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files } } // 所有项目都继承这个配置 allprojects { repositories { mavenLocal() jcenter() } } ./app/build.grade 设置了模块的gradle构建配置 // 说明这个模块是安卓项目，如果是多模块开发，有可能有的值为java/war apply plugin: ‘com.android.application’ // 配置了所有android构建的参数android { // 编译使用SDK版本 compileSdkVersion 23 // 编译工具的版本 buildToolsVersion “23.0.1” defaultConfig { // 包名 applicationId &quot;com.awesomeproject&quot; // sdk最低支持版本 minSdkVersion 16 // 目标SDK版本，如果目标设备的API版本正好等于此数值，就不会为此程序开启兼容性检查判断的工作 targetSdkVersion 22 // 版本号 versionCode 1 versionName &quot;1.0&quot; // 原生 ndk { abiFilters &quot;armeabi-v7a&quot;, &quot;x86&quot; } } buildTypes { // 发布时候的设置 release { // 是否进行混淆 minifyEnabled false // 混淆使用文件 proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; } } } // 依赖的工具包 dependencies { compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) compile &apos;com.android.support:appcompat-v7:23.0.0&apos; compile &apos;com.facebook.react:react-native:0.11.+&apos; } ./app/proguard-rules.pro 这个和上面说的一样混淆文件 ./gradle.properties grade的运行环境配置，比如使用多少内存之类的。 ./gradlew 和 ./gradlew.bat 自动完成 gradle 环境的脚本，在linux和mac下直接运行gradlew会自动完成gradle环境的搭建。 ./local.properties 配置SDK或者NDK的环境路径，各个机器上这个变量可能都是不一样的，所以不应该进入版本库 ./setting.gradle 整个项目的管理，比如这个项目包含哪些模块等。 ./XXX.iml 和 ./app/app.iml iml是Intellij模块文件。Intellij是一款JAVA的IDE。AndroidStudio是基于开源的Intellij IDEA开发出来的IDE。所以AndroidStudio有的IDE功能是需要有.iml才能使用的。比如我们删除了iml文件，可能就在Android Studio中看不到一些目录了。","categories":[{"name":"gradle","slug":"gradle","permalink":"http://b.nearby.ren/categories/gradle/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"},{"name":"gradle","slug":"gradle","permalink":"http://b.nearby.ren/tags/gradle/"}]},{"title":"读不透的言辞","slug":"读不透的言辞","date":"2015-10-01T01:09:50.000Z","updated":"2021-10-03T03:02:40.028Z","comments":true,"path":"2015/10/01/读不透的言辞/","link":"","permalink":"http://b.nearby.ren/2015/10/01/读不透的言辞/","excerpt":"","text":"没什么比懂自己的心来得更重要.","categories":[{"name":"文字","slug":"文字","permalink":"http://b.nearby.ren/categories/文字/"}],"tags":[{"name":"文字","slug":"文字","permalink":"http://b.nearby.ren/tags/文字/"}]},{"title":"java对象四大引用","slug":"java对象四大引用","date":"2015-09-22T03:47:38.000Z","updated":"2016-11-21T14:59:36.000Z","comments":true,"path":"2015/09/22/java对象四大引用/","link":"","permalink":"http://b.nearby.ren/2015/09/22/java对象四大引用/","excerpt":"","text":"强引用、软引用、弱引用、虚引用总结 总结： 强引用(StrongReference)：普通new对象的引用Person person = new Person(); JVM宁愿抛出OutOfMenory异常也不会去回收该对象。 软引用(SoftReference)： SoftReference引用的装饰对象，该对象的强引用应该赋值空这里配合SoftReferenceQueue使用(也可以配合),因为SoftRefereceQueue本身也是new了一个对象，当它把别人的问题解决掉以后，也需要自己的问题解决，所有jvm把软引用对象回收后，就会把自己的对象引用放到这个队列中，我们可以通过队列的poll()方法查看,如果存在该ReferenceQueue引用也赋值为空，等待被jvm回收。注意：软引用对象在jvm内存不够的时候才会被回收，我们调用system.gc方法只是起通知作用，jvm什么时候扫描回收对象，是jvm自己的状态决定的。就算扫描到软引用对象也不一定回收。只有内存不够的时候才会回收ReferenceQueue queue = new ReferenceQueue();Person person = new Person();SoftReference soft = new SoftReference(person,queue);user = null; 弱引用(WeakReference)：弱引用也是用描述非必需对象的，当jvm进行垃圾回收时，只要扫描到，无论内存是否充足(与软引用的区别)，都会回收弱引用关联的对象。在java中，用java.lang.ref.WeakReference类表示WeakReference weak = new WeakRefence(new Person());System.out.println(weak.get());System.gc();//通知jvm的gc进行垃圾回收System.out.println(weak.get()); 虚引用(PhantomReference)：虚引用和前面的软引用，弱引用不同，它并不影响对象的生命周期。在java中用java.lang.ref.PhantomReference类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。要注意的是，虚引用必须和引用队列关联使用，当垃圾回收准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入引用队列，那么就可以在所引用的对象内存被回收之前采取必要的行动。ReferenceQueue queue = new ReferenceQueue();PhantomReference prf = new PhantomReference(new Person(),queue);System.out.print(prf.get());http://www.cnblogs.com/dolphin0520/p/3741519.htmlhttp://www.cnblogs.com/dolphin0520/p/3749259.html","categories":[{"name":"java","slug":"java","permalink":"http://b.nearby.ren/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://b.nearby.ren/tags/java/"}]},{"title":"android 正则表达式","slug":"android-正则表达式","date":"2015-09-22T01:52:37.000Z","updated":"2016-11-21T14:59:36.000Z","comments":true,"path":"2015/09/22/android-正则表达式/","link":"","permalink":"http://b.nearby.ren/2015/09/22/android-正则表达式/","excerpt":"","text":"android正则表达式及Pattern Matcher使用 // 反斜杠 /t 间隔 (&apos;/u0009&apos;) /n 换行 (&apos;/u000A&apos;) /r 回车 (&apos;/u000D&apos;) /d 数字 等价于[0-9] /D 非数字 等价于[^0-9] /s 空白符号 [/t/n/x0B/f/r] /S 非空白符号 [^/t/n/x0B/f/r] /w 单独字符 [a-zA-Z_0-9] /W 非单独字符 [^a-zA-Z_0-9] /f 换页符 /e Escape /b 一个单词的边界 /B 一个非单词的边界 /G 前一个匹配的结束 ^为限制开头 ^java 条件限制为以Java为开头字符 $为限制结尾 java$ 条件限制为以java为结尾字符 . 条件限制除/n以外任意一个单独字符 java.. 条件限制为java后除换行外任意两个字符 加入特定限制条件「[]」 [a-z] 条件限制在小写a to z范围中一个字符 [A-Z] 条件限制在大写A to Z范围中一个字符 [a-zA-Z] 条件限制在小写a to z或大写A to Z范围中一个字符 [0-9] 条件限制在小写0 to 9范围中一个字符 [0-9a-z] 条件限制在小写0 to 9或a to z范围中一个字符 [0-9[a-z]] 条件限制在小写0 to 9或a to z范围中一个字符(交集) []中加入^后加再次限制条件「[^]」 [^a-z] 条件限制在非小写a to z范围中一个字符 [^A-Z] 条件限制在非大写A to Z范围中一个字符 [^a-zA-Z] 条件限制在非小写a to z或大写A to Z范围中一个字符 [^0-9] 条件限制在非小写0 to 9范围中一个字符 [^0-9a-z] 条件限制在非小写0 to 9或a to z范围中一个字符 [^0-9[a-z]] 条件限制在非小写0 to 9或a to z范围中一个字符(交集) 在限制条件为特定字符出现0次以上时，可以使用「*」 J* 0个以上J .* 0个以上任意字符 J.*D J与D之间0个以上任意字符 在限制条件为特定字符出现1次以上时，可以使用「+」 J+ 1个以上J .+ 1个以上任意字符 J.+D J与D之间1个以上任意字符 在限制条件为特定字符出现有0或1次以上时，可以使用「?」JA? J或者JA出现 限制为连续出现指定次数字符「{a}」 J{2} JJ J{3} JJJ 文字a个以上，并且「{a,}」 J{3,} JJJ,JJJJ,JJJJJ,???(3次以上J并存) 文字个以上，b个以下「{a,b}」 J{3,5} JJJ或JJJJ或JJJJJ 两者取一「|」 J|A J或A Java|Hello Java或Hello 比如，在字符串包含验证时 //查找以Java开头,任意结尾的字符串 Pattern pattern = Pattern.compile(&quot;^Java.*&quot;); Matcher matcher = pattern.matcher(&quot;Java棒棒的&quot;); boolean bool = matcher.matches(); System.out.println(bool); //true //以多条件分割字符串时 Pattern pattern = Pattern.compile(&quot;[,|]+&quot;); String[] strs = pattern.split(&quot;Java Hello World Java,Hello,,World|Sun&quot;); for (int i=0;i&lt;strs.length;i++) { System.out.println(strs[i]); //Java Hello World Java //Hello //World //Sun } //文字替换（首次出现字符） Pattern pattern = Pattern.compile(&quot;正则表达式&quot;); Matcher matcher = pattern.matcher(&quot;正则表达式 Hello World,正则表达式 Hello World&quot;); //替换第一个符合正则的数据 System.out.println(matcher.replaceFirst(&quot;Java&quot;)); //Java Hello World,正则表达式 Hello //文字替换（全部） Pattern pattern = Pattern.compile(&quot;正则表达式&quot;); Matcher matcher = pattern.matcher(&quot;正则表达式 Hello World,正则表达式 Hello World&quot;); //替换第一个符合正则的数据 System.out.println(matcher.replaceAll(&quot;Java&quot;)); //Java Hello World,Java Hello //◆文字替换（置换字符） Pattern pattern = Pattern.compile(&quot;正则表达式&quot;); Matcher matcher = pattern.matcher(&quot;正则表达式 Hello World,正则表达式 Hello World &quot;); StringBuffer sbr = new StringBuffer(); while (matcher.find()) { matcher.appendReplacement(sbr, &quot;Java&quot;); } matcher.appendTail(sbr); System.out.println(sbr.toString()); //Java Hello World,Java Hello World //验证是否为邮箱地址 String str=&quot;ceponline@yahoo.com.cn&quot;; Pattern pattern = Pattern.compile(&quot;[//w//.//-]+@([//w//-]+//.)+[//w//-]+&quot;,Pattern.CASE_INSENSI TIVE); Matcher matcher = pattern.matcher(str); System.out.println(matcher.matches()); //true //去除html标记 Pattern pattern = Pattern.compile(&quot;&lt;.+?&gt;&quot;, Pattern.DOTALL); Matcher matcher = pattern.matcher(&quot;&lt;a href=/&quot;index.html/&quot;&gt;主页&lt;/a&gt;&quot;); String string = matcher.replaceAll(&quot;&quot;); System.out.println(string); //主页 //查找html中对应条件字符串 Pattern pattern = Pattern.compile(&quot;href=\\&quot;(.+?)\\&quot;&quot;); Matcher matcher = pattern.matcher(&quot;&lt;a href=\\&quot;index.html\\&quot;&gt;主页&lt;/a&gt;&quot;); if(matcher.find()) System.out.println(matcher.group(1));//index.html //截取http://地址 Pattern pattern = Pattern.compile(&quot;(http://|https://){1}[//w//.//-/:]+&quot;); Matcher matcher = pattern.matcher(&quot;dsdsds&lt;http://dsds//gfgffdfd&gt;fdf&quot;); StringBuffer buffer = new StringBuffer(); while(matcher.find()){ buffer.append(matcher.group()); buffer.append(&quot;/r/n&quot;); System.out.println(buffer.toString()); } //替换指定{}中文字 String str = &quot;Java目前的发展史是由{0}年-{1}年&quot;; String[][] object={new String[]{&quot;//{0//}&quot;,&quot;1995&quot;},new String[]{&quot;//{1//}&quot;,&quot;2007&quot;}}; System.out.println(replace(str,object)); public static String replace(final String sourceString,Object[] object) { String temp=sourceString; for(int i=0;i&lt;object.length;i++){ String[] result=(String[])object[i]; Pattern pattern = Pattern.compile(result[0]); Matcher matcher = pattern.matcher(temp); temp=matcher.replaceAll(result[1]); } return temp; } //Java目前的发展史是由1995年-2007年","categories":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://b.nearby.ren/tags/android/"}]},{"title":"git基础学习一","slug":"git基础学习一","date":"2015-09-21T03:13:18.000Z","updated":"2017-04-18T05:45:21.211Z","comments":true,"path":"2015/09/21/git基础学习一/","link":"","permalink":"http://b.nearby.ren/2015/09/21/git基础学习一/","excerpt":"","text":"git常用命令 git mkdir xx(创建xx文件夹) cd xx(切换到xx文件夹) touch a.md(新建a.md文件) gitstatus (查看git文件内容状态) git init(初始化仓库) git add xx(添加xx文件到暂存区) git add . (添加所有文件到暂存区) git commit -m”content”(content 提交内容留言) git log (查看日志) git branch (查看分支，* master是默认分支) git branch a (新建名为a的分支) git checkout a (切换到名为a的分支 快捷方式 git checkout -b a 新建a分支并切换到该分支) git merge (分支合并 切换到主分支 再执行 git merge a 将a分支合并到主分支上) git branch -d a (删除a分支) git branch -D a (执行 branch -d a 删除失败，比如a分支未合并到主分支上，git branch -D a就是执行强制删除) git tag v1.0(创建标签v1.0版本。标签，用于标记版本。切换某版本 git checkout v1.0) PUSH&amp;PUll git push origin master (推代码到远程仓库) git pull origin master (拉代码到本地) git clone git@github.com:mccapp/test.git (将远程代码复制到本地) git remote add origin git@github.com:mccapp/test.git (将本地项目与github上的项目进行关联) git remote -v (查看有那些远程仓库) git config –blobal user.name “mccapp” (设置github用户名) git config –blobal user.email “rsinn@sina.com”(设置邮箱) git进阶 进阶链接 团队合作gitrxjava进阶教程","categories":[{"name":"git","slug":"git","permalink":"http://b.nearby.ren/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://b.nearby.ren/tags/git/"}]},{"title":"git基础学习二","slug":"git基础学习二","date":"2015-09-21T03:13:18.000Z","updated":"2017-04-18T05:45:27.227Z","comments":true,"path":"2015/09/21/git基础学习二/","link":"","permalink":"http://b.nearby.ren/2015/09/21/git基础学习二/","excerpt":"","text":"git常用命令 1) 远程仓库相关命令 检出仓库：$ git clone git://github.com/jquery/jquery.git查看远程仓库：$ git remote -v添加远程仓库：$ git remote add [name] [url]删除远程仓库：$ git remote rm [name]修改远程仓库：$ git remote set-url –push[name][newUrl]拉取远程仓库：$ git pull [remoteName] [localBranchName]推送远程仓库：$ git push [remoteName] [localBranchName] 2）分支(branch)操作相关命令 查看本地分支：$ git branch查看远程分支：$ git branch -r创建本地分支：$ git branch [name] —-注意新分支创建后不会自动切换为当前分支切换分支：$ git checkout [name]创建新分支并立即切换到新分支：$ git checkout -b [name]删除分支：$ git branch -d [name] —- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项合并分支：$ git merge [name] —-将名称为[name]的分支与当前分支合并创建远程分支(本地分支push到远程)：$ git push origin [name]删除远程分支：$ git push origin :heads/[name]我从master分支创建了一个issue5560分支，做了一些修改后，使用git push origin master提交，但是显示的结果却是’Everything up-to-date’，发生问题的原因是git push origin master 在没有track远程分支的本地分支中默认提交的master分支，因为master分支默认指向了origin master 分支，这里要使用git push origin issue5560：master 就可以把issue5560推送到远程的master分支了。如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，那么可以这么做。 $ git push origin test:master // 提交本地test分支作为远程的master分支 //好像只写这一句，远程的github就会自动创建一个test分支$ git push origin test:test // 提交本地test分支作为远程的test分支 如果想删除远程的分支呢？类似于上面，如果:左边的分支为空，那么将删除:右边的远程的分支。 $ git push origin :test // 刚提交到远程的test将被删除，但是本地还会保存的，不用担心 3）版本(tag)操作相关命令 查看版本：$ git tag创建版本：$ git tag [name]删除版本：$ git tag -d [name]查看远程版本：$ git tag -r创建远程版本(本地版本push到远程)：$ git push origin [name]删除远程版本：$ git push origin :refs/tags/[name]推送所有tag: git push origin –tags tag迁出branch：git checkout tagnamegit checkout -b new_branch_name 4）git stash暂存相关命令 git stash: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。git stash pop: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。git stash list: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。git stash clear: 清空Git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了。 5）git rebase 使用 当前分支问题develop，从master拉取最新代码git pull –rebase origin master 或者 git rebase develop先将develop分支的代码checkout出来，作为工作目录然后将master分支从develop分支创建起的所有改变的补丁，依次打上。如果打补丁的过程没问题，rebase就搞定了如果打补丁的时候出现了问题，就会提示你处理冲突。处理好了，可以运行git rebase –continue继续直到完成如果你不想处理，你还是有两个选择，一个是放弃rebase过程（运行git rebase –abort），另一个是直接用test分支的取代当前分支的（git rebase –skip）。 6） 工具 SourceTree &amp; git bash git进阶 进阶链接 团队合作gitrxjava进阶教程","categories":[{"name":"git","slug":"git","permalink":"http://b.nearby.ren/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://b.nearby.ren/tags/git/"}]},{"title":"resume2","slug":"resume2","date":"2015-06-09T01:19:18.000Z","updated":"2016-11-21T14:59:36.000Z","comments":true,"path":"2015/06/09/resume2/","link":"","permalink":"http://b.nearby.ren/2015/06/09/resume2/","excerpt":"","text":"姓名170 7777 7777 | xxx@gmail.com | github.com/xx | www.xx.com 个人经历20xx/xx—至今codeKK2 公司 | Android 资深开发工作描述：带领移动团队负责 xx，取得了什么成绩 20xx/xx—20xx/xxcodeKK1 公司 | Android 高级开发工作描述：负责 xx 产品，取得了什么成绩 20xx/xx—20xx/xxXXX 学校 | XX 专业 | 本科专业排名：x/xxx GPA： 专业技能x 年团队管理经验，x 年开发经验，x 年移动开发经验开源 xx 项目，用于 xx，多少 Star，多少 Contributors博客主要分享 xx xx熟悉 Android 应用框架设计，熟悉 Android 高性能编程及调优熟悉xx 技术点，xx 技术点，xx 技术点 项目经验 20xx/xx—至今 | codeKK2 公司 | XX 项目项目简介：职责： 20xx/xx—20xx/xx | codeKK2 公司 | XX 项目项目简介：职责： 20xx/xx—20xx/xx | codeKK2 公司 | XX 项目项目简介：职责： 20xx/xx—20xx/xx | codeKK1 公司 | XX 项目项目简介：职责： 20xx/xx—20xx/xx | codeKK1 公司 | XX 项目项目简介：职责： 在校经历XX大赛 XX 奖XX 系统设计、开发XXX 奖学金","categories":[{"name":"resume","slug":"resume","permalink":"http://b.nearby.ren/categories/resume/"}],"tags":[{"name":"resume","slug":"resume","permalink":"http://b.nearby.ren/tags/resume/"}]},{"title":"resume1","slug":"resume1","date":"2015-06-08T01:19:18.000Z","updated":"2016-11-21T14:59:36.000Z","comments":true,"path":"2015/06/08/resume1/","link":"","permalink":"http://b.nearby.ren/2015/06/08/resume1/","excerpt":"","text":"姓名Phone：170 7777 7777 Email：xxx@gmail.com GitHub：github.com/xx Blog：www.xx.com 个人经历 ■ 20xx/xx—至今 codeKK2 公司 Android 资深开发 带领移动团队负责 xx，取得了什么成绩 ■ 20xx/xx—20xx/xx codeKK1 公司 Android 高级开发 负责 xx 产品，取得了什么成绩 ■ 20xx/xx—20xx/xx XX 学校 本科 xx 专业专业排名：x/xxx GPA： 专业技能 x 年团队管理经验，x 年开发经验，x 年移动开发经验 开源 xx 项目，用于 xx，多少 Star，多少 Contributors 博客主要分享 xx xx 熟悉 Android 应用框架设计，熟悉 Android 高性能编程及调优 熟悉 xx 技术点，xx 技术点，xx 技术点 项目经历 ■ 20xx/xx—至今 XX 项目 codeKK2 公司 项目简介：职责： ■ 20xx/xx—20xx/xx XX 项目 codeKK2 公司 项目简介：职责： ■ 20xx/xx—20xx/xx XX 项目 codeKK2 公司 项目简介：职责： ■ 20xx/xx—20xx/xx XX 项目 codeKK1 公司 项目简介：职责： ■ 20xx/xx—20xx/xx XX 项目 codeKK1 公司 项目简介：职责： 在校经历● XX 比赛 XX 奖● XX 系统设计、开发● XXX 奖学金各大互联网公司 Android 内推到 http://j.codekk.com/","categories":[{"name":"resume","slug":"resume","permalink":"http://b.nearby.ren/categories/resume/"}],"tags":[{"name":"resume","slug":"resume","permalink":"http://b.nearby.ren/tags/resume/"}]}]}