<!DOCTYPE html>
<html lang="zh">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    
    <title>nearby.ren</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="nearby, 移动开发, 用户体验, 设计, Java, JavaWeb, Go">
<meta property="og:type" content="website">
<meta property="og:title" content="nearby.ren">
<meta property="og:url" content="http://b.nearby.ren/page/17/index.html">
<meta property="og:site_name" content="nearby.ren">
<meta property="og:description" content="nearby, 移动开发, 用户体验, 设计, Java, JavaWeb, Go">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="nearby.ren">
<meta name="twitter:description" content="nearby, 移动开发, 用户体验, 设计, Java, JavaWeb, Go">
    

    
        <link rel="alternate" href="/atom.xml" title="nearby.ren" type="application/atom+xml">
    

    
        <link rel="icon" href="/css/images/super.png# path to favicon">
    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    


</head>
</html>
<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">nearby.ren</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/">首页</a>
                
                    <a class="main-nav-link" href="/archives">目录</a>
                
                    <a class="main-nav-link" href="/categories">分类</a>
                
                    <a class="main-nav-link" href="/tags">Tags</a>
                
                    <a class="main-nav-link" href="/about">关于</a>
                
            </nav>
            
                
                <nav id="sub-nav">
                    <div class="profile" id="profile-nav">
                        <a id="profile-anchor" href="javascript:;">
                            <img class="avatar" src="/css/images/avatar.png">
                            <i class="fa fa-caret-down"></i>
                        </a>
                    </div>
                </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索">
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么...">
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/">首页</a></td>
                
                    <td><a class="main-nav-link" href="/archives">目录</a></td>
                
                    <td><a class="main-nav-link" href="/categories">分类</a></td>
                
                    <td><a class="main-nav-link" href="/tags">Tags</a></td>
                
                    <td><a class="main-nav-link" href="/about">关于</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索">
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
                

<aside id="profile">
    <div class="inner profile-inner">
        <div class="base-info profile-block">
            <img id="avatar" src="/css/images/avatar.png">
            <h2 id="name">lr</h2>
            <h3 id="title">Android server web Go</h3>
            <span id="location"><i class="fa fa-map-marker"></i>china, Hainan</span>
            <a id="follow" target="_blank" href="https://github.com/nearbyren">关注我</a>
        </div>
        <div class="article-info profile-block">
            <div class="article-info-block">
                93
                <span>文章</span>
            </div>
            <div class="article-info-block">
                41
                <span>标签</span>
            </div>
        </div>
        
        <div class="profile-block social-links">
            <table>
                <tr>
                    
                    
                    <td>
                        <a href="https://gitee.com/mccapp" target="_blank" title="github">
                            <i class="fa fa-github"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="https://twitter.com/" target="_blank" title="twitter">
                            <i class="fa fa-twitter"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="https://www.facebook.com/" target="_blank" title="facebook">
                            <i class="fa fa-facebook"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="https://dribbble.com/" target="_blank" title="dribbble">
                            <i class="fa fa-dribbble"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/atom.xml" target="_blank" title="rss">
                            <i class="fa fa-rss"></i>
                        </a>
                    </td>
                    
                </tr>
            </table>
        </div>
        
    </div>
</aside>

            
            <section id="main">
    <article id="post-service详解" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2016/01/18/service详解/">service详解</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2016/01/18/service详解/">
            <time datetime="2016-01-18T06:00:17.000Z" itemprop="datePublished">2016-01-18</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/android/">android</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/service/">service</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <blockquote>
<p><strong>android server 详解</strong></p>
<p> Service的种类：</p>
<p>一、Service的种类</p>
</blockquote>
<ol>
<li>本地服务， Local Service<br>用于应用程序内部。在Service可以调用Context.startService()启动，调用Context.stopService()结束。在内部可以调用Service.stopSelf()<br>或<br>Service.stopSelfResult()来自己停止。无论调用了多少次startService()，都只需调用一次stopService()来停止。</li>
<li>远程服务， Remote Service<br>用于android系统内部的应用程序之间。可以定义接口并把接口暴露出来，以便其他应用进行操作。客户端建立到服务对象的连接，并通过那个连接来调用服务。调用Context.bindService()方法建立连接，并启动，以调用<br>Context.unbindService()关闭连接。多个客户端可以绑定至同一个服务。如果服务此时还没有加载，bindService()会先加载它。</li>
</ol>
<p>提供给可被其他应用复用，比如定义一个天气预报服务，提供与其他应用调用即可。</p>
<blockquote>
<p> 二、生命周期</p>
</blockquote>
<p>1). 被启动的服务的生命周期：如果一个Service被某个Activity 调用 Context.startService方法启动，那么不管是否有Activity使用bindService绑定或unbindService解除绑定到该Service，该Service都在后台运行。如果一个Service被startService 方法多次启动，那么onCreate方法只会调用一次，onStart将会被调用多次（对应调用startService的次数），并且系统只会创建Service的一个实例（因此你应该知道只需要一次stopService调用）。该Service将会一直在后台运行，而不管对应程序的Activity是否在运行，直到被调用stopService，或自身的stopSelf方法。当然如果系统资源不足，android系统也可能结束服务。</p>
<p>2). 被绑定的服务的生命周期：如果一个Service被某个Activity 调用 Context.bindService 方法绑定启动，不管调用 bindService调用几次，onCreate方法都只会调用一次，同时onStart方法始终不会被调用。当连接建立之后，Service将会一直运行，除非调用Context.unbindService 断开连接或者之前调用bindService 的 Context 不存在了（如Activity被finish的时候），系统将会自动停止Service，对应onDestroy将被调用。</p>
<p>3).被启动又被绑定的服务的生命周期：如果一个Service又被启动又被绑定，则该Service将会一直在后台运行。并且不管如何调用，onCreate始终只会调用一次，对应startService调用多少次，Service的onStart便会调用多少次。调用unbindService将不会停止Service，而必须调用 stopService 或 Service的 stopSelf 来停止服务。</p>
<p>4).当服务被停止时清除服务：当一个Service被终止（1、调用stopService；2、调用stopSelf；3、不再有绑定的连接（没有被启动））时，onDestroy方法将会被调用，在这里你应当做一些清除工作，如停止在Service中创建并运行的线程。</p>
<blockquote>
<p>特别注意：</p>
</blockquote>
<ol>
<li><p>你应当知道在调用 bindService 绑定到Service的时候，你就应当保证在某处调用 unbindService<br>解除绑定（尽管Activity被finish的时候绑定会自动解除，并且Service会自动停止）</p>
</li>
<li><p>你应当注意 使用 startService 启动服务之后，一定要使用<br>stopService停止服务，不管你是否使用bindService。</p>
</li>
<li><p>同时使用 startService 与 bindService 要注意到，Service<br>的终止，需要unbindService与stopService同时调用，才能终止 Service，不管 startService 与<br>bindService 的调用顺序，如果先调用 unbindService 此时服务不会自动终止，再调用 stopService<br>之后服务才会停止，如果先调用 stopService 此时服务也不会终止，而再调用 unbindService 或者 之前调用<br>bindService 的 Context 不存在了（如Activity 被 finish 的时候）之后服务才会自动停止。</p>
</li>
<li><p>当在旋转手机屏幕的时候，当手机屏幕在“横”“竖”变换时，此时如果你的 Activity 如果会自动旋转的话，旋转其实是 Activity<br>的重新创建，因此旋转之前的使用 bindService 建立的连接便会断开（Context 不存在了），对应服务的生命周期与上述相同</p>
</li>
<li><p>在 sdk 2.0 及其以后的版本中，对应的 onStart 已经被否决变为了 onStartCommand，不过之前的 onStart<br>任然有效。这意味着，如果你开发的应用程序用的 sdk 为 2.0 及其以后的版本，那么你应当使用 onStartCommand 而不是<br>onStart。<br><img src="http://static.oschina.net/uploads/space/2015/0730/095222_Jssm_1175007.png" alt="此处输入图片的描述"></p>
</li>
</ol>
<blockquote>
<p>例子：</p>
</blockquote>
<pre><code>    public class ServiceDemo extends Service {

    public static final String TAG = &quot;ServiceDemo&quot; ;
    public static final String ACTION = &quot;com.demo.SERVICE_DEMO&quot;;

    /**
     * onBind 是 Service 的虚方法，因此我们不得不实现它。
     * 返回 null，表示客服端不能建立到此服务的连接，所以不会调用onServiceConnected。
     */
    @Override
    public IBinder onBind(Intent intent) {
        Log.i(TAG, this.toString() + &quot; ServiceDemo onBind&quot;);
        return null;
    }

    @Override
    public void onCreate() {
        Log.i(TAG, this.toString() + &quot; ServiceDemo onCreate&quot;);
        super.onCreate();
    }

    @Override
    public void onStart(Intent intent, int startId) {
    Log.i(TAG, this.toString() + &quot; ServiceDemo onStart&quot;);
    super.onStart(intent, startId);
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        Log.i(TAG, this.toString() + &quot; ServiceDemo onStartCommand&quot;);
        return super.onStartCommand(intent, flags, startId);
    }

    @Override
    public boolean onUnbind(Intent intent) {
        Log.i(TAG, this.toString() + &quot; ServiceDemo onUnbind&quot;);
        return super.onUnbind(intent);
    }

    @Override
    public void onDestroy() {
        Log.i(TAG, this.toString() + &quot; ServiceDemo onDestroy&quot;);
        super.onDestroy();
    }

}
&lt;!-- android:exported 这个属性用于指示该服务是否能够被其他应用程序组件调用或跟它交互。
     如果设置为true，则能够被调用或交互，否则不能。设置为false时，
     只有同一个应用程序的组件或带有相同用户ID的应用程序才能启动或绑定该服务。--&gt;
&lt;service android:name=&quot;.ServiceDemo&quot; android:exported=&quot;false&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;com.demo.SERVICE_DEMO&quot; /&gt;
        &lt;category android:name=&quot;android.intent.category.default&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/service&gt;

通过Context.startService(Intent)方法启动service或者Context.bindService方法来绑定service


    public class MainActivity extends ActionBarActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        findViewById(R.id.btn_bindService).setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
            bindService(new Intent(ServiceDemo.ACTION), conn, BIND_AUTO_CREATE);
        }
    });

        findViewById(R.id.btn_unbindService).setOnClickListener(new OnClickListener() {
            @Override
        public void onClick(View v) {
        unbindService(conn);
        }
    });

        findViewById(R.id.btn_startService).setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
            startService(new Intent(ServiceDemo.ACTION));
            }
        });

        findViewById(R.id.btn_stopService).setOnClickListener(new OnClickListener() {
        @Override
        public void onClick(View v) {
        stopService(new Intent(ServiceDemo.ACTION));
        }
    });
    }

    ServiceConnection conn = new ServiceConnection() {
        public void onServiceConnected(ComponentName name, IBinder service) {
            Log.i(ServiceDemo.TAG, service.toString() + &quot; onServiceConnected&quot;);
        }
    public void onServiceDisconnected(ComponentName name) {
        Log.i(ServiceDemo.TAG, &quot;onServiceDisconnected&quot;);
    }
    };

    @Override
    protected void onDestroy() {
        super.onDestroy();
    }
}
</code></pre><p>  <img src="http://static.oschina.net/uploads/space/2015/0730/160834_rK7t_1175007.png" alt="此处输入图片的描述"></p>
<blockquote>
<p>日志输出：</p>
</blockquote>
<p><img src="http://static.oschina.net/uploads/space/2015/0730/160949_ye2r_1175007.png" alt="此处输入图片的描述"><br>上面的截图是点击绑定服务时输出的。可以看出，只调用了onCreate方法和onBind方法，当重复点击绑定服务时，没有再输出任何日志，并且不报错。onCreate方法是在第一次创建Service时调用的，而且只调用一次。另外，在绑定服务时，给定了参数BIND_AUTO_CREATE，即当服务不存在时，自动创建，如果服务已经启动了或者创建了，那么只会掉调用onBind方法。<br><img src="http://static.oschina.net/uploads/space/2015/0730/161109_fGYl_1175007.png" alt="此处输入图片的描述"><br>当解除绑定的时，可以看出，Service调用onUnbind和onDestroy销毁了服务。<br><img src="http://static.oschina.net/uploads/space/2015/0730/161604_zRTz_1175007.png" alt="此处输入图片的描述"><br>上面的截图是在多次点击启动服务时输出的。可以看出，在第一次点击时，因为Service还未创建，所以调用了onCreate方法，紧接着调用了onStartCommand和onStart方法。当再次点击启动服务时，仍然调用了onStartCommand和onStart方法，所以，在Service中做任务处理时需要注意这点，因为一个Service可以被重复启动。<br><img src="http://static.oschina.net/uploads/space/2015/0730/161711_V5xw_1175007.png" alt="此处输入图片的描述"><br>当点停止服务的时，Service只是执行onDestroy方法，跟绑定还是有点小区别。<br>这里说一下，平常使用多的是startService方法，可以把一些耗时的任务放到后台去处理，当处理完成后，可以通过广播来通知前台。<br>而onBind方法更多的是结合AIDL来使用，这样一个应用可以通过绑定服务获得的IBinder来拿到后台的接口，进而调用AIDL中定义的方法，进行数据交换等。</p>
<blockquote>
<p>三、Local 与 Remote 服务绑定</p>
</blockquote>
<p>1) Local 服务绑定：Local 服务的绑定较简单，首先在 Service 中我们需要实现 Service 的抽象方法 onBind，并返回一个实现 IBinder 接口的对象。</p>
<p>Service 中的代码：</p>
<pre><code>    public class LocalService extends Service{

    public static final String TAG = &quot;LocalService&quot; ;
    public static final String ACTION = &quot;com.demo.LOCAL_SERVICE&quot;;
    public SimpleBinder sBinder;

    public class SimpleBinder extends Binder{

        public LocalService getService(){
            return LocalService.this;
        }

        public int add(int a, int b){
            return a + b;
        }
    }

    @Override
    public void onCreate() {
    super.onCreate();
    // 创建 SimpleBinder
        sBinder = new SimpleBinder();
    }

    @Override
    public IBinder onBind(Intent intent) {
    // 返回 SimpleBinder 对象
    Log.i(TAG, &quot;LocalService onBind&quot;);
        return sBinder;
    }

    @Override
    public boolean onUnbind(Intent intent) {
    Log.i(TAG, &quot;LocalService onUnbind&quot;);
    return super.onUnbind(intent);
    }

}
&lt;service android:name=&quot;.LocalService&quot; android:exported=&quot;false&quot;&gt;
    &lt;intent-filter&gt;
    &lt;action android:name=&quot;com.demo.LOCAL_SERVICE&quot; /&gt;
    &lt;category android:name=&quot;android.intent.category.default&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/service&gt;
public class LocalActivity extends ActionBarActivity {

    private ServiceConnection sc;
    private boolean isBind;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_local);

    sc = new ServiceConnection() {

            @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            Log.i(LocalService.TAG, &quot;onServiceConnected&quot;);
        LocalService.SimpleBinder sBinder = (LocalService.SimpleBinder)service;
                Log.i(LocalService.TAG, &quot;3 + 5 = &quot; + sBinder.add(3, 5));
        }

            @Override
            public void onServiceDisconnected(ComponentName name) {
                Log.i(LocalService.TAG, &quot; onServiceDisconnected&quot;);
            }
        };

        findViewById(R.id.btn_bindService).setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                bindService(new Intent(LocalService.ACTION), sc, Context.BIND_AUTO_CREATE);
                isBind = true;
            }
        });
        findViewById(R.id.btn_unbindService).setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                if(isBind){
                    unbindService(sc);
                    isBind = false;
                }
            }
        });
    }
}
</code></pre><p>在 Activity 中，我们通过 ServiceConnection 接口来取得建立连接 与 连接意外丢失的回调。bindService有三个参数，第一个是用于区分 Service 的Intent 与 startService 中的 Intent 一致，第二个是实现了 ServiceConnection 接口的对象，最后一个是 flag 标志位。有两个flag，BIND_DEBUG_UNBIND 与 BIND_AUTO_CREATE，前者用于调试（详细内容可以查看javadoc 上面描述的很清楚），后者默认使用。unbindService 解除绑定，参数则为之前创建的 ServiceConnection 接口对象。另外，多次调用 unbindService 来释放相同的连接会抛出异常，因此我创建了一个 boolean 变量来判断是否 unbindService 已经被调用过。</p>
<p>运行结果：<br><img src="http://static.oschina.net/uploads/space/2015/0730/173329_fLfe_1175007.png" alt="此处输入图片的描述"></p>
<p>在绑定服务的时候，需要一个服务连接对象，ServiceConnection，服务一旦连接，就会调用onServiceConnected方法，我们可以在这个方法里面返回我们的本地服务对象，具体看代码；而在服务断开时候会调用onServiceDisconnected方法，我们可以清理一些服务资源。</p>
<p>2) Remote 服务绑定：之前所谈的Service属于Local Service，即Service和Client在同一进程内（即同一application内），Service的生命周期服从进程的生命周期。在实际应用上，有时希望Service作为后台服务，不仅被同一进程内的activity使用，也可被其他进程所使用。</p>
<p>通常每个应用程序都在它自己的进程内运行，但有时需要在进程之间传递对象（IPC通信），你可以通过应用程序UI的方式写个运行在一个不同的进程中的service。在android平台中，一个进程通常不能访问其它进程中的内存区域。所以，他们需要把对象拆分成操作系统能理解的简单形式，以便伪装成对象跨越边界访问。编写这种伪装代码相当的枯燥乏味，好在android为我们提供了AIDL工具可以来做这件事。</p>
<p>AIDL(android接口描述语言)是一个IDL语言，它可以生成一段代码，可以使在一个android设备上运行的两个进程使用内部通信进程进行交互。如果你需要在一个进程中(例如在一个Activity中)访问另一个进程中(例如一个Service)某个对象的方法，你就可以使用AIDL来生成这样的代码来伪装传递各种参数。</p>
<p> <img src="http://static.oschina.net/uploads/space/2015/0802/170432_x9mE_1175007.png" alt="此处输入图片的描述"><br> Android提供AIDL（Android Interface Definition Language）工具帮助IPC之间接口的建立，大大地简化了开发者视图。通过下面的步骤实现client和service之间的通信：<br>1）定义AIDL接口 ，Eclipse将自动为Service建立接口IService<br>2）Client连接Service，连接到IService暴露给Client的Stub，获得stub对象；换句话，Service通过接口中的Stub向client提供服务，在IService中对抽象IService.Stub具体实现。<br>3）Client和Service连接后，Client可向使用本地方法那样，简单地直接调用IService.Stub里面的方法。<br>下面的例子给出client从提供定时计数的Remote Service，称为TestRemoteService，中获得服务的例子。</p>
<p><strong>步骤1：通过AIDL文件定义Service向client提供的接口，ITestRemoteService.aidl文件如下</strong></p>
<pre><code>interface ITestRemoteService {
    int getCounter();
}

我们在src的目录下添加一个ITestRemoteService.aidl文件，语法和java的相同。在这个例子中Service很简单，只提供计数器的值，故在接口中我们定义了int getCounter( )。
</code></pre><p>AIDL文件很简单，Eclipse会根据文件自动生成相关的一个java interface文件，不过没有显示出来，如果直接使用命令行工具会帮助生成java文件。</p>
<p><strong>步骤2：Remote Service的编写，通过onBind()，在client连接时，传递stub对象。 TestRemoteService.java文件如下</strong>：</p>
<pre><code>//Service提供一个定时计数器，采用Runnable的方式实现。
public class TestRemoteService extends Service{
    private Handler serviceHandler = null;
    private int counter = 0;
    private TestCounterTask myTask = new TestCounterTask();

    public void onCreate() {
        super.onCreate();
        showInfo(&quot;remote service onCreate()&quot;);
    }

    public void onDestroy() {
        super.onDestroy();
        serviceHandler.removeCallbacks(myTask); //停止计数器
        serviceHandler = null;
        showInfo(&quot;remote service onDestroy()&quot;);
    }

    public void onStart(Intent intent, int startId) {
       // 开启计数器
        super.onStart(intent, startId);
        serviceHandler=new Handler();
        serviceHandler.postDelayed(myTask, 1000);
        showInfo(&quot;remote service onStart()&quot;);
    }

   //步骤2.1：具体实现接口中暴露给client的Stub，提供一个stub inner class来具体实现。
    private ITestRemoteService.Stub stub= new ITestRemoteService.Stub() {
       //步骤2.1：具体实现AIDL文件中接口的定义的各个方法。
        public int getCounter() throws RemoteException {
            showInfo(&quot;getCounter()&quot;);
            return counter;
        }
    };

//步骤2.2：当client连接时，将触发onBind()，Service向client返回一个stub对象，
//由此client可以通过stub对象来访问Service，本例中通过stub.getCounter()就可以获得计时器的当前计数。
//在这个例子中，我们向所有的client传递同一stub对象。
   public IBinder onBind(Intent arg0) {
   //我们特别跟踪了stub对象的地址，可以在client连接service中看看通过ServiceConnection传递给client
        showInfo(&quot;onBind() &quot; + stub);
        return stub;
   }

    //用Runnable使用定时计数器，每10秒计数器加1。
    private class TestCounterTask implements Runnable{
        public void run() {
            ++ counter;
            serviceHandler.postDelayed(myTask,10000);
            showInfo(&quot;running &quot; + counter);
        }
    }
    //showInfo() 帮助我们进行信息跟踪，更好了解Service的运行情况
    private void showInfo(String s){
        System.out.println(&quot;[&quot; +getClass().getSimpleName()+&quot;@&quot; + Thread.currentThread().getName()+ &quot;] &quot; + s);
    }
}
</code></pre><p><img src="http://static.oschina.net/uploads/space/2015/0802/171454_Lix4_1175007.png" alt="此处输入图片的描述"></p>
<p><strong>步骤3：Client和Service建立连接，获得stub，ServiceTest4.java代码如下</strong></p>
<pre><code>public class ServiceTest4 extends Activity{

    //步骤3.1 定义接口变量
    private ITestRemoteService remoteService = null;
    private boolean isStarted = false;
    //步骤3.1 定义连接变量，实现ServiceConnection接口
    private CounterServiceConnection conn = null;

    protected void onCreate(Bundle savedInstanceState) {
        //5个button分别触发startService( )，stopService( ) ,
        //bindService( ), releaseService( )和invokeService( )，
        //下面两行，一行是显示从Service中获得的计数值，一行显示状态。
    }

    private void startService(){
        Intent i = new Intent();
        //我的这个包里面还有层次，如*.part1、*.part2,etc
        i.setClassName(&quot;com.wei.android.learning&quot;, &quot;com.wei.android.learning.part5.TestRemoteService&quot;);
//和之前的local service一样，通过intent开启Service，触发onCreate()[if Service没有开启]-&gt;onStart()
        startService(i);
        isStarted = true;
        updateServiceStatus();
    }
    private void stopService(){
        Intent i = new Intent();
        i.setClassName(&quot;com.wei.android.learning&quot;,&quot;com.wei.android.learning.part5.TestRemoteService&quot;);
        stopService(i); //触发Service的 onDestroy()[if Service存在]
        isStarted = false;
        updateServiceStatus();
    }
   //步骤3.3：bindService( )通过一个实现ServiceConnection接口的类于Service之间建立连接，
   //注意到里面的参数Context.BIND_AUTO_CREATE，触发onCreate()[if Service不存在] –&gt; onBind().
    private void bindService(){
        if(conn == null){
            conn = new CounterServiceConnection();
            Intent i = new Intent();
            i.setClassName(&quot;com.wei.android.learning&quot;,&quot;com.wei.android.learning.part5.TestRemoteService&quot;);
           bindService(i, conn,Context.BIND_AUTO_CREATE);
            updateServiceStatus();
        }
    }

    private void releaseService(){
        if(conn !=null){
            unbindService(conn); //断开连接，解除绑定
            conn = null;
            updateServiceStatus();
        }
    }
    private void invokeService(){
        if(conn != null){
            try{
            //一旦client成功绑定到Service，就可以直接使用stub中的方法。
                Integer counter =remoteService.getCounter();
                TextView t = (TextView)findViewById(R.id.st4_notApplicable);
                t.setText(&quot;Counter value : &quot; + Integer.toString(counter));
            }catch(RemoteException e){
                Log.e(getClass().getSimpleName(),e.toString());
            }
        }
    }
    //步骤3.2 class CounterServiceConnection实现ServiceConnection接口，
    //需要具体实现里面两个触发onServiceConnected()和onServiceDisconnected()
    private class CounterServiceConnection implements ServiceConnection{
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            // 从连接中获得stub对象，根据我们的跟踪，remoteService就是service中的stub对象
            remoteService = ITestRemoteService.Stub.asInterface(service);
            showInfo(&quot;onServiceConnected()&quot; + remoteService);
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
            remoteService = null;
            updateServiceStatus();
            showInfo(&quot;onServiceDisconnected&quot;);
        }
    }

    private void updateServiceStatus() {
        TextView t = (TextView)findViewById( R.id.st4_serviceStatus);
        t.setText( &quot;Service status: &quot;+(conn == null ? &quot;unbound&quot; : &quot;bound&quot;)+ &quot;,&quot;+ (isStarted ? &quot;started&quot; : &quot;not started&quot;; ));
      }

    private void showInfo(String s){
        System.out.println(&quot;[&quot; +getClass().getSimpleName()+&quot;@&quot; + Thread.currentThread().getName()+ &quot;] &quot; + s);
    }
}
</code></pre><p> <img src="http://static.oschina.net/uploads/space/2015/0802/171402_Rt1I_1175007.png" alt="此处输入图片的描述"></p>
<p> 注意：</p>
<p>Service.onBind如果返回null，则调用 bindService 会启动 Service，但不会连接上 Service，因此 ServiceConnection.onServiceConnected 不会被调用，但你任然需要使用 unbindService 函数断开它，这样 Service 才会停止。</p>
<p>其它：</p>
<p>1、在什么情况下使用 startService 或 bindService 或 同时使用startService 和 bindService</p>
<p>如果你只是想要启动一个后台服务长期进行某项任务那么使用 startService 便可以了。如果你想要与正在运行的 Service 取得联系，那么有两种方法，一种是使用 broadcast ，另外是使用 bindService ，前者的缺点是如果交流较为频繁，容易造成性能上的问题，并且 BroadcastReceiver 本身执行代码的时间是很短的（也许执行到一半，后面的代码便不会执行），而后者则没有这些问题，因此我们肯定选择使用 bindService（这个时候你便同时在使用 startService 和 bindService 了，这在 Activity 中更新 Service 的某些运行状态是相当有用的）。另外如果你的服务只是公开一个远程接口，供连接上的客服端（android 的 Service 是C/S架构）远程调用执行方法。这个时候你可以不让服务一开始就运行，而只用 bindService ，这样在第一次 bindService 的时候才会创建服务的实例运行它，这会节约很多系统资源，特别是如果你的服务是Remote Service，那么该效果会越明显（当然在 Service 创建的时候会花去一定时间，你应当注意到这点）。</p>
<p>2、在 AndroidManifest.xml 里 Service 元素的常见选项</p>
<p>android:name，服务类名</p>
<p>android:label，服务的名字，如果此项不设置，那么默认显示的服务名则为类名</p>
<p>android:icon，服务的图标</p>
<p>android:permission，申明此服务的权限，这意味着只有提供了该权限的应用才能控制或连接此服务</p>
<p>android:process，表示该服务是否运行在另外一个进程，如果设置了此项，那么将会在包名后面加上这段字符串表示另一进程的名字</p>
<p>android:enabled，如果此项设置为 true，那么 Service 将会默认被系统启动，不设置默认此项为 false</p>
<p>android:exported，表示该服务是否能够被其他应用程序所控制或连接，不设置默认此项为 false</p>
<p>3、Service 与 Thread 的区别</p>
<p>很多时候，你可能会问，为什么要用 Service，而不用 Thread 呢，因为用 Thread 是很方便的，比起 Service 也方便多了，下面我详细的来解释一下。</p>
<p>1). Thread：Thread 是程序执行的最小单元，它是分配CPU的基本单位。可以用 Thread 来执行一些异步的操作。</p>
<p>2). Service：Service 是android的一种机制，当它运行的时候如果是Local Service，那么对应的 Service 是运行在主进程的 main 线程上的。如：onCreate，onStart 这些函数在被系统调用的时候都是在主进程的 main 线程上运行的。如果是Remote Service，那么对应的 Service 则是运行在独立进程的 main 线程上。因此请不要把 Service 理解成线程，它跟线程半毛钱的关系都没有！</p>
<p>既然这样，那么我们为什么要用 Service 呢？其实这跟 android 的系统机制有关，我们先拿 Thread 来说。Thread 的运行是独立于 Activity 的，也就是说当一个 Activity 被 finish 之后，如果你没有主动停止 Thread 或者 Thread 里的 run 方法没有执行完毕的话，Thread 也会一直执行。因此这里会出现一个问题：当 Activity 被 finish 之后，你不再持有该 Thread 的引用。另一方面，你没有办法在不同的 Activity 中对同一 Thread 进行控制。</p>
<p>举个例子：如果你的 Thread 需要不停地隔一段时间就要连接服务器做某种同步的话，该 Thread 需要在 Activity 没有start的时候也在运行。这个时候当你 start 一个 Activity 就没有办法在该 Activity 里面控制之前创建的 Thread。因此你便需要创建并启动一个 Service ，在 Service 里面创建、运行并控制该 Thread，这样便解决了该问题（因为任何 Activity 都可以控制同一 Service，而系统也只会创建一个对应 Service 的实例）。</p>
<p>因此你可以把 Service 想象成一种消息服务，而你可以在任何有 Context 的地方调用 Context.startService、Context.stopService、Context.bindService，Context.unbindService，来控制它，你也可以在 Service 里注册 BroadcastReceiver，在其他地方通过发送 broadcast 来控制它，当然这些都是 Thread 做不到的。</p>
<p>4、拥有service的进程具有较高的优先级</p>
<p>官方文档告诉我们，Android系统会尽量保持拥有service的进程运行，只要在该service已经被启动(start)或者客户端连接(bindService)到它。当内存不足时，需要保持，拥有service的进程具有较高的优先级。</p>
<p>1). 如果service正在调用onCreate,onStartCommand或者onDestory方法，那么用于当前service的进程则变为前台进程以避免被killed。</p>
<p>2). 如果当前service已经被启动(start)，拥有它的进程则比那些用户可见的进程优先级低一些，但是比那些不可见的进程更重要，这就意味着service一般不会被killed.</p>
<p>3). 如果客户端已经连接到service (bindService),那么拥有Service的进程则拥有最高的优先级，可以认为service是可见的。</p>
<p>4). 如果service可以使用startForeground(int, Notification)方法来将service设置为前台状态，那么系统就认为是对用户可见的，并不会在内存不足时killed。</p>
<p>如果有其他的应用组件作为Service,Activity等运行在相同的进程中，那么将会增加该进程的重要性。</p>
<p>5、注意事项</p>
<p>Service的onCreate的方法只会被调用一次，就是你无论多少次的startService又 bindService，Service只被创建一次。如果先是bind了，那么start的时候就直接运行Service的onStart方法，如果先是start，那么bind的时候就直接运行onBind方法。如果你先bind上了，就stop不掉了，只能先UnbindService, 再StopService,所以是先start还是先bind行为是有区别的。</p>
<p>Android中的服务和windows中的服务是类似的东西，服务一般没有用户操作界面，它运行于系统中不容易被用户发觉，可以使用它开发如监控之类的 程序。</p>
<p>服务不能自己运行，需要通过调用Context.startService()或Context.bindService()方法启动服务。</p>
<p>这两个方法都可以启动Service，但是它们的使用场合有所不同。使用startService()方法启用服务，调用者与服务之间没有关连，即使调用者退出了，服务仍然运行。使用bindService()方法启用服务，调用者与服务绑定在了一起，调用者一旦退出，服务也就终止，大有“不求同 时生，必须同时死”的特点。</p>
<p>如果打算采用Context.startService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onStart()方法。如果调用startService()方法前服务已经被创建，多次调用startService()方法并不会导致多次 创建服务，但会导致多次调用onStart()方法。采用startService()方法启动的服务，只能调用Context.stopService()方法结 束服务，服务结束时会调用onDestroy()方法。</p>
<p>如果打算采用Context.bindService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onBind()方法。这个时候调用者和服务绑定在一起，调用者退出了，系统就会先调用服务的onUnbind()方法，接着调用onDestroy()方法。如果调用bindService()方法前服务已经被绑定，多次调用bindService()方法并不会导致多次创建服务及绑定(也就是说onCreate()和onBind()方法并不会被多次调用)。</p>
<p>如果调用者希望与正在绑定的服务解除绑定，可以调用unbindService()方法，调用该方法也会导致系统调用服务的 onUnbind()–&gt;onDestroy()方法.</p>
<p>原文地址：<a href="http://aswang.iteye.com/blog/1424309" target="_blank" rel="noopener">http://aswang.iteye.com/blog/1424309</a></p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

            
    
        <a href="http://b.nearby.ren/2016/01/18/service详解/#comments" class="article-comment-link">评论</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-淘汰" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2015/12/17/淘汰/">淘汰</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2015/12/17/淘汰/">
            <time datetime="2015-12-17T01:24:27.000Z" itemprop="datePublished">2015-12-17</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/文字/">文字</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/歌曲/">歌曲</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>陈奕迅 - 淘汰<br>曲 : 周杰伦 词：周杰伦</p>
<p>我说了 所有的谎<br>你全都相信<br>简单的 我爱你<br>你却老不信<br>你书里的剧情<br>我不想上演<br>因为我喜欢 喜剧收尾</p>
<p>我试过 完美放弃<br>的确很踏实<br>醒来了<br>梦散了<br>你我都走散了<br>情歌歌词何必押韵<br>就算我是K歌之王<br>也不见得把 爱情唱得完美</p>
<p>只能说我输了<br>也许是你怕了<br>我们的回忆 没有皱褶<br>你却用离开烫下句点<br>只能说我认了<br>你的不安赢得你信任<br>我却得到你 安慰的淘汰</p>
<p>我试过完美放弃<br>的确很踏实<br>醒来了<br>梦散了<br>你我都走散了<br>情歌歌词何必押韵<br>就算我是K歌之王<br>也不见得把 爱情唱得完美</p>
<p>只能说我输了<br>也许是你怕了<br>我们的回忆 没有皱褶<br>你却用离开烫下句点<br>只能说我认了<br>你的不安赢得你信任<br>我却得到你 安慰的淘汰</p>
<p>只能说我输了<br>也许是你怕了<br>我们的回忆 没有皱褶<br>你却用离开烫下句点<br>只能说我认了<br>你的不安赢得你信任<br>我却得到你 安慰的淘汰</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

            
    
        <a href="http://b.nearby.ren/2015/12/17/淘汰/#comments" class="article-comment-link">评论</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-offce001" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2015/12/14/offce001/">offce 001</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2015/12/14/offce001/">
            <time datetime="2015-12-14T04:12:55.000Z" itemprop="datePublished">2015-12-14</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/offce/">offce</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/offce/">offce</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>View的绘制流程、Activity、Window、View的关系<br>Activity启动时创建Window、ViewRoot并建立关联，流程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class ActivityThread &#123;</span><br><span class="line">  // startActivity最终会调用到这里</span><br><span class="line">  fun handleLaunchActivity()&#123;</span><br><span class="line">	// 1. performLaunchActivity() 创建activity</span><br><span class="line">    // 2. activity.attach() 内部创建了PhoneWindow</span><br><span class="line">    // 3. activity.onCreate() -&gt; setContentView，实际调用window的对应方法，创建DecorView </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  fun handleResumeActivity()&#123;</span><br><span class="line">    // 1. activity.onResume()</span><br><span class="line">    // 2. 获取activity的window对象，添加DecorView到WindowManagerGlobal中</span><br><span class="line">    // 3. WindowManagerGlobal.addView(DecorView)时，创建了ViewRootImpl，所有view绘制的工作都是</span><br><span class="line">    //		ViewRootImpl来调度，在这里才建立了ViewRootImpl和View的关联</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ViewRoot &#123;</span><br><span class="line">// ViewRoot添加view后，会执行ViewRoot.requestLayout</span><br><span class="line">// scheduleTraversals -&gt; 在消息队列中插入一个同步消息屏障,保证UI优先绘制 </span><br><span class="line">//  -&gt; 通过choreographer提交绘制任务，同时向底层请求sync信号，</span><br><span class="line">//  -&gt; 在下一次信号到来时JNI回调doTraversal，并移除屏障消息</span><br><span class="line">//  -&gt; doTraversal中调用了performMeasure、performLayout和performDraw进行测量、布局和绘制流程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>MeasureSpec是一个32位int值，高2位表示测量模式，后30位表示在该模式下的测量值，一个view的MeasureSpec由自己的LayoutParams和父View的MeasureSpec共同决定。测量过程实际是递归的测量子view后再设置自己的尺寸。</p>
<h1 id="onCreate、onResume中能否获取到View的宽高，为什么？"><a href="#onCreate、onResume中能否获取到View的宽高，为什么？" class="headerlink" title="onCreate、onResume中能否获取到View的宽高，为什么？"></a>onCreate、onResume中能否获取到View的宽高，为什么？</h1><p>由于View的measure过程和Activity的生命周期方法不是同步执行的，如果View还没有测量完毕，那么获得的宽/高就是0。所以在onCreate、onStart、onResume中均无法正确得到某个View的宽高信息。<br>解决方式如下：</p>
<p>1.view.post(runnable)，注意这里handler.post(runnable)是不行的，View.post会先判断attachInfo是否为空，如果为空就放到一个等待执行的队列中，等待View被添加（dispatchAttachedToWindow）之后才执行，这时测量已经完毕了，如果不为空，表示View已经被添加，就调用attachInfo中的Handler来post任务，所以是一定能获取到的。注意api23以下和以上的逻辑不一样：</p>
<p>Api23以下：调用的ViewRootImpl.getRunQueue().post()，执行时机是doTraversa()中，这个方法又是在下一个同步信号来的时候调用的，参考屏幕刷新机制。</p>
<p>Api23以上：调用的是getRunQueue().post() ，它的执行时机是View被添加之后执行，如果View只是创建出来没有被添加，那将一直得不到执行。</p>
<p>2.使用ViewTreeObserver</p>
<h1 id="卡顿原理、屏幕刷新机制、卡顿监控"><a href="#卡顿原理、屏幕刷新机制、卡顿监控" class="headerlink" title="卡顿原理、屏幕刷新机制、卡顿监控"></a>卡顿原理、屏幕刷新机制、卡顿监控</h1><h1 id="卡顿的根本原因：view在16ms内不能完成绘制造成掉帧，常见造成掉帧的原因又有："><a href="#卡顿的根本原因：view在16ms内不能完成绘制造成掉帧，常见造成掉帧的原因又有：" class="headerlink" title="卡顿的根本原因：view在16ms内不能完成绘制造成掉帧，常见造成掉帧的原因又有："></a>卡顿的根本原因：view在16ms内不能完成绘制造成掉帧，常见造成掉帧的原因又有：</h1><p>1.主线程有耗时操作（合理使用线程来执行耗时任务）<br>2.View本身太复杂、嵌套过多导致绘制超过16ms（优化View的层级、合理使用include、ViewStub标签）<br>3.内存抖动造成频繁GC，例如循环内部创建对象，onDraw中创建对象等。（优化内存泄漏、对一些需要频繁创建的对象采用对象池技术）</p>
<h1 id="屏幕刷新机制："><a href="#屏幕刷新机制：" class="headerlink" title="屏幕刷新机制："></a>屏幕刷新机制：</h1><p>1.基于handler消息队列，如BlockCanary，handler分发消息前后都会打印日志，可以自定义Printer，计算Looper两次获取消息的时间差，如果时间太长就说明Handler处理时间过长，直接把堆栈信息打印出来，就可以定位到耗时代码<br>2.代码插桩，在方法的前后插入计时代码来监控执行时间，缺点是包增大，无法监控系统方法，并且需要过滤简单方法<br>3.循环插入空消息到消息队列，监控这个消息的处理时间，例如每隔1秒插入一条空消息，如果这条消息处理时间间隔大于一定时间，则认为发生了卡顿</p>
<h1 id="RxJava的原理"><a href="#RxJava的原理" class="headerlink" title="RxJava的原理"></a>RxJava的原理</h1><p>Rxjava每个操作符会生成一个新的Observable,同时持有上游事件源和下游Observer，最终在subscribeActual中实现自己的操作逻辑，并连接上下游。<br>Rxjava有点像观察者模式和责任链模式的结合，普通的观察者模式一般是被观察者通知多个观察者，而Rxjava则是被观察者通知第一个Obsever,接下来Observer依次通知下一个节点的Observer，形成一个“观察链”，将观察者模式进行了一种类似链式的变换，每个节点又会执行它不同的“职责”。</p>
<p>1.SubscribeOn节点在订阅的时候，将它的上游节点的subscribe操作，以runnable的形式交给调度器在执行，在io调度器就是一个线程池，他影响的是事件源的发射行为，如果多次subscribeOn相当后一次subscribeOn把上一次subscribeOn行为在线程池里执行了一次，最终就只有最上边的一个起作用；<br>2.observeOn会将它下游的Observer放到切换的线程中执行，因此observeOn影响的是它的下游，多次调用影响的是这次到下一次observeOn之间的代码；</p>
<h1 id="Rxjava中调度器"><a href="#Rxjava中调度器" class="headerlink" title="Rxjava中调度器"></a>Rxjava中调度器</h1><p>Schedulers.io()：无边界线程池作为支撑的一个Scheduler，线程可以无限增长，它适用于非CPU密集的I/O工作，比如访问文件系统、执行网络调用、访问数据库等<br>Schedulers.computation()：用于执行CPU密集的工作，比如处理大规模的数据集、图像处理等等。它由一个有界的线程池作为支撑，线程的最大数量就是可用的处理器数量<br>Schedulers.newThread()：这个Scheduler 每次都会创建一个全新的线程来完成一组工作<br><strong>Schedulers.single()：</strong>只有一个线程作为支撑，只能按照有序的方式执行任务<br><strong>Schedulers.from(Executor executor)</strong>我们可以使用它创建自定义的Scheduler<br>AndroidSchedulers.mainThread()：Android主线程调度器</p>
<h1 id="事件分发机制"><a href="#事件分发机制" class="headerlink" title="事件分发机制"></a>事件分发机制</h1><p>事件传递的顺序：Activity-&gt;Window-&gt;DecorView</p>
<p>dispatchTouchEvent中：</p>
<p>1.判断是否需要拦截事件的标记intercepted<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 如果是down事件或者mFirstTouchTarget不为空</span><br><span class="line">if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123;</span><br><span class="line">  final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;</span><br><span class="line">  if (!disallowIntercept) &#123;</span><br><span class="line">    // 判断disallowIntercept标记</span><br><span class="line">    // 如果允许拦截则调用onInterceptTouchEvent</span><br><span class="line">    intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 有disallowIntercept标记，不拦截</span><br><span class="line">    intercepted = false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // 已有mFirstTouchTarget或者不是down时间，直接拦截</span><br><span class="line">  intercepted = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.尝试分发事件：如果第一步不需要拦截，并且不是cancel状态，分发给子view</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">	// 遍历子view，判断坐标是否在view范围内并且view没有处于动画状态</span><br><span class="line">  // 满足条件则交给子view的dispatchTouchEvent来处理</span><br><span class="line">  // 如果子view处理了事件，则把子view赋值给mFirstTouchTarget</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.再次分发事件：判断firstTouchTarget是否为空，如果为空表示没有子view处理事件，则间接的交给自己的onTouchEvent来处理，为空则直接交给firstTouchTarget处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (mFirstTouchTarget == null) &#123;</span><br><span class="line">  // 没有子view处理事件，交给自己的onTouchEvent处理</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // 直接交给mFirstTouchTarget处理后续事件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.<strong>onTouchListener ：</strong>如果有onTouchListener则优先交给onTouchListener处理，onTouchListener返回true则onTouchEvent将不会调用<br>5.cancel事件：父视图先不拦截，然后在 MOVE 事件中重新拦截，此时子 View 会接收到一个 CANCEL 事件，例如move出子view范围，或者scrollView中事件首先传递给子view，如果滑动则会被拦截。</p>
<h1 id="LeakCanary原理"><a href="#LeakCanary原理" class="headerlink" title="LeakCanary原理"></a>LeakCanary原理</h1><p>首先java的四种引用，强、软、弱、虚四种引用，配合ReferenceQueue使用，在构造弱引用时传入ReferenceQueue，在垃圾回收之前，会将引用放入队列中，可以通过队列中是否有对象的引用来判断对象是否被回收；</p>
<p>具体就是在Application中注册ActivityLifecycleCallbacks监听activity的生命周期，在onDestory的时候，新建一个弱引用传入队列，在线程空闲的时候，会尝试清除队列的弱引用，如果成功则没有发生泄漏，如果失败，则尝试GC，GC之后再<br>次尝试清除弱引用，如果失败则发生了内存泄漏</p>
<p>Fragment也类似，在Activity创建时获取到FragmentManager注册一个fragmentLifecycleCallbacks，然后观察fragment；</p>
<h1 id="Retrofit原理"><a href="#Retrofit原理" class="headerlink" title="Retrofit原理"></a>Retrofit原理</h1><p>核心原理：在createService时，创建一个Api接口的动态代理，在loadServiceMethod方法先查找缓存，没有找到则解析Api接口，解析包括两部分，一个是方法上的注解，包括url、Header、请求参数等，第二个是方法的返回类型和参数类型，也就是CallAdapter和ConverAdapter</p>
<p>CallAdapter用于把结果适配成Rxjava、kotlin协程等返回类型</p>
<p>ConverAdapter用于把参数转化为json或者其他格式传输。</p>
<p>loadServiceMethod完毕后，实际上是把请求组装成一个OkHttpCall，用okhttp来进行具体的请求。</p>
<h1 id="OkHttp原理"><a href="#OkHttp原理" class="headerlink" title="OkHttp原理"></a>OkHttp原理</h1><p>优点：连接池技术复用连接，可以降低延迟，无缝支持gzip减少数据量，支持http2以及SPDY多路复用技术</p>
<p>责任链设计模式：用来处理相关事务责任的一条执行链，执行链上有多个节点，每个节点都有机会（条件匹配）处理请求事务，如果某个节点处理完了就可以根据实际业务需求传递给下一个节点继续处理或者返回处理完毕</p>
<h1 id="请求流程："><a href="#请求流程：" class="headerlink" title="请求流程："></a>请求流程：</h1><p>1.构建request<br>2.通过dispatcher执行请求，dispatcher内部包含三个队列：同步请求队列、异步等待队列和异步执行队列，对于同步请求，直接添加到同步请求队列执行，异步请求则添加到等待队列中，然后判断请求数是否大于最大请求数、以及同一个主机的最大请求数，如果可以执行，则提升到执行队列进行执行<br>3.无论是同步请求还是异步请求，最终都调用到getResponseWithInterceptorChain方法，核心就是拦截器链，包含了7大拦截器，分别负责不同的功能，每一个拦截器都可以自己处理请求，然后直接返回或者交给下一节点来处理。</p>
<pre><code>自定义拦截器
RetryAndFollowUpInterceptor：重试和重定向拦截器
BridgeInterceptor：用来设置一些必要的header
CacheInterceptor：处理缓存
ConnectInterceptor：负责建立服务器连接，优先从连接池中找到可用连接(soket连接是否可用，是否超时等，如不可用则会从连接池中移除)，否则打开一个新的连接
自定义网络拦截器
CallServerInterceptor：最后一个拦截器，用于真正发送网络请求，返回response
</code></pre><h1 id="为什么要组件化，怎么实现？了解的路由框架"><a href="#为什么要组件化，怎么实现？了解的路由框架" class="headerlink" title="为什么要组件化，怎么实现？了解的路由框架"></a>为什么要组件化，怎么实现？了解的路由框架</h1><p>痛点：在业务开发中，各个业务模块依赖关系复杂，耦合严重，造成app编译缓慢、不能并行开发、组件复用性不高的问题。通过组件化改造，可以对各个模块进行了业务隔离，使模块可以单独编译运行，降低耦合度，提高了开发和调试效率。</p>
<h2 id="组件拆分："><a href="#组件拆分：" class="headerlink" title="组件拆分："></a>组件拆分：</h2><p>应用入口：一个空壳app，提供应用的启动页面</p>
<p>支撑业务组件：网络请求、图片加载等一些支撑服务</p>
<p>通用业务模块：例如支付、推送、地图等sdk，封装后对外提供调用接口</p>
<p>应用业务组件：具体的业务，可以提出来作为一个单独应用的功能模块，两两之间不互相依赖</p>
<h2 id="模块间的通信，需要引入路由框架，主流路由框架大概分为两种"><a href="#模块间的通信，需要引入路由框架，主流路由框架大概分为两种" class="headerlink" title="模块间的通信，需要引入路由框架，主流路由框架大概分为两种"></a>模块间的通信，需要引入路由框架，主流路由框架大概分为两种</h2><p>ARouter：路由表+接口下沉的方式，在编译期间通过注解处理器扫描目标类，然后解析参数生成路由表，<br>模块服务通过接口下沉的方式，把接口定义在公共库中，具体实现类在业务模块中，在编译时通过扫描字节码发现实现类，然后通过ASM等字节码修改技术完成服务的注册；</p>
<p>CC：组件总线的方式，类似于EventBus发送消息一样，直接找到目标组件，发送一条指令执行对应操作，<br>通过gradle的Transform API:在编译时(dex/proguard之前)扫描当前要打包到apk中的所有类 ，然后通过ASM技术修改字节码，生成代码完成组件的注册；</p>
<h1 id="android优化的数据结构：SparseArray、ArrayMap"><a href="#android优化的数据结构：SparseArray、ArrayMap" class="headerlink" title="android优化的数据结构：SparseArray、ArrayMap"></a>android优化的数据结构：SparseArray、ArrayMap</h1><p>SparseArray的key只能为int，双列数组结构，优化了自动装箱的过程，并且会自动排序，查找采用二分查找，在数据量不大的情况下效率高</p>
<p>ArrayMap和SparseArray类似，但是key可以是对象，存储的时候存储通过key的hash值排序，也采用二分查找；</p>
<h1 id="进程间通信的方式"><a href="#进程间通信的方式" class="headerlink" title="进程间通信的方式"></a>进程间通信的方式</h1><p>1.广播</p>
<p>2.Messenger，封装的Binder，可以执行简单的串行通信。</p>
<p>3.ContentProvider，适用于进程间的数据共享，可以进行操作权限的控制，如数据库的读写等。</p>
<p>4.Socket，适用于网络通信，用于传输原始的字节流，两次拷贝、效率低于binder</p>
<p>5.Binder，适用于复杂的进程通信，功能强大，CS架构，底层基于内存映射，只进行一次拷贝，所以效率高，可以验证通信的进程id，所以比socket更安全。</p>
<h1 id="AIDL和Binder机制"><a href="#AIDL和Binder机制" class="headerlink" title="AIDL和Binder机制"></a>AIDL和Binder机制</h1><p>AIDL实际上是一套快速实现Binder通信的工具，通过定义AIDL接口，系统会自动生成一个类实现IInterface接口，内部包含Stub和Proxy两个内部类。服务端继承Stub提供服务。</p>
<h2 id="关键类和方法"><a href="#关键类和方法" class="headerlink" title="关键类和方法"></a>关键类和方法</h2><p>Stub：服务端通过继承Stub，实现定义的接口来提供服务</p>
<p>Proxy：服务端对象的本地代理，客户端通过它来间接调用服务端接口的方法</p>
<p>asInterface：客户端调用，将binder对象转化为AIDL接口类型对象，如果和服务端在同一进程，返回Stub对象本身，否则返回Stub.proxy代理对象</p>
<p>asBinder：返回binder对象</p>
<p>onTransact：运行在服务端binder线程池，客户端请求时，远程请求会被系统封装后交给此方法处理</p>
<p>transact：运行在客户端，客户端发起请求时线程挂起，调用到服务端onTransact，等待其返回后才继续执行</p>
<h1 id="Binder机制"><a href="#Binder机制" class="headerlink" title="Binder机制"></a>Binder机制</h1><p>基于C/S架构，包括Server、Client、ServiceManager和Binder驱动，其中Binder驱动运行在内核空间，其他的运行在用户空间</p>
<p>ServiceManager负责服务管理，服务端向ServiceManager注册后，客户端可以向ServiceManager查询获取到目标服务的引用</p>
<p>Binder驱动：负责进程之间的Binder通信的建立，基于内存映射技术，传统的通信方式需要将数据从用户空间拷贝到内核空间，然后从内核空间拷贝到目标进程的用户空间，需要两次拷贝，Binder驱动可以建立用户空间内存和内核空间内存的一个映射，</p>
<p>只需要一次拷贝，非常高效。</p>
<h1 id="kotlin的扩展方法是怎么实现的，inline关键字的作用"><a href="#kotlin的扩展方法是怎么实现的，inline关键字的作用" class="headerlink" title="kotlin的扩展方法是怎么实现的，inline关键字的作用"></a>kotlin的扩展方法是怎么实现的，inline关键字的作用</h1><p>扩展方法编译成java后，实际上是一个 public static的静态方法，传入了对象实例和参数<br>Inline关键字修饰的函数是内联函数，用于优化函数调用的压栈操作，相当于在编译期间把内联函数的代码拷贝到函数调用处，可以提升性能，但是增加了代码量</p>
<h1 id="Handler机制"><a href="#Handler机制" class="headerlink" title="Handler机制"></a>Handler机制</h1><h2 id="关键类："><a href="#关键类：" class="headerlink" title="关键类："></a>关键类：</h2><p>Handler：用于发送消息和处理消息，发送消息就是将消息对象放入当前线程的MessageQueue中，然后Looper轮询到消息后交给自己处理，构造时需要传入Looper或者自动获取当前线程的Looper</p>
<p>Looper：轮询器，一个线程只能有一个Looper，用于从消息队列中轮询消息，然后交给对应的Handler处理</p>
<p>MessageQueue：消息队列，是一个阻塞队列，当没有消息是线程会被阻塞，等待有消息时唤醒线程</p>
<p>Message：消息对象，采用了对象池技术，可以避免对象的频繁创建开销</p>
<h1 id="消息的发送和轮询"><a href="#消息的发送和轮询" class="headerlink" title="消息的发送和轮询"></a>消息的发送和轮询</h1><p>发送消息：最终都会调用MessageQueue的enqueueMessage中，如果队列中没有消息或者消息的发送时间小于第一个消息，则直接放入队列头部，否则则根据时间插入到队列中的合适位置，同时会刷新needWeak标记，然后判断needWeak，如果需要唤醒，调用naviteWeak唤醒Looper。</p>
<p>获取消息：核心方法为MessageQueue的next，首先调用nativePollOnce，这个方法是一个native阻塞方法（通过监控文件描述符的io操作来实现），新消息放入队列时，会调用naviteWeak来唤醒。唤醒之后，如果是消息屏障就先处理异步消息，否则判断消息执行时间是否到达来返回消息或者进入下一个循环继续阻塞。</p>
<p>IdleHandler：在消息队列空闲的时候，会尝试执行IdleHandler的任务</p>
<p>消息屏障机制：当messageQueue取出屏障消息时，会开启循环，找到下一个异步消息执行，相当于阻塞了同步消息而优先执行异步消息，Android中所有UI绘制都是异步消息，可以保证UI绘制任务优先执行。</p>
<h1 id="postDelay怎么保证消息的顺序"><a href="#postDelay怎么保证消息的顺序" class="headerlink" title="postDelay怎么保证消息的顺序"></a>postDelay怎么保证消息的顺序</h1><p>发送消息时会对消息队列按执行时间进行排序，如果没有消息或者当前消息执行时间小于队列的第一条消息，则直接插入到表头，否则会插入到合适的位置，保证delay时间长的不会阻塞住时间短的。</p>
<h1 id="Activity启动流程"><a href="#Activity启动流程" class="headerlink" title="Activity启动流程"></a>Activity启动流程</h1><p>1.Luancher 进程通过binder向AMS发起startActivity请求<br>2.AMS收到请求， ActivityStarter解析flag，启动模式等，ActivityStack处理activity栈<br>3.然后AMS通过socket调用到Zygote，fork新的app进程<br>4.app进程创建后，再通过binder向AMS发起attachApplication请求<br>5.AMS通过binder调用发送scheduleLaunchActivity到app进程<br>6.APP进程的binder线程ApplicationThread接收到请求，通过handler发送LAUNCH_ACTIVITY消息到主线程<br>7.ActivityThread接收到消息，执行到handleLaunchActivity，开始Activity的生命周期<br><img src="/2015/12/14/offce001/../../../../images/a3aed8572f104535a3b0e679ea8c4cd9_tplv-k3u1fbpfcp-zoom-1.png" alt="Alt text"><br>应用第一次启动时，zygote进程fork出应用进程后，AMS会保存一个ProcessRecord信息（包名+进程uid），下一次启动判断这个ProcessRecord已经存在的话，就不会再新建进程，这就属于应用内打开Activity的过程了</p>
<h1 id="APK打包流程"><a href="#APK打包流程" class="headerlink" title="APK打包流程"></a>APK打包流程</h1><p><img src="/2015/12/14/offce001/../../../../images/4689f854f716495ea598a49d6ddac2b0_tplv-k3u1fbpfcp-zoom-1.png" alt="Alt text"></p>
<p>1.打包资源文件，生成R.java文件<br>2.处理aidl文件，生成相应的Java文件<br>3.编译项目源代码，生成class文件（所有的Java代码，包括R.java和.aidl文件）<br>4.转换所有的class文件，生成classes.dex文件<br>5.打包生成APK文件<br>6.对APK文件进行签名<br>7.对签名后的APK文件进行对齐处理。对齐的主要过程是将APK包中所有的资源文件距离文件起始偏移为4字节整数倍，这样通过内存映射访问apk文件时的速度会更快。对齐的作用就是减少运行时内存的使用</p>
<h1 id="APK安装流程："><a href="#APK安装流程：" class="headerlink" title="APK安装流程："></a>APK安装流程：</h1><p>1.拷贝阶段：通过PMS通过handler发送一个安装消息，包含一些安装的参数，PackageHandler收到消息后通过隐式intent绑定到拷贝的service。检查apk安装路径，包的状态，然后拷贝至/data/app包名下<br>2.装载阶段：installPackageLI，PackageParser解析AndroidManifest文件，解析四大组件等信息<br>3.验证apk的签名信息<br>4.执行 dex 优化，实际为 dex2oat 操作，用来将 apk 中的 dex 文件转换为 oat 文件<br>5.安装apk，创建data目录，安装成功则更新权限等信息<br>6.发送成功广播，安装失败则删除安装包和缓存</p>
<h1 id="Android系统启动流程"><a href="#Android系统启动流程" class="headerlink" title="Android系统启动流程"></a>Android系统启动流程</h1><p>1.开机加载BootLoader，加载Linux内核<br>2.启动Init进程<br>3.读取init.rc配置文件，启动几个关键进程，包括Zygote、ServiceManager、SurfaceFlinger和MediaServer<br>4.zygote进程启动java runntime，然后fork出sytem_server进程<br>5.sytem_server启动AMS、WMS、电源管理、等等系统服务，并通过Binder注册到ServiceManager。<br>6.启动Launcher显示桌面<br><img src="/2015/12/14/offce001/../../../../images/96bd5c17c1374385971a2ad840d964bc_tplv-k3u1fbpfcp-zoom-1.png" alt="Alt text"></p>
<h1 id="Webview的漏洞"><a href="#Webview的漏洞" class="headerlink" title="Webview的漏洞"></a>Webview的漏洞</h1><p>1.4.2版本的addJavascriptInterface 造成的远程代码执行漏洞，当JS拿到Android这个对象后，就可以调用Android对象中所有的方法，包括系统类（java.lang.Runtime 类），从而执行任意代码</p>
<pre><code>4.2版本以上通过对调用的方法添加JavascriptInterface注解避免漏洞
4.2以下采用url拦截或者js弹窗拦截的方式进行交互，不能采用对象映射
</code></pre><p>2.密码明文存储<br>3.域控制不严问题，允许导出的WebActivity未关闭file协议，可以外部启动并加载恶意file协议的文件，从而访问私有文件，所以不需要使用file协议的，需要关闭</p>
<h1 id="Dalvik与ART的区别"><a href="#Dalvik与ART的区别" class="headerlink" title="Dalvik与ART的区别"></a>Dalvik与ART的区别</h1><p>1.Dalvik：即时编译，应用每次运行都需要通过即时编译器（JIT）将字节码转换为机器码，所以运行效率相对ART较低。由于不需要预编译，所以安装过程较快<br>2.ART ：应用在第一次安装的时候，字节码就会预编译（AOT）成机器码，这样的话，虽然设备和应用的首次启动（安装慢了）会变慢，但是以后每次启动执行的时候，都可以直接运行，因此运行效率会提高<br>3.ART占用空间比Dalvik大（字节码变为机器码之后，可能会增加10%-20%）<br>4.预编译也可以明显改善电池续航，从而减少了 CPU 的使用频率，降低了能耗。</p>
<h1 id="热修复和插件化原理"><a href="#热修复和插件化原理" class="headerlink" title="热修复和插件化原理"></a>热修复和插件化原理</h1><p>java类加载机制</p>
<p>双亲委托机制：如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载</p>
<p>Java的类加载器分为：根加载器（加载java核心类）、扩展类加载器（加载jre扩展目录）、应用类加载器（加载classPath指定目录的类，自定义类加载器一般继承此加载器）</p>
<p>Android的类加载器：根加载器、BaseDexClassLoader、PathClassLoader（加载安装到系统的APK）、DexClassLoader（加载指定目录的dex和apk）</p>
<h1 id="热修复和插件化的区别"><a href="#热修复和插件化的区别" class="headerlink" title="热修复和插件化的区别"></a>热修复和插件化的区别</h1><p>热修复：替换bug的类，需要把修复类抢先于bug类进行加载，让bug类得不到加载。通过反射修改DexClassLoader中DexPathList的dexElements数组，将需要加载的dex添加到数组前面。</p>
<p>插件化：运行未安装的插件apk的代码，不涉及到抢先加载，只需要将dex加载到dexElements中</p>
<h1 id="热修复的CLASS-ISPREVERIFIED问题"><a href="#热修复的CLASS-ISPREVERIFIED问题" class="headerlink" title="热修复的CLASS_ISPREVERIFIED问题"></a>热修复的CLASS_ISPREVERIFIED问题</h1><p>热修复是需要修复有bug的类，所以需要把dex放在数组的前端抢先加载补丁类，在虚拟机启动的时候，在verify选项被打开的时候，如果static方法、private方法、构造函数等，其中直接引用到的类都在同一个dex文件中，那么该类就会被打上CLASS_ISPREVERIFIED标志，且一旦类被打上CLASS_ISPREVERIFIED标志其他dex就不能再去替换这个类。<br>​        为了阻止类被打上CLASS_ISPREVERIFIED标志，先将一个预备好的hack.dex加入到dexElements的第一项，让后面的dex的所有类都引用hack.dex其中的一个类。</p>
<h1 id="常见热修复框架"><a href="#常见热修复框架" class="headerlink" title="常见热修复框架"></a>常见热修复框架</h1><p>Tinker实际上是类加载方案的升级，它增加了dex的差分算法，再将差分dex与apk中的classex.dex做合并，在运行bug类之前抢先加载补丁。</p>
<p>tinker差分算法：dexDiff , 新旧dex先排序，然后定义两个指针依次往下挪，如果old&gt;new，则一定是新增，如果old&lt;\new，则是删除，如果相等，则索引可能不同，需要记录索引的变化，最后如果相同的索引既有删除又有新增，则优化为replace操作。资源差分则采用BSDiff。</p>
<p>美团Robust，Instant Run方案，用代码插桩的方式，在每个方法中插入一段开关代码，如果需要修复，则走入if判断，执行补丁中的同名类的同名方法</p>
<h1 id="插件化方案"><a href="#插件化方案" class="headerlink" title="插件化方案"></a>插件化方案</h1><p>插件化主要是加载新的功能模块，最主要的功能除了加载类，还需要加载资源和生命周期的管理。</p>
<p>资源加载：通过反射AssetManager ，将资源所在路径添加到AssetManager的path中，然后创建一个Resource，hook住activity替换mResources实现资源的访问。具体分为两种：</p>
<p>1.合并式：插件资源合并到主工程，插件和主工程可以直接访问资源，合并资源会造成资源id冲突，所以需要修改aapt源码，id格式为0xPPTTNNNN，在编译期修改高两位PP段，不同插件使用不同的PP段标识。<br>修改resources.arsc文件，该文件列出了资源id到具体资源路径的映射，相当于一个索引。</p>
<p>2.独立式：插件只访问插件内部的资源，不能共享，也不会冲突。</p>
<p><strong>生命周期的管理：</strong>没有在清单文件中注册过的Activity不能启动，现在的主流做法是预留各种启动模式的代理Activity占坑，然后通过hook住mInstrumentation对象，在启动插件Activity时替换intent为代理的Activity，从而绕过AMS的验证，系统以为是启动的代理Activity，然后真正启动时，需要还原原先的Intent，启动插件Activity，同时hook替换mResources，这样就实现了生命周期管理</p>
<p>#VirtualApk原理<br>如何加载插件类：（类加载机制）<br>插件创建ClassLoader，父类加载器是宿主的classloader，这样插件可以反射访问到宿主的类。</p>
<p>然后判断COMBINE_CLASSLOADER标记，如果COMBINE_CLASSLOADER为true，则会把dex插入到父类加载器的elements后边，使宿主可以访问插件的类。如果为false表示宿主与插件隔离，宿主不能访问插件。不论true或false，插件都可以访问宿主。</p>
<p>DroidPlugin是采用隔离模式，插件的classloader的父类加载器是BootClassLoader，所以相互都不能访问。</p>
<h1 id="如何加载资源："><a href="#如何加载资源：" class="headerlink" title="如何加载资源："></a>如何加载资源：</h1><p>1.COMBINE_CLASSLOADER为true：把插件资源添加到宿主Resources的AssetsManager的资源路径中去。<br>编译时过滤宿主和插件中的重复资源，然后修改R和资源表文件，让插件中只保留新的资源。<br>存在的问题：</p>
<p>2.宿主和插件开发可能是并行的，过滤资源时候如果依赖的是1.0的宿主，在1.1中资源发生了变化，插件就会找不到资源，滴滴是让public.xml让宿主资源id不可变来实现。<br>如果宿主和插件有相同名字的资源，例如都有一个about字符串，由于资源过滤，插件的会被过滤掉。</p>
<h1 id="activity的启动："><a href="#activity的启动：" class="headerlink" title="activity的启动："></a>activity的启动：</h1><p>hook系统instrumentation，判断如果启动的是插件的类，则通过预埋的activity绕过ams对activity的验证，然后在真正启动activity的时候，还原intent来启动目标类，这样目标类就有正常的生命周期了</p>
<h1 id="service的启动："><a href="#service的启动：" class="headerlink" title="service的启动："></a>service的启动：</h1><p>hook系统ActivityManager，创建一个动态代理来替换系统中的单例对象，实际上启动LocalService来代理目标服务的生命周期。</p>
<h1 id="广播："><a href="#广播：" class="headerlink" title="广播："></a>广播：</h1><p>解析清单文件，把注册的静态广播转换为动态广播。</p>
<p>启动activity时的问题</p>
<p>在创建插件的ClassLoader时，有一个COMBINE_CLASSLOADER标记用来设置是否要讲插件的dex插入到宿主的dex数组中，让宿主可以访问插件的类。COMBINE_CLASSLOADER标记为false时，宿主不能访问到插件类<br>源码instrumentation中handleMessage处理启动activity时，给intent的extras设置了宿主的类加载器，如果extra中有一个插件中才有的序列化对象，读取extra时反序列化会出错，就会抛出找不到类异常。到现在版本仍未解决。<br>解决方案：直接用一个新的intent包装原始的intent来替换，intent是parcelable的。</p>
<h1 id="RecyclerView缓存"><a href="#RecyclerView缓存" class="headerlink" title="RecyclerView缓存"></a>RecyclerView缓存</h1><p>1.mAttachedScrap和mChangedScrap，用于缓存屏幕内的ViewHolder，例如下拉刷新后，屏幕内的ViewHolder需要刷新数据<br>2.mCachedViews，移除屏幕之外的，默认缓存两个，因为接下来可能马上往回滑动，再次使用到<br>3.ViewCacheExtension，预留的一个缓存扩展，暂时没有用到<br>4.RecycledViewPool，缓存屏幕外的 ViewHolder，需要重新绑定数据</p>
<h1 id="RecyclerView-缓存结构，RecyclerView预取，RecyclerView局部刷新"><a href="#RecyclerView-缓存结构，RecyclerView预取，RecyclerView局部刷新" class="headerlink" title="RecyclerView 缓存结构，RecyclerView预取，RecyclerView局部刷新"></a>RecyclerView 缓存结构，RecyclerView预取，RecyclerView局部刷新</h1><ul>
<li>Scrap：对应ListView 的Active View，就是屏幕内的缓存数据，就是相当于换了个名字，可以直接拿来复用</li>
<li>Cache ： 刚刚移出屏幕的缓存数据</li>
<li>ViewCacheExtension：是google留给开发者自己来自定义缓存的</li>
<li>RecycledViewPool：回收池，最重要<h1 id="答：四级缓存，有一个自定义的不用"><a href="#答：四级缓存，有一个自定义的不用" class="headerlink" title="答：四级缓存，有一个自定义的不用"></a>答：四级缓存，有一个自定义的不用</h1></li>
<li>局部刷新：notifyPositon或者nofiyview实现，可以执行动画</li>
</ul>
<h1 id="AsyncTask原理和缺陷"><a href="#AsyncTask原理和缺陷" class="headerlink" title="AsyncTask原理和缺陷"></a>AsyncTask原理和缺陷</h1><p>实际是通过Handler+线程池实现，内部含有两个线程池，一个用于排队，一个用于真正执行任务</p>
<h1 id="缺陷："><a href="#缺陷：" class="headerlink" title="缺陷："></a>缺陷：</h1><p>执行任务的线程池是个静态的全局线程池，最大线程数为128，如果任务队列满了，然后最大线程数也满了，再提交任务会出现崩溃；解决方案为自定义线程池<br>必须主线程初始化，内部handler获取主线程looper，否则不能正确切换到主线程。<br>结果丢失问题：如果activity重建，例如切横竖屏，因为持有的引用是重建之前的，新的Activity无法接收到结果。<br>内存泄漏，退出页面需要正确取消</p>
<h1 id="性能优化相关"><a href="#性能优化相关" class="headerlink" title="性能优化相关"></a>性能优化相关</h1><p>卡顿优化</p>
<p>1.View本身绘制时间过长超过16ms造成掉帧，所以需要减少View嵌套层级，使用ViewStub和merge标签，优化过度绘制等</p>
<p>2.主线程执行耗时任务，合理使用线程，将耗时任务放到后台进行</p>
<p>3.内存抖动，会频繁触发GC，造成卡顿。使用内存分析工具优化内存使用，减少不必要对象的创建</p>
<h1 id="耗电优化"><a href="#耗电优化" class="headerlink" title="耗电优化"></a>耗电优化</h1><p>合理使用后台服务，合并网络请求，使用protobuf替换json进行服务端请求，cpu休眠锁等</p>
<h1 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h1><p>内存泄露优化（包括常见的内存泄漏、分析方法、LeakCanrary等）、使用优化的数据结构（ArrayMap和SparseArray），对频繁创建的对象使用对象池技术，减少不必要的内存开销，</p>
<h1 id="启动优化"><a href="#启动优化" class="headerlink" title="启动优化"></a>启动优化</h1><p>Application的attachBaseContext和onCreate，三方sdk采用线程池异步初始化，activity的onCreate中，设置布局的优化（xml的io操作、反射创建view的操作，通过异步inflater和自定义inflater.factory来优化）</p>
<p>1.延迟初始化非必要的库，拓展到异步启动器的设计和实现，有向无环图来解决库依赖的问题。<br>2.给闪屏页设置图片背景避免冷启动白屏，其实不能加快启动，只是避免白屏给用户的体验不佳</p>
<h1 id="apk大小优化"><a href="#apk大小优化" class="headerlink" title="apk大小优化"></a>apk大小优化</h1><p>1，开启混淆压缩代码<br>2，压缩和混淆资源，图片压缩采用webP格式，整理Raw、assets资源<br>3，减少非必要so库，目前主流的机型都是支持armeabi-v7a的，并且armeabi-v7a兼容armeabi<br>4，移除未使用的资源，如图标，字符串，字体等<br>5，一些小图像可以使用矢量图，大矢量图渲染时间很长，不适用<br>6，减少三方库使用，避免枚举的使用<br>7，动态下发一些资源，如换肤包，so，字体等</p>
<h1 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h1><p>1.HttpDNS优化，传统DNS解析一般是用UDP的方式与DNS服务器交互，HttpDNS采用Http协议交互，绕过运营商的 LocalDNS 服务器，有效的防止了域名劫持，提高域名解析的效率<br>2.使用缓存，需要服务端支持，或者通过OkHttp拦截器添加统一的缓存策略<br>3.HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。在HTTP1.1中默认开启keep-alive<br>4.数据压缩，gzip压缩，http2.0也支持header的压缩<br>5.根据网络质量来下载不同质量的图片</p>
<h1 id="View-inflate流程"><a href="#View-inflate流程" class="headerlink" title="View inflate流程"></a>View inflate流程</h1><p>1.先从resource中获取一个xml parser用于加载布局<br>2.读取layout文件，调用createViewFromTag创建View<br>3.tryCreateView中，依次判断有没有设置Factory2和Factory，如果有则调用它的createView来创建view<br>4.如果没有factory则调用自己的createView来创建，内部是使用反射创建对象<br>5.注意，Factory2继承Factory增加了一个创建view的方法，相当于是一个扩展，它们可以对view创建的过程进行拦截，在创建view的时候做一些事情，例如换肤功能就用到这里。</p>
<h1 id="换肤的原理"><a href="#换肤的原理" class="headerlink" title="换肤的原理"></a>换肤的原理</h1><p>1.制作皮肤包apk，只包含颜色、图片等，通过网络下载到sd卡；<br>2.通过反射构造皮肤包的AssetManager，再用此AssetManager创建Resource。<br>3.原apk和资源包中资源名称一样，提供一个资源映射的方法，通过原来的资源id找到资源名称，然后在皮肤包中查找皮肤资源具体的值；<br>4.通过自定义LayoutInflater传入自定义的Factory2拦截view的创建过程，查找到需要换肤的view和对应的可替换属性名(background、color、textcolor等)、属性值的类型（color\drawable\mipmap…）、属性值在原apk中的资源名(如color1)和资源的id，保存起来；<br>5.点击换肤时，遍历需要换肤的view集合，调用对应的方法（setColor等等）设置新的值。</p>
<h1 id="Android的startActivityForResult的实现为什么不使用回调。"><a href="#Android的startActivityForResult的实现为什么不使用回调。" class="headerlink" title="Android的startActivityForResult的实现为什么不使用回调。"></a>Android的startActivityForResult的实现为什么不使用回调。</h1><p>因为匿名内部类会持有外部类的引用，使用回调时，例如A启动B去获取result，由于某些原因原A已经被销毁了，当B设置结果返回A时，实际上A已经被系统重建，和原先的A不是同一个对象了，所以就不能正确的获取结果。</p>
<h1 id="如何跨app启动activity？"><a href="#如何跨app启动activity？" class="headerlink" title="如何跨app启动activity？"></a>如何跨app启动activity？</h1><p>1.shareUserId，设置同一个shareUserId的应用可以直接启动。<br>2.Exported 设置为true，向外部暴露activity，允许外部启动。<br>注意：为了安全需要添加自定义权限控制，注意被暴露的有权限的app需要先被安装，否则会获取不到权限。<br>会导致拒绝服务漏洞，例如：A启动B中的activity，往intent中添加一个序列化对象，这个对象只在A中有，B中没有这个类，如果在B中访问intent的extra，就会触发反序列化对象，由于找不到这个对象的类，造成B崩溃。处理方法：获取extra要捕获异常。<br>3.隐式启动activity，只要intentFilter匹配成功就可以启动。</p>
<h1 id="高性能日志采集"><a href="#高性能日志采集" class="headerlink" title="高性能日志采集"></a>高性能日志采集</h1><h2 id="传统直接读写文件的方式的缺点"><a href="#传统直接读写文件的方式的缺点" class="headerlink" title="传统直接读写文件的方式的缺点"></a>传统直接读写文件的方式的缺点</h2><p>读写文件的IO操作，需要两次拷贝，用户空间到内核空间，内核空间再到硬盘。为了避免频繁IO，采用缓存日志到内存，达到一定量时再统一写入文件，虽然避免了频繁IO，但是可能造成crash时日志丢失。多进程也无法保证写入顺序</p>
<h1 id="mmap方案："><a href="#mmap方案：" class="headerlink" title="mmap方案："></a>mmap方案：</h1><p>mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。mmap操作提供了一种机制，让用户程序直接访问设备内存，这种机制，相比较在用户空间和内核空间互相拷贝数据，效率更高。</p>
<h1 id="mmap的回写时机："><a href="#mmap的回写时机：" class="headerlink" title="mmap的回写时机："></a>mmap的回写时机：</h1><p>1.内存不足<br>2.进程退出<br>3.调用 msync 或者 munmap<br>4.不设置 MAP_NOSYNC 情况下 30s-60s(仅限FreeBSD)</p>
<p>多进程写入映射同一个内存也会造成写入顺序无法保证，所以可以选择多进程映射不同的文件，每隔一段时间合并一次来解决</p>
<h1 id="性能优化工具："><a href="#性能优化工具：" class="headerlink" title="性能优化工具："></a>性能优化工具：</h1><p>查看方法执行时间：</p>
<h1 id="TraceView（影响性能）"><a href="#TraceView（影响性能）" class="headerlink" title="TraceView（影响性能）"></a>TraceView（影响性能）</h1><p>1.用Debug.startMethodTrace来打点，生成trace文件，然后用adb导出分析<br>2.使用profiler工具，选择cpu，输出trace文件</p>
<h1 id="Systrace（轻量级）"><a href="#Systrace（轻量级）" class="headerlink" title="Systrace（轻量级）"></a>Systrace（轻量级）</h1><p>1.TraceCompat.beginSection<br>2.使用python命令导出html，查看wall time和 cpu time</p>
<h1 id="MAT分析内存泄露："><a href="#MAT分析内存泄露：" class="headerlink" title="MAT分析内存泄露："></a>MAT分析内存泄露：</h1><p>profiler分析内存，手动触发gc，然后输出堆转储hporf文件，然后用mat分析引用链</p>
<h1 id="内存抖动："><a href="#内存抖动：" class="headerlink" title="内存抖动："></a>内存抖动：</h1><p>使用profiler工具排查</p>
<h1 id="你们项目的稳定性如何？有做过什么稳定性优化的工作？"><a href="#你们项目的稳定性如何？有做过什么稳定性优化的工作？" class="headerlink" title="你们项目的稳定性如何？有做过什么稳定性优化的工作？"></a>你们项目的稳定性如何？有做过什么稳定性优化的工作？</h1><p>答： 我们主要优化了三项：<br>Crash专项优化<br>性能稳定性优化<br>业务稳定性优化<br>性能：全面的性能优化：启动速度、内存优化、绘制优化<br>线下发现问题、优化为主<br>线上监控为主<br>Crash专项优化<br>我们针对启动速度，内存、布局加载、卡顿、瘦身、流量、电量等多个方面做了多维的优化。</p>
<p>我们的优化主要分为了两个层次，即线上和线下，针对于线下呢，我们侧重于发现问题，直接解决，将问题尽可能在上线之前解决为目的。而真正到了线上呢，我们最主要的目的就是为了监控，对于各个性能纬度的监控呢，可以让我们尽可能早地获取到异常情况的报警。</p>
<p>同时呢，对于线上最严重的性能问题性问题：Crash，我们做了专项的优化，不仅优化了Crash的具体指标，而且也尽可能地获取了Crash发生时的详细信息，结合后端的聚合、报警等功能，便于我们快速地定位问题。</p>
<h1 id="PathClassLoader与DexClassLoader有什么区别"><a href="#PathClassLoader与DexClassLoader有什么区别" class="headerlink" title="PathClassLoader与DexClassLoader有什么区别"></a>PathClassLoader与DexClassLoader有什么区别</h1><p>答： PathClassLoader 和 DexClassLoader 类加载器都是继承自 BaseDexClassLoade<br>DexClassLoader 和 PathClassLoader 构造函数<br>DexClassLoader 和 PathClassLoader 的差异在于构造 ClassLoader 对象时，是否给父类 (<br>BaseDexClassLoader<br>) 传递 optimizedDirectory 参数 </p>
<h1 id="跨进程通信了解多少？管道了解吗？"><a href="#跨进程通信了解多少？管道了解吗？" class="headerlink" title="跨进程通信了解多少？管道了解吗？"></a>跨进程通信了解多少？管道了解吗？</h1><ul>
<li>答：四大组件可以跨进程<br>主要是binder机制。Android都是，平时用AIDL<br>管道：2次拷贝？？？？？？？缓冲区有大小限制。管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。在创建时分配一个page大小的内存，缓存区大小比较有限。</li>
</ul>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

            
    
        <a href="http://b.nearby.ren/2015/12/14/offce001/#comments" class="article-comment-link">评论</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-offce002" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2015/12/13/offce002/">offce 002</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2015/12/13/offce002/">
            <time datetime="2015-12-13T04:10:55.000Z" itemprop="datePublished">2015-12-13</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/offce/">offce</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/offce/">offce</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h5 id="标记算法："><a href="#标记算法：" class="headerlink" title="标记算法："></a>标记算法：</h5><p>1.引用计数法<br>2.可达性分析法(注意GC root的类型，虚拟机栈和本地方法栈引用的对象、静态对象、字节码对象)</p>
<h3 id="回收算法（复制算法、标记清除、标记整理）"><a href="#回收算法（复制算法、标记清除、标记整理）" class="headerlink" title="回收算法（复制算法、标记清除、标记整理）"></a>回收算法（复制算法、标记清除、标记整理）</h3><p>新生代：对象存活率低，采用复制算法，堆中分为3个区域，Eden、from、to，每次分配对象都在Eden，第一次gc时，把存活对象复制到from，第二次gc把Eden和from的对象复制到to，第三次又把Eden和to的对象复制到from，依次往复。达到一定阈值时，把对象移入老年代。</p>
<p>老年代：对象存活率高，标记整理法</p>
<h3 id="java类加载机制"><a href="#java类加载机制" class="headerlink" title="java类加载机制"></a>java类加载机制</h3><ul>
<li><p>双亲委托机制：如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完</p>
</li>
<li><p>成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载</p>
</li>
<li><p>Java的类加载器：根加载器（加载java核心类）、扩展类加载器（加载jre扩展目录）、应用类加载器（加载classPath指定目录的类，自定义类加载器一般继承此加载器）</p>
</li>
<li><p>Android的类加载器：根加载器、BaseDexClassLoader、PathClassLoader（加载安装到系统的APK）、DexClassLoader（加载指定目录的dex和apk）</p>
</li>
</ul>
<h3 id="java匿名内部类"><a href="#java匿名内部类" class="headerlink" title="java匿名内部类"></a>java匿名内部类</h3><p>匿名内部类就是没有名字的内部类，（其实是有名字的，虚拟机定位这个类，编译之后会使用 外部类名$1这样的名字，数字按顺序生成）。<br>匿名内部类的构造方法由编译器生成，参数列表包括：</p>
<ul>
<li><p>外部类的引用（定义在非静态域）</p>
</li>
<li><p>捕获的外部变量（方法体中使用的外部final对象）</p>
</li>
<li><p>父类的构造参数</p>
</li>
<li><p>如果父类也是一个非静态内部类则还有父类的外部类引用。</p>
</li>
</ul>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ul>
<li><p>不能继承父类或者实现接口（kotlin中是可以的）</p>
</li>
<li><p>不能定义静态变量和方法</p>
</li>
<li><p>会持有外部类的引用，可能会造成内存泄露。</p>
</li>
</ul>
<p>拓展：lambda表达式可以替代部分匿名内部类，父类必须是接口，且只有一个方法。</p>
<h3 id="java泛型擦除"><a href="#java泛型擦除" class="headerlink" title="java泛型擦除"></a>java泛型擦除</h3><p>使用泛型可以声明集合存储的元素类型，取出元素时避免强转的操作。在java中，编译完成后泛型参数会被擦除，例如List<string>和List<integer>编译完成后都是List类型。</integer></string></p>
<h3 id="java泛型为什么会被擦除："><a href="#java泛型为什么会被擦除：" class="headerlink" title="java泛型为什么会被擦除："></a>java泛型为什么会被擦除：</h3><ul>
<li><p>运行时内存压力小，不同泛型的List都编译成同一个类型。泛型不擦除的语言如c#，在方法区就会真实存在各种不同的List类型，压力就会相对较大。</p>
</li>
<li><p>兼容性的问题，1.5之前是没有泛型的，java当时的用户量很大，为了向下兼容。  </p>
</li>
</ul>
<h3 id="存在的问题："><a href="#存在的问题：" class="headerlink" title="存在的问题："></a>存在的问题：</h3><p>1.基本类型无法用于泛型，只能用装箱类型，例如List，装箱操作有额外的开销。<br>2.泛型参数不能用于方法重载，因为编译完成后泛型被擦除，参数都是一样的。<br>3.泛型类型不能当做真实的类型来使用，例如方法参数中有一个泛型T，方法中不能直接new  T（），因为编译之后就是Object，不知道真实的类型。<br>4.静态方法无法引用类的泛型，因为类的泛型在实例化的时候才知道。<br>5.类型强转的额外开销。</p>
<p>泛型在特定场景可以通过反射获取，例如父类有一个泛型参数已经被确定，子类继承之后可以获取。例如gson中，解析带泛型的List，要传入一个TypeToken，实际上是new了一个子类，通过反射获取泛型类型。</p>
<h3 id="如何写出线程安全的程序？"><a href="#如何写出线程安全的程序？" class="headerlink" title="如何写出线程安全的程序？"></a>如何写出线程安全的程序？</h3><p>线程安全的本质，可变资源在线程间共享的问题。关键：可变资源、线程共享。</p>
<p>线程安全三要素：原子性、可见性、有序性</p>
<p>所以要保证线程安全：</p>
<p>1.共享不可变资源，final关键字的使用。<br>2.使用纯函数（不访问外部资源），使用ThreadLocal，不共享资源。<br>3.使用volatile关键字保证共享资源的可见性，并禁止指令重排序。<br>4.操作原子性（加锁保证操作的互斥性，原子类AtomicXXX的使用，CAS指令如Unsafe.compareAndSwap）</p>
<h3 id="Synchronized原理"><a href="#Synchronized原理" class="headerlink" title="Synchronized原理"></a>Synchronized原理</h3><p>底层通过一个监视器monitor实现，monitor对象包含一个count计数字段和owner字段指向获取锁的线程，当线程获取monitor后，count+1，owner指向线程，监视器处于锁定状态，其他线程不能获取monitor会进入阻塞状态，当前线程释放monitor后，其他线程可以继续竞争该锁。</p>
<h3 id="Java1-6之后对Synchronized进行了一些优化："><a href="#Java1-6之后对Synchronized进行了一些优化：" class="headerlink" title="Java1.6之后对Synchronized进行了一些优化："></a>Java1.6之后对Synchronized进行了一些优化：</h3><ul>
<li><p>锁自旋：线程的阻塞和唤醒需要 CPU 从用户态转为核心态，例如在Synchronized代码块中调用wait方法阻塞线程，wait会释放锁，所谓自旋，就是让该线程执行一段无意义的循环指令来等待一段时间，不会被立即挂起，看当前持有锁的线程是否会很快释放锁。缺点是需要占用 CPU，锁竞争的时间比较长时不实用）</p>
</li>
<li><p>偏斜锁：如果一个线程获得了一个偏向锁，如果在接下来的一段时间中没有其他线程来竞争锁，那么持有偏向锁的线程再次进入或者退出同一个同步代码块，不需要再次进行抢占锁和释放锁的操作，一旦出现锁竞争，偏向锁会被撤销，并膨胀成轻量级锁</p>
</li>
<li><p>轻量级锁：对于一块同步代码，虽然有多个不同线程会去执行，但是这些线程是在不同的时间段交替请求这把锁对象，也就是不存在锁竞争的情况。在这种情况下，锁会保持在轻量级锁的状态，从而避免重量级锁的阻塞和唤醒操作</p>
</li>
</ul>
<p>Synchronized可以修饰静态方法（锁对象为字节码对象）、实例方法（锁为实例对象）和代码块，无论是否发生异常虚拟机都会正常释放锁<br>ReentrantLock发生异常时不能释放锁，所以一般需要在finaly代码块中释放锁，它包含公平锁和读写锁等用法，使用更灵活</p>
<h3 id="java虚拟机内存模型"><a href="#java虚拟机内存模型" class="headerlink" title="java虚拟机内存模型"></a>java虚拟机内存模型</h3><ul>
<li><p>虚拟机栈：线程私有，随线程创建而创建。栈里面是一个一个“栈帧”，每个栈帧对应一次方法调用。栈帧中存放了局部变量表（基本数据类型变量和对象引用）、操作数栈、方法出口等信息。当栈调用深度大于JVM所允许的范围，会抛出StackOverflowError的错误。</p>
</li>
<li><p>本地方法栈：线程私有，这部分主要与虚拟机用到的Native方法相关，一般情况下并不需要关心这部分内容。</p>
</li>
<li><p>程序计数器：也叫PC寄存器，JVM支持多个线程同时运行，每个线程都有自己的程序计数器。倘若当前执行的是 JVM 的方法，则该寄存器中保存当前执行指令的地址；倘若执行的是native方法，则PC寄存器中为空。（PS：线程执行过程中并不都是一口气执行完，有可能在一个CPU时钟周期内没有执行完，由于时间片用完了，所以不得不暂停执行，当下一次获得CPU资源时，通过程序计数器就知道该从什么地方开始执行）</p>
</li>
<li><p>方法区：方法区存放类的信息（包括类的字节码，类的结构）、常量、静态变量等。字符串常量池就是在方法区中。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的是与Java堆区分开来。很多人都更愿意把方法区称为“永久代”（Permanent Generation）。从jdk1.7已经开始准备“去永久代”的规划，jdk1.7的HotSpot中，已经把原本放在方法区中的静态变量、字符串常量池等移到堆内存中。</p>
</li>
<li><p>堆：堆中存放的是数组（PS：数组也是对象）和对象。当申请不到空间时会抛出OutOfMemoryError。</p>
</li>
</ul>
<h3 id="class加载过程"><a href="#class加载过程" class="headerlink" title="class加载过程"></a>class加载过程</h3><p>1.装载，将class文件加载进内存，在堆中生成class对象<br>2.链接，验证二进制数据流（类结构是否正确），分配静态变量设置默认值（初始化时才真正赋值），将符号引用转换为直接引用<br>3.初始化，初始化静态变量，静态代码块</p>
<h3 id="java内存模型、volatile的作用"><a href="#java内存模型、volatile的作用" class="headerlink" title="java内存模型、volatile的作用"></a>java内存模型、volatile的作用</h3><h5 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h5><ul>
<li><p>本地内存：存放的是 私有变量 和 主内存数据的副本。如果私有变量是基本数据类型，则直接存放在本地内存，如果是引用类型变量，存放的是引用，实际的数据存放在主内存。本地内存是不共享的，只有属于它的线程可以访问。</p>
</li>
<li><p>主内存：存放的是共享的数据，所有线程都可以访问。当然它也有不少其他称呼，比如 堆内存，共享内存等等。</p>
</li>
</ul>
<p>Java内存模型规定了所有对共享变量的读写操作都必须在本地内存中进行，需要先从主内存中拿到数据，复制到本地内存，然后在本地内存中对数据进行修改，再刷新回主内存，这就导致了多线程情况下数据的可见性问题，可以使用volatile关键字来修饰</p>
<ul>
<li><p>volatile变量在修改后，会立即刷新主内存的值，对所有线程可见，当volatile变量写后，线程中本地内存中共享变量就会置为失效的状态，因此线程需要从主内存中去读取该变量的最新值。</p>
</li>
<li><p>volatile还可以防止指令重排序造成的线程安全问题，例如双重校验的懒汉式单例中，不加volatile的对象编译后的指令有可能重排序成：对象引用已经被赋值不等于null了，但是对象的构造方法还没有调用完成的情况。第二个线程去判断不为空，拿到的对象还未初始化完成造成错误。</p>
</li>
</ul>
<h3 id="如何安全停止一个线程"><a href="#如何安全停止一个线程" class="headerlink" title="如何安全停止一个线程"></a>如何安全停止一个线程</h3><p>stop方法，被废弃。强行停止一个线程，没有资源的机会，如果正在处理任务，会留下一堆异常的数据。另一个线程再访问时就会发生错误。那么如何安全的结束呢：<br>1、设置volatile的boolean标志位，修改标志位来判断是否继续执行还是清理现场。</p>
<p>2、Interrupt方法：线程内部也需要做支持，判断是否被中断，和标志位类似的处理。支持sleep等系统方法（sleep过程中中断）。判断是否中断的两个方法的区别：<br>interrupted，静态方法，获取当前正在执行的线程是否被中断，中断之后会清空状态，重复获取就返回falseisInterrupted，线程的方法，获取当前线程的中断状态，不会被清空状态</p>
<h3 id="HashMap原理"><a href="#HashMap原理" class="headerlink" title="HashMap原理"></a>HashMap原理</h3><p>底层是数组+链表的结构，默认数组长度16，加载因子0.75，在put时，（如果第一次put，会创建数组）如果元素个数大于数组长度*加载因子时，将触发扩容操作，数组长度翻倍，并重新计算hash将元素放入数组；</p>
<p>Java1.8中，如果元素过多，数组长64，链表长度超过8，将进行树化操作，将链表转为红黑树，红黑树的节点是链表节点占用空间的两倍，提高查询效率；</p>
<h5 id="如何计算元素存储的位置，如何解决hash冲突，为何数组长度必须为2的整数幂："><a href="#如何计算元素存储的位置，如何解决hash冲突，为何数组长度必须为2的整数幂：" class="headerlink" title="如何计算元素存储的位置，如何解决hash冲突，为何数组长度必须为2的整数幂："></a>如何计算元素存储的位置，如何解决hash冲突，为何数组长度必须为2的整数幂：</h5><p>先把key取hash值，然后进行一个二次hash，方式为(n-1)&amp;hash，这个二次hash是因为如果n正好等于2的幂，(n-1)&amp;hash相当于对n取模，这样位运算效率很高，这样就相当于把元素均匀分布到了数组中，如果数组的位置没有元素，直接保存元素，如果已经有元素了，表示发生了hash冲突，将改为链表的存储方式，把新元素放在头部（1.8中是尾插法）</p>
<h5 id="为什么加载因子为0-75？设为1和0-5有什么问题？"><a href="#为什么加载因子为0-75？设为1和0-5有什么问题？" class="headerlink" title="为什么加载因子为0.75？设为1和0.5有什么问题？"></a>为什么加载因子为0.75？设为1和0.5有什么问题？</h5><p>loadFactor太大，比如等于1，那么就会有很高的哈希冲突的概率，会大大降低查询速度。</p>
<p>loadFactor太小，比如等于0.5，那么频繁扩容没，就会大大浪费空间。</p>
<h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p>初始化容量不一样（11），线程安全对整个数组加锁，不允许null值，数据结构一直是数组+链表，不会转换为红黑树；</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap:"></a>ConcurrentHashMap:</h3><p>1.5-1.7采用分段锁segment机制，不再是整个数组加锁，而是对单条或者几条链表和红黑树进行加锁。内部结构如图：segment数组，segment中类似HashMap的数组+链表。要通过hash让元素尽可能的均匀分布到不同的segment和数组中，所以对key取hash，用高位确定segment的位置，然后用低位确定数组的位置。</p>
<p>1.5的hash算法不好，元素多的时候会造成新加的节点分布在最后的几个桶，分布不均匀，</p>
<p>1.6就改善了hash算法。</p>
<p>1.7的优化是采用segment的懒加载机制，并用volatile的方式访问数组，保证数组的线程可见性，结合CAS指令来避免加锁。</p>
<p>1.8中则基于hashmap做优化，不再采用分段锁，而是对桶节点加锁，使用volatile和CAS乐观锁来实现读和写，再次提高了效率。</p>
<p>通过对Hashtable和ConcurrentHashMap的比较，得出一些锁优化的方法论，比如大锁不如小锁，长锁不如短锁，读写锁的分离等等</p>
<h3 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h3><h3 id="线程池的参数"><a href="#线程池的参数" class="headerlink" title="线程池的参数"></a>线程池的参数</h3><p>1.corePoolSize：线程池大小，当向线程池提交任务时，如果线程池已创建的线程数小于corePoolSize，即便此时存在空闲线程，也会创建一个新的线程来执行任务，直到线程数大于或等于corePoolSize。（除了提交新任务来创建线程，也可以通过prestartCoreThread或prestartAllCoreThreads来提前创建核心线程）<br>2.maximumPoolSize：线程池最大大小，当任务队列满了，且已创建的线程数小于最大线程数，则创建新线程来执行任务，如果线程池任务队列为无界队列可以忽略该参数<br>3.keepAliveTime：线程存活时间，当线程数大于核心线程数时，线程空闲时间大于存活时间，那么这个线程将被销毁，如果线程池任务队列为无界队列可以忽略该参数<br>4.workQueue：任务队列，用于保存等待执行任务的阻塞队列<br>5.threadFactory：线程工厂，用于创建新线程，可以设置统一风格的线程名<br>6.handler：线程饱和策略，当任务队列和线程池都满了，继续提交任务将执行此策略</p>
<h3 id="如何配置线程池？需要看任务的类型"><a href="#如何配置线程池？需要看任务的类型" class="headerlink" title="如何配置线程池？需要看任务的类型"></a>如何配置线程池？需要看任务的类型</h3><p>cpu密集型需要配置较小的线程数，避免cpu过度切换反而效率低下<br>IO密集型，线程池可以稍大，提高cpu的利用率；混合型任务则可配置两个线程池分别来执行；</p>
<p>java自带的线程池</p>
<p>线程池                   核心线程    最大线程              存活时间           任务队列<br>CachedThreadPool        0          Integer.MAX_VALUE    60S               SynchronousQueue<br>FixedThreadPool         n          n                    0                 LinkedBlockingQueue<br>SingleThreadExecutor    1          1                    0                 LinkedBlockingQueue<br>ScheduledThreadPool     n          Integer.MAX_VALUE    0                 DelayWorkQueue</p>
<p>SynchronousQueue：只能有一个元素的队列，插入和获取元素都会阻塞线程</p>
<h3 id="java方法分派（多态）"><a href="#java方法分派（多态）" class="headerlink" title="java方法分派（多态）"></a>java方法分派（多态）</h3><p>子类复写父类方法，调用方法调用子类还是父类？ 取决于运行时具体的调用者类型，实例是子类就调用子类的方法。</p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><ul>
<li><p>对称加密和非对称加密</p>
</li>
<li><p>对称加密：加密和解密使用同一个秘钥，使用对应的加密和解密算法进行加解密</p>
</li>
<li><p>非对称加密：加密和解密使用不同的秘钥，分为公钥和私钥，公钥和私钥相互可解，意思就是私钥加密的密文只有公钥可解，反之亦然。</p>
</li>
<li><p>数字签名技术<br>​   非对称加密在实际使用中，公钥会公开出来，私钥保存在自己手中不公开。由于私钥加密的密文只有公钥可解，那么如果有一个密文用你的公钥可以解开，那么可以说明这个密文肯定是你的私钥加密的，这就诞生了数字签名技术。<br>​   只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明</p>
</li>
</ul>
<h3 id="https的本质"><a href="#https的本质" class="headerlink" title="https的本质"></a>https的本质</h3><p>https的本质就是：用非对称加密的方式协商出一个对称加密的会话秘钥来进行会话</p>
<ul>
<li>首先服务端需要有一个证书，证书包含了自己的公钥和服务端信息，如hash算法、加密算法、域名、有效期等等。此证书需要由可信任的第三方（CA机构）的私钥进行签名，实际上是对证书做一个hash，得到hash值然后签名，CA机构也可能不止一级而是一个证书链</li>
<li>为什么要用第三方机构来颁发证书呢？为了安全的传输自己的公钥，系统都预置了可信任的根证书，三方机构是否可信任由系统来保证</li>
</ul>
<h3 id="客户端如何校验CA证书"><a href="#客户端如何校验CA证书" class="headerlink" title="客户端如何校验CA证书"></a>客户端如何校验CA证书</h3><p>1.客户端收到证书后，用证书中的公钥去解密该Hash值，得到hash-a<br>2.客户端用证书中指定的签名算法，计算出一个hash-b，比较hash-a和hash-b<br>3.除了校验hash值，还会校验CA证书有效期和域名等</p>
<h3 id="SSL握手过程"><a href="#SSL握手过程" class="headerlink" title="SSL握手过程"></a>SSL握手过程</h3><p>1.客户端A访问服务端B，客户端生成一个随机数1、将自己支持的SSL版本号、加密套件（包括哈希算法和加密算法）等信息发送给服务端<br>2.服务端B收到请求，选择一个加密套件，也生成一个随机数2，将随机数和自己的证书一同返回给客户端<br>3.客户端收到证书，校验证书是否有效（方法之前说过了），通过校验后，生成一个随机数3，用证书中的公钥加密随机数3，发送给服务端B<br>4.服务端收到加密的随机数，用私钥解密<br>5.服务端和客户端都有了随机数1、2、3，通过这三个随机数，生成一个对称加密的会话密钥<br>6.服务端和客户端分别通知对方之后的会话用会话秘钥来完成，握手结束</p>
<h3 id="为什么要用非对称加密来握手，而用对称加密来会话"><a href="#为什么要用非对称加密来握手，而用对称加密来会话" class="headerlink" title="为什么要用非对称加密来握手，而用对称加密来会话"></a>为什么要用非对称加密来握手，而用对称加密来会话</h3><p>对称加密握手的话，由于双方的秘钥是一样的，相当于秘钥公开了，和没加密没有区别<br>而会话阶段，对称加密效率较非对称高</p>
<h3 id="TCP为什么要三次握手和四次挥手"><a href="#TCP为什么要三次握手和四次挥手" class="headerlink" title="TCP为什么要三次握手和四次挥手"></a>TCP为什么要三次握手和四次挥手</h3><ul>
<li>“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。例如：第一次请求由于网络拥堵没有到达服务端，客户端又发起第二次请求，正常完成了连接，传输完数据之后断开，这时第一次的请求到达了服务端，如果没有第三次握手，会直接建立一条没有用的连接，server端一直等待，浪费资源。</li>
</ul>
<p>+“四次挥手”原因是因为tcp是全双工模式，接收到FIN时意味对方将没有数据再发来，但是自己还是可以继续发送数据。</p>
<h3 id="为什么TCP是可靠的？"><a href="#为什么TCP是可靠的？" class="headerlink" title="为什么TCP是可靠的？"></a>为什么TCP是可靠的？</h3><h3 id="TCP基于连接，具有以下机制："><a href="#TCP基于连接，具有以下机制：" class="headerlink" title="TCP基于连接，具有以下机制："></a>TCP基于连接，具有以下机制：</h3><ul>
<li>确认和重传：接收方收到报文后就会进行确认，发送方一段时间没有收到确认就会重传。</li>
<li>数据校验。</li>
<li>数据合理分片与排序，TCP会对数据进行分片，接收方会缓存为按序到达的数据，重新排序后再提交给应用层。</li>
<li>流程控制：当接收方来不及接收发送的数据时，则会提示发送方降低发送的速度，防止包丢失。</li>
<li>拥塞控制：当网络发生拥塞时，减少数据的发送。</li>
</ul>
<p>UDP是无连接、不安全的，每个数据包都包含接收的ip等信息，客户端只管发送，没有确认重传机制，所以速度更快，但是可能会丢包。</p>
<h3 id="HTTP1-0、1-1、2-0的区别"><a href="#HTTP1-0、1-1、2-0的区别" class="headerlink" title="HTTP1.0、1.1、2.0的区别"></a>HTTP1.0、1.1、2.0的区别</h3><h5 id="1-1和1-0："><a href="#1-1和1-0：" class="headerlink" title="1.1和1.0："></a>1.1和1.0：</h5><ul>
<li><p>增加新的控制缓存策略的Header，如Entity tag，If-Unmodified-Since, If-Match, If-None-Match；</p>
</li>
<li><p>增加了range请求头，允许请求资源的一部分，支持了多线程断点续传下载，优化了带宽和连接；</p>
</li>
<li><p>增加了Host头，允许一台物理服务器上存在多个虚拟主机，共享一个IP地址，通过Host来区分；</p>
</li>
<li><p>增加了keep-alive支持TCP长连接，一定程度弥补了每次请求都重新创建连接的情况；</p>
</li>
</ul>
<h4 id="SPDY："><a href="#SPDY：" class="headerlink" title="SPDY："></a>SPDY：</h4><p>SPDY是Http1.x版本的优化方案，包括多路复用技术、请求优先级（多路复用时，多个请求并行于共用的TCP连接，可以设置请求的优先级防止关键请求被阻塞）、header压缩和服务端推送功能；SPDY的特性并入了Http2.0中；</p>
<h4 id="1-1和2-0："><a href="#1-1和2-0：" class="headerlink" title="1.1和2.0："></a>1.1和2.0：</h4><ul>
<li><p>支持了新的二进制格式，1.x版本只支持文本协议</p>
</li>
<li><p>多路复用技术，在HTTP/1.1协议中，同一时间针对同一域名下的请求有一定数量限制，超过限制数目的请求会被阻塞。多个请求是串行处理，当一个请求超时，后续请求就会被阻塞，而在2.0中，一个TCP连接上并行多个请求，某个请求耗时不影响其他连接；</p>
</li>
<li><p>Header压缩，多个请求可以差量更新Header字段，降低流量提高效率；</p>
</li>
<li><p>服务端推送功能</p>
</li>
</ul>
<h3 id="三方授权方式"><a href="#三方授权方式" class="headerlink" title="三方授权方式"></a>三方授权方式</h3><ul>
<li><p>Basic：格式：Authorization: Basic username:password(Base64ed)</p>
</li>
<li><p>Bearer：格式：Authorization: Bearer </p>
</li>
</ul>
<h3 id="bearer-token-的获取⽅式（-OAuth2-的授权流程）："><a href="#bearer-token-的获取⽅式（-OAuth2-的授权流程）：" class="headerlink" title="bearer token 的获取⽅式（ OAuth2 的授权流程）："></a>bearer token 的获取⽅式（ OAuth2 的授权流程）：</h3><p>1.第三⽅⽹站向授权⽅⽹站申请第三⽅授权合作，拿到 client id 和 client secret</p>
<p>2.⽤户在使⽤第三⽅⽹站时，点击「通过 XX (如 GitHub) 授权」按钮，第三⽅⽹站将⻚⾯跳转到授权⽅⽹站，并传⼊ client id 作为⾃⼰的身份标识</p>
<p>3.授权⽅⽹站根据 client id ，将第三⽅⽹站的信息和需要的⽤户权限展示给⽤户，询问⽤户是否同意授权</p>
<p>4.⽤户点击「同意授权」按钮后，授权⽅⽹站将⻚⾯跳转回第三⽅⽹站，并传⼊ Authorization code 作为⽤户认可的凭证。</p>
<p>5.第三⽅⽹站将 Authorization code 发送回⾃⼰的服务器</p>
<p>6.服务器将 Authorization code 和 client secret ⼀并发送给授权⽅的服务器，授权⽅返回 access token。</p>
<h3 id="WebSocket和Socket的区别"><a href="#WebSocket和Socket的区别" class="headerlink" title="WebSocket和Socket的区别"></a>WebSocket和Socket的区别</h3><ul>
<li>WebSocket是应用层的一个持久化协议，http它一次请求和响应就断开连接，属于非持久化协议。WebSocket分为握手和数据传输两个阶段，采用http协议握手然后建立全双工的tcp连接。</li>
<li>Socket是传输层的一个协议抽象，包括TCP和UDP，TCP基于连接，拥有确认和重传，拥塞控制和流程控制等机制的可靠的协议。UDP则面向无连接，基于数据报，相对于TCP速度快但不可靠。</li>
</ul>
<h3 id="多线程下载和断点续传"><a href="#多线程下载和断点续传" class="headerlink" title="多线程下载和断点续传"></a>多线程下载和断点续传</h3><p>两个核心Header，Content-Length表示文件的总字节数，RANGE表示从某一个位置开始传输。</p>
<p>首先，获取到文件大小后，通过线程数来计算每个线程下载的开始位置。</p>
<p>然后，通过range来设置从哪个位置传输。</p>
<p>当暂停或者退出时，记录已下载的位置，下次恢复后从记录的位置下载。</p>
<p>使用RandAccessFile来保存文件，这个类的特点是可以通过移动文件指针来设置写入的位置。</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

            
    
        <a href="http://b.nearby.ren/2015/12/13/offce002/#comments" class="article-comment-link">评论</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-七友" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2015/11/11/七友/">七友</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2015/11/11/七友/">
            <time datetime="2015-11-11T03:50:28.000Z" itemprop="datePublished">2015-11-11</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/文字/">文字</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/歌曲/">歌曲</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>梁汉文 - 七友<br>曲 : 雷颂德 词：林夕</p>
<p>为了她又再勉强去谈天论爱<br>又再振作去慰解他人<br>如难复合便尽早放开<br>凡事看开<br>又再讲没有情人时还可自爱<br>忘掉或是为自己感慨<br>笑住说沉沦那些苦海<br>会有害</p>
<p>因为我坚强到利用自己的痛心<br>转换成爱心<br>抵我对她操心<br>已记不起我也有权利爱人</p>
<p>谁人曾照顾过我的感受<br>待我温柔吻过我伤口<br>能得到的安慰是失恋者得救后<br>很感激忠诚的狗<br>谁人曾介意我也不好受<br>为我出头碰过我的手<br>重生者走得的都走<br>谁人又为天使忧愁<br>甜言蜜语没有但却有我这个好友</p>
<p>直到她又再告诉我重新被爱<br>又再看透了我的将来<br>完成任务后大可喝采<br>无谓搭台<br>别怪她就怪我永远难得被爱<br>然后自虐地赞她可爱<br>往日最彷徨那刻<br>好彩有我在</p>
<p>因为我坚强到利用自己的痛心<br>转换成爱心<br>抵我对她操心<br>已记不起我也有权利爱人</p>
<p>谁人曾照顾过我的感受<br>待我温柔吻过我伤口<br>能得到的安慰是失恋者得救后<br>很感激忠诚的狗<br>谁人曾介意我也不好受<br>为我出头碰过我的手<br>重生者走得的都走<br>谁人又为天使忧愁<br>甜言蜜语没有但却有我这个好友</p>
<p>白雪公主不多<br>认命扮矮人的有太多个<br>早有六个<br>多我这个不多<br>我太好心还是太傻<br>未问过她有没有理我的感受<br>待我温柔吻过我伤口<br>能得到的安慰是失恋者得救后<br>很感激忠诚的狗<br>谁人曾介意我也不好受<br>为我出头碰过我的手<br>重生者走得的都走<br>谁人又为天使忧愁<br>甜言蜜语没有但却有我这个好友</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

            
    
        <a href="http://b.nearby.ren/2015/11/11/七友/#comments" class="article-comment-link">评论</a>
    

        </footer>
    </div>
    
</article>



    <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/page/16/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/page/18/">18</a><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" href="/page/18/">下一页 &raquo;</a>
    </nav>
</section>
            
                <aside id="sidebar">
   
        
    <div class="widget-wrap">
        <h3 class="widget-title">最新文章</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2022/04/25/kotlin Android  day/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/kotlin/">kotlin</a></p>
                            <p class="item-title"><a href="/2022/04/25/kotlin Android  day/" class="title">kotlin Android day</a></p>
                            <p class="item-date"><time datetime="2022-04-25T03:13:18.000Z" itemprop="datePublished">2022-04-25</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2021/05/31/mac flutter 支持多个版本配置/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/android/">android</a></p>
                            <p class="item-title"><a href="/2021/05/31/mac flutter 支持多个版本配置/" class="title">mac flutter 支持多个版本配置</a></p>
                            <p class="item-date"><time datetime="2021-05-31T01:47:42.000Z" itemprop="datePublished">2021-05-31</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2020/09/11/深入详解Apk编译打包流程/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Android/">Android</a></p>
                            <p class="item-title"><a href="/2020/09/11/深入详解Apk编译打包流程/" class="title">深入详解Apk编译打包流程</a></p>
                            <p class="item-date"><time datetime="2020-09-11T04:13:18.000Z" itemprop="datePublished">2020-09-11</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2020/03/31/android 网络优化/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/android/">android</a></p>
                            <p class="item-title"><a href="/2020/03/31/android 网络优化/" class="title">android 网络优化</a></p>
                            <p class="item-date"><time datetime="2020-03-31T01:12:23.000Z" itemprop="datePublished">2020-03-31</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2019/12/30/View绘制主要要讲什么/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/android/">android</a></p>
                            <p class="item-title"><a href="/2019/12/30/View绘制主要要讲什么/" class="title">View绘制主要要讲什么</a></p>
                            <p class="item-date"><time datetime="2019-12-30T03:50:25.000Z" itemprop="datePublished">2019-12-30</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">分类</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/EventBus/">EventBus</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RecyclerView/">RecyclerView</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a><span class="category-list-count">30</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/android-studio/">android studio</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/apk/">apk</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/dagger2/">dagger2</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/flutter/">flutter</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/go/">go</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/gradle/">gradle</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/kotlin/">kotlin</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linxu/">linxu</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mac/">mac</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/markdown/">markdown</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mvp/">mvp</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/offce/">offce</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/resume/">resume</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/rxjava/">rxjava</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tinker/">tinker</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/vuforia/">vuforia</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/延迟搜索/">延迟搜索</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/文字/">文字</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/软件/">软件</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/适配/">适配</a><span class="category-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">归档</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">十一月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">六月 2015</a><span class="archive-list-count">2</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">标签</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Leakcanary/">Leakcanary</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mac-Linux/">Mac/Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a><span class="tag-list-count">39</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-studio/">android studio</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bug/">bug</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dagger2/">dagger2</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flutter/">flutter</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/glide/">glide</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/">go</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/">golang</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gradle/">gradle</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/h5/">h5</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/https/">https</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ios/">ios</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kotlin/">kotlin</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linxu/">linxu</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mac/">mac</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/">markdown</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mvp/">mvp</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/offce/">offce</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/resume/">resume</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rxandroid/">rxandroid</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rxjava/">rxjava</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/service/">service</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springboot/">springboot</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/view/">view</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vuforia/">vuforia</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/">web</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/延迟/">延迟</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/性能优化/">性能优化</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/文字/">文字</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/歌曲/">歌曲</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/直播/">直播</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/笔录/">笔录</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/软件名词/">软件名词</a><span class="tag-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">标签云</h3>
        <div class="widget tagcloud">
            <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/Leakcanary/" style="font-size: 10px;">Leakcanary</a> <a href="/tags/Mac-Linux/" style="font-size: 10px;">Mac/Linux</a> <a href="/tags/android/" style="font-size: 20px;">android</a> <a href="/tags/android-studio/" style="font-size: 10px;">android studio</a> <a href="/tags/bug/" style="font-size: 10px;">bug</a> <a href="/tags/dagger2/" style="font-size: 11.67px;">dagger2</a> <a href="/tags/flutter/" style="font-size: 10px;">flutter</a> <a href="/tags/git/" style="font-size: 16.67px;">git</a> <a href="/tags/glide/" style="font-size: 15px;">glide</a> <a href="/tags/go/" style="font-size: 18.33px;">go</a> <a href="/tags/golang/" style="font-size: 10px;">golang</a> <a href="/tags/gradle/" style="font-size: 11.67px;">gradle</a> <a href="/tags/h5/" style="font-size: 10px;">h5</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/https/" style="font-size: 11.67px;">https</a> <a href="/tags/ios/" style="font-size: 11.67px;">ios</a> <a href="/tags/java/" style="font-size: 11.67px;">java</a> <a href="/tags/kotlin/" style="font-size: 10px;">kotlin</a> <a href="/tags/linxu/" style="font-size: 11.67px;">linxu</a> <a href="/tags/mac/" style="font-size: 11.67px;">mac</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/mvp/" style="font-size: 13.33px;">mvp</a> <a href="/tags/offce/" style="font-size: 11.67px;">offce</a> <a href="/tags/resume/" style="font-size: 11.67px;">resume</a> <a href="/tags/rxandroid/" style="font-size: 11.67px;">rxandroid</a> <a href="/tags/rxjava/" style="font-size: 11.67px;">rxjava</a> <a href="/tags/service/" style="font-size: 10px;">service</a> <a href="/tags/springboot/" style="font-size: 10px;">springboot</a> <a href="/tags/view/" style="font-size: 11.67px;">view</a> <a href="/tags/vuforia/" style="font-size: 10px;">vuforia</a> <a href="/tags/web/" style="font-size: 13.33px;">web</a> <a href="/tags/延迟/" style="font-size: 10px;">延迟</a> <a href="/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/tags/文字/" style="font-size: 11.67px;">文字</a> <a href="/tags/歌曲/" style="font-size: 11.67px;">歌曲</a> <a href="/tags/直播/" style="font-size: 10px;">直播</a> <a href="/tags/笔录/" style="font-size: 13.33px;">笔录</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/设计模式/" style="font-size: 13.33px;">设计模式</a> <a href="/tags/软件名词/" style="font-size: 10px;">软件名词</a>
        </div>
    </div>

    
        
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">链接</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="http://hexo.io">Hexo</a>
                    </li>
                
            </ul>
        </div>
    </div>


    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2022 阿荣<br>
            <!-- <a href="http://github.com/ppoffice">ppoffice</a>     
            主题 - <a href="http://hexo.io/" target="_blank">Hexo</a> -->  
             <a href="#" target="_blank">人生如逆旅  &phi; 我亦是行人 </a>
             <div class="copyright" style="margin-top: 10px;">
 			ICP备案号： <a href="https://beian.miit.gov.cn/" target="_blank">粤ICP备16067940号</a><br>
		</div>	
        </div>
    </div>
</footer>
        
    
    <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2119666"></script>



    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>