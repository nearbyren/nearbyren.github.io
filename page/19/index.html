<!DOCTYPE html>
<html lang="zh">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    
    <title>lr</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="nearby, 移动开发, 用户体验, 设计, Java, JavaWeb, Go">
<meta property="og:type" content="website">
<meta property="og:title" content="lr">
<meta property="og:url" content="http://b.nearby.ren/page/19/index.html">
<meta property="og:site_name" content="lr">
<meta property="og:description" content="nearby, 移动开发, 用户体验, 设计, Java, JavaWeb, Go">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lr">
<meta name="twitter:description" content="nearby, 移动开发, 用户体验, 设计, Java, JavaWeb, Go">
    

    
        <link rel="alternate" href="/atom.xml" title="lr" type="application/atom+xml">
    

    
        <link rel="icon" href="/css/images/super.png# path to favicon">
    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    


</head>
</html>
<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">lr</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/">首页</a>
                
                    <a class="main-nav-link" href="/archives">目录</a>
                
                    <a class="main-nav-link" href="/categories">分类</a>
                
                    <a class="main-nav-link" href="/tags">Tags</a>
                
                    <a class="main-nav-link" href="/about">关于</a>
                
            </nav>
            
                
                <nav id="sub-nav">
                    <div class="profile" id="profile-nav">
                        <a id="profile-anchor" href="javascript:;">
                            <img class="avatar" src="/css/images/avatar.png">
                            <i class="fa fa-caret-down"></i>
                        </a>
                    </div>
                </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索">
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么...">
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/">首页</a></td>
                
                    <td><a class="main-nav-link" href="/archives">目录</a></td>
                
                    <td><a class="main-nav-link" href="/categories">分类</a></td>
                
                    <td><a class="main-nav-link" href="/tags">Tags</a></td>
                
                    <td><a class="main-nav-link" href="/about">关于</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索">
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
                

<aside id="profile">
    <div class="inner profile-inner">
        <div class="base-info profile-block">
            <img id="avatar" src="/css/images/avatar.png">
            <h2 id="name">lr</h2>
            <h3 id="title">Android server web Go</h3>
            <span id="location"><i class="fa fa-map-marker"></i>china, Hainan</span>
            <a id="follow" target="_blank" href="https://github.com/nearbyren">关注我</a>
        </div>
        <div class="article-info profile-block">
            <div class="article-info-block">
                105
                <span>文章</span>
            </div>
            <div class="article-info-block">
                42
                <span>标签</span>
            </div>
        </div>
        
        <div class="profile-block social-links">
            <table>
                <tr>
                    
                    
                    <td>
                        <a href="https://github.com/nearbyren" target="_blank" title="github">
                            <i class="fa fa-github"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="https://twitter.com/" target="_blank" title="twitter">
                            <i class="fa fa-twitter"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="https://www.facebook.com/" target="_blank" title="facebook">
                            <i class="fa fa-facebook"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="https://dribbble.com/" target="_blank" title="dribbble">
                            <i class="fa fa-dribbble"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/atom.xml" target="_blank" title="rss">
                            <i class="fa fa-rss"></i>
                        </a>
                    </td>
                    
                </tr>
            </table>
        </div>
        
    </div>
</aside>

            
            <section id="main">
    <article id="post-Flex布局教程链接" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2016/03/09/Flex布局教程链接/">Flex布局教程链接</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2016/03/09/Flex布局教程链接/">
            <time datetime="2016-03-09T08:03:12.000Z" itemprop="datePublished">2016-03-09</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/web/">web</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/h5/">h5</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h1 id="Flex布局教程链接"><a href="#Flex布局教程链接" class="headerlink" title="Flex布局教程链接"></a>Flex布局教程链接</h1><p>[语法篇]<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?^%$" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?^%$</a><br>[实例篇]<a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-examples.html</a></p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

            
    
        <a href="http://b.nearby.ren/2016/03/09/Flex布局教程链接/#comments" class="article-comment-link">评论</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-设计模式中类的关系" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2016/02/24/设计模式中类的关系/">设计模式中类的关系</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2016/02/24/设计模式中类的关系/">
            <time datetime="2016-02-24T07:28:13.000Z" itemprop="datePublished">2016-02-24</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/java/">java</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/设计模式/">设计模式</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>在Java以及其他的面向对象设计模式中，类与类之间主要有6种关系，他们分别是：依赖、关联、聚合、组合、继承、实现。他们的耦合度依次增强。</p>
<ul>
<li>依赖（Dependence）<a href="https://github.com/mccappcom/DesignPattern/raw/master/assets/uml1.gif" target="_blank" rel="noopener"><img src="https://github.com/mccappcom/DesignPattern/raw/master/assets/uml1.gif" alt=""></a><br><img src="https://github.com/mccappcom/DesignPattern/raw/master/assets/uml2.gif" alt=""><br>依赖关系的定义为：对于两个相对独立的对象，当一个对象负责构造另一个对象的实例，或者依赖另一个对象的服务时，这两个对象之间主要体现为依赖关系。定义比较晦涩难懂，但在java中的表现还是比较直观的：类A当中使用了类B，其中类B是作为类A的方法参数、方法中的局部变量、或者静态方法调用。类上面的图例中：People类依赖于Book类和Food类，Book类和Food类是作为类中方法的参数形式出现在People类中的。</li>
</ul>
<p><strong>代码样例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(Book book)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">"读的书是"</span>+book.getName());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>关联（Association）<img src="https://github.com/mccappcom/DesignPattern/raw/master/assets/uml3.gif" alt=""><img src="https://github.com/mccappcom/DesignPattern/raw/master/assets/uml4.gif" alt=""><img src="https://github.com/mccappcom/DesignPattern/raw/master/assets/uml5.gif" alt=""><br><strong>单项关联：</strong><br><img src="https://github.com/mccappcom/DesignPattern/raw/master/assets/uml6.gif" alt=""><br><strong>双向关联：</strong><br><img src="https://github.com/mccappcom/DesignPattern/raw/master/assets/uml7.gif" alt=""></li>
</ul>
<p>对于两个相对独立的对象，当一个对象的实例与另一个对象的一些特定实例存在固定的对应关系时，这两个对象之间为关联关系。关联关系分为单向关联和双向关联。在java中，单向关联表现为：类A当中使用了类B，其中类B是作为类A的成员变量。双向关联表现为：类A当中使用了类B作为成员变量；同时类B中也使用了类A作为成员变量。</p>
<p><strong>代码样例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Father father = <span class="keyword">new</span> Father();</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">"从"</span>+father.getName()+<span class="string">"获得礼物"</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Son son = <span class="keyword">new</span> Son();</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">"从"</span>+son.getName()+<span class="string">"获得礼物"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>聚合（Aggregation）<img src="https://github.com/mccappcom/DesignPattern/raw/master/assets/uml8.gif" alt=""><br><img src="https://github.com/mccappcom/DesignPattern/raw/master/assets/uml9.gif" alt=""></li>
</ul>
<p>聚合关系是关联关系的一种，耦合度强于关联，他们的代码表现是相同的，仅仅是在语义上有所区别：关联关系的对象间是相互独立的，而聚合关系的对象之间存在着包容关系，他们之间是“整体-个体”的相互关系。</p>
<p><strong>代码样例：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	Car car;</span><br><span class="line"></span><br><span class="line">	House house;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(Car car)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">this</span>.car = car;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHouse</span><span class="params">(House house)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">this</span>.house = house;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">driver</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">			System.out.println(<span class="string">"车型号:"</span>+car.getType());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">			System.out.println(<span class="string">"我在房子里睡觉:"</span>+house.getAddress());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>组合（Composition）<img src="https://github.com/mccappcom/DesignPattern/raw/master/assets/uml10.gif" alt=""><br><img src="https://github.com/mccappcom/DesignPattern/raw/master/assets/uml11.gif" alt=""></li>
</ul>
<p>相比于聚合，组合是一种耦合度更强的关联关系。存在组合关系的类表示“整体-部分”的关联关系，“整体”负责“部分”的生命周期，他们之间是共生共死的；并且“部分”单独存在时没有任何意义。在下图的例子中，People与Soul、Body之间是组合关系，当人的生命周期开始时，必须同时有灵魂和肉体；当人的生命周期结束时，灵魂肉体随之消亡；无论是灵魂还是肉体，都不能单独存在，他们必须作为人的组成部分存在。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	Soul soul;</span><br><span class="line"></span><br><span class="line">	Body body;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(Soul soul,Body body)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">this</span>.soul = soul;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">this</span>.body = body;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">			System.out.println(<span class="string">"学习要灵魂:"</span>+soul.getName());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">			System.out.println(<span class="string">"吃饭需要身体:"</span>+body.getName());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>继承（GeneraliZation）<img src="https://github.com/mccappcom/DesignPattern/raw/master/assets/uml12.gif" alt=""><br><img src="https://github.com/mccappcom/DesignPattern/raw/master/assets/uml13.gif" alt=""></li>
</ul>
<p>继承表示类与类（或者接口与接口）之间的父子关系。在java中，用关键字extends表示继承关系。UML图例中，继承关系用实线+空心箭头表示，箭头指向父类。</p>
<ul>
<li>实现（Implementation）<img src="https://github.com/mccappcom/DesignPattern/raw/master/assets/uml14.gif" alt=""><br><img src="https://github.com/mccappcom/DesignPattern/raw/master/assets/uml15.gif" alt=""></li>
</ul>
<p>表示一个类实现一个或多个接口的方法。接口定义好操作的集合，由实现类去完成接口的具体操作。在java中使用implements表示。UML图例中，实现关系用虚线+空心箭头表示，箭头指向接口。</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

            
    
        <a href="http://b.nearby.ren/2016/02/24/设计模式中类的关系/#comments" class="article-comment-link">评论</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-service详解" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2016/01/18/service详解/">service详解</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2016/01/18/service详解/">
            <time datetime="2016-01-18T06:00:17.000Z" itemprop="datePublished">2016-01-18</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/android/">android</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/service/">service</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <blockquote>
<p><strong>android server 详解</strong></p>
<p> Service的种类：</p>
<p>一、Service的种类</p>
</blockquote>
<ol>
<li>本地服务， Local Service<br>用于应用程序内部。在Service可以调用Context.startService()启动，调用Context.stopService()结束。在内部可以调用Service.stopSelf()<br>或<br>Service.stopSelfResult()来自己停止。无论调用了多少次startService()，都只需调用一次stopService()来停止。</li>
<li>远程服务， Remote Service<br>用于android系统内部的应用程序之间。可以定义接口并把接口暴露出来，以便其他应用进行操作。客户端建立到服务对象的连接，并通过那个连接来调用服务。调用Context.bindService()方法建立连接，并启动，以调用<br>Context.unbindService()关闭连接。多个客户端可以绑定至同一个服务。如果服务此时还没有加载，bindService()会先加载它。</li>
</ol>
<p>提供给可被其他应用复用，比如定义一个天气预报服务，提供与其他应用调用即可。</p>
<blockquote>
<p> 二、生命周期</p>
</blockquote>
<p>1). 被启动的服务的生命周期：如果一个Service被某个Activity 调用 Context.startService方法启动，那么不管是否有Activity使用bindService绑定或unbindService解除绑定到该Service，该Service都在后台运行。如果一个Service被startService 方法多次启动，那么onCreate方法只会调用一次，onStart将会被调用多次（对应调用startService的次数），并且系统只会创建Service的一个实例（因此你应该知道只需要一次stopService调用）。该Service将会一直在后台运行，而不管对应程序的Activity是否在运行，直到被调用stopService，或自身的stopSelf方法。当然如果系统资源不足，android系统也可能结束服务。</p>
<p>2). 被绑定的服务的生命周期：如果一个Service被某个Activity 调用 Context.bindService 方法绑定启动，不管调用 bindService调用几次，onCreate方法都只会调用一次，同时onStart方法始终不会被调用。当连接建立之后，Service将会一直运行，除非调用Context.unbindService 断开连接或者之前调用bindService 的 Context 不存在了（如Activity被finish的时候），系统将会自动停止Service，对应onDestroy将被调用。</p>
<p>3).被启动又被绑定的服务的生命周期：如果一个Service又被启动又被绑定，则该Service将会一直在后台运行。并且不管如何调用，onCreate始终只会调用一次，对应startService调用多少次，Service的onStart便会调用多少次。调用unbindService将不会停止Service，而必须调用 stopService 或 Service的 stopSelf 来停止服务。</p>
<p>4).当服务被停止时清除服务：当一个Service被终止（1、调用stopService；2、调用stopSelf；3、不再有绑定的连接（没有被启动））时，onDestroy方法将会被调用，在这里你应当做一些清除工作，如停止在Service中创建并运行的线程。</p>
<blockquote>
<p>特别注意：</p>
</blockquote>
<ol>
<li><p>你应当知道在调用 bindService 绑定到Service的时候，你就应当保证在某处调用 unbindService<br>解除绑定（尽管Activity被finish的时候绑定会自动解除，并且Service会自动停止）</p>
</li>
<li><p>你应当注意 使用 startService 启动服务之后，一定要使用<br>stopService停止服务，不管你是否使用bindService。</p>
</li>
<li><p>同时使用 startService 与 bindService 要注意到，Service<br>的终止，需要unbindService与stopService同时调用，才能终止 Service，不管 startService 与<br>bindService 的调用顺序，如果先调用 unbindService 此时服务不会自动终止，再调用 stopService<br>之后服务才会停止，如果先调用 stopService 此时服务也不会终止，而再调用 unbindService 或者 之前调用<br>bindService 的 Context 不存在了（如Activity 被 finish 的时候）之后服务才会自动停止。</p>
</li>
<li><p>当在旋转手机屏幕的时候，当手机屏幕在“横”“竖”变换时，此时如果你的 Activity 如果会自动旋转的话，旋转其实是 Activity<br>的重新创建，因此旋转之前的使用 bindService 建立的连接便会断开（Context 不存在了），对应服务的生命周期与上述相同</p>
</li>
<li><p>在 sdk 2.0 及其以后的版本中，对应的 onStart 已经被否决变为了 onStartCommand，不过之前的 onStart<br>任然有效。这意味着，如果你开发的应用程序用的 sdk 为 2.0 及其以后的版本，那么你应当使用 onStartCommand 而不是<br>onStart。<br><img src="http://static.oschina.net/uploads/space/2015/0730/095222_Jssm_1175007.png" alt="此处输入图片的描述"></p>
</li>
</ol>
<blockquote>
<p>例子：</p>
</blockquote>
<pre><code>    public class ServiceDemo extends Service {

    public static final String TAG = &quot;ServiceDemo&quot; ;
    public static final String ACTION = &quot;com.demo.SERVICE_DEMO&quot;;

    /**
     * onBind 是 Service 的虚方法，因此我们不得不实现它。
     * 返回 null，表示客服端不能建立到此服务的连接，所以不会调用onServiceConnected。
     */
    @Override
    public IBinder onBind(Intent intent) {
        Log.i(TAG, this.toString() + &quot; ServiceDemo onBind&quot;);
        return null;
    }

    @Override
    public void onCreate() {
        Log.i(TAG, this.toString() + &quot; ServiceDemo onCreate&quot;);
        super.onCreate();
    }

    @Override
    public void onStart(Intent intent, int startId) {
    Log.i(TAG, this.toString() + &quot; ServiceDemo onStart&quot;);
    super.onStart(intent, startId);
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        Log.i(TAG, this.toString() + &quot; ServiceDemo onStartCommand&quot;);
        return super.onStartCommand(intent, flags, startId);
    }

    @Override
    public boolean onUnbind(Intent intent) {
        Log.i(TAG, this.toString() + &quot; ServiceDemo onUnbind&quot;);
        return super.onUnbind(intent);
    }

    @Override
    public void onDestroy() {
        Log.i(TAG, this.toString() + &quot; ServiceDemo onDestroy&quot;);
        super.onDestroy();
    }

}
&lt;!-- android:exported 这个属性用于指示该服务是否能够被其他应用程序组件调用或跟它交互。
     如果设置为true，则能够被调用或交互，否则不能。设置为false时，
     只有同一个应用程序的组件或带有相同用户ID的应用程序才能启动或绑定该服务。--&gt;
&lt;service android:name=&quot;.ServiceDemo&quot; android:exported=&quot;false&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;com.demo.SERVICE_DEMO&quot; /&gt;
        &lt;category android:name=&quot;android.intent.category.default&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/service&gt;

通过Context.startService(Intent)方法启动service或者Context.bindService方法来绑定service


    public class MainActivity extends ActionBarActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        findViewById(R.id.btn_bindService).setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
            bindService(new Intent(ServiceDemo.ACTION), conn, BIND_AUTO_CREATE);
        }
    });

        findViewById(R.id.btn_unbindService).setOnClickListener(new OnClickListener() {
            @Override
        public void onClick(View v) {
        unbindService(conn);
        }
    });

        findViewById(R.id.btn_startService).setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
            startService(new Intent(ServiceDemo.ACTION));
            }
        });

        findViewById(R.id.btn_stopService).setOnClickListener(new OnClickListener() {
        @Override
        public void onClick(View v) {
        stopService(new Intent(ServiceDemo.ACTION));
        }
    });
    }

    ServiceConnection conn = new ServiceConnection() {
        public void onServiceConnected(ComponentName name, IBinder service) {
            Log.i(ServiceDemo.TAG, service.toString() + &quot; onServiceConnected&quot;);
        }
    public void onServiceDisconnected(ComponentName name) {
        Log.i(ServiceDemo.TAG, &quot;onServiceDisconnected&quot;);
    }
    };

    @Override
    protected void onDestroy() {
        super.onDestroy();
    }
}
</code></pre><p>  <img src="http://static.oschina.net/uploads/space/2015/0730/160834_rK7t_1175007.png" alt="此处输入图片的描述"></p>
<blockquote>
<p>日志输出：</p>
</blockquote>
<p><img src="http://static.oschina.net/uploads/space/2015/0730/160949_ye2r_1175007.png" alt="此处输入图片的描述"><br>上面的截图是点击绑定服务时输出的。可以看出，只调用了onCreate方法和onBind方法，当重复点击绑定服务时，没有再输出任何日志，并且不报错。onCreate方法是在第一次创建Service时调用的，而且只调用一次。另外，在绑定服务时，给定了参数BIND_AUTO_CREATE，即当服务不存在时，自动创建，如果服务已经启动了或者创建了，那么只会掉调用onBind方法。<br><img src="http://static.oschina.net/uploads/space/2015/0730/161109_fGYl_1175007.png" alt="此处输入图片的描述"><br>当解除绑定的时，可以看出，Service调用onUnbind和onDestroy销毁了服务。<br><img src="http://static.oschina.net/uploads/space/2015/0730/161604_zRTz_1175007.png" alt="此处输入图片的描述"><br>上面的截图是在多次点击启动服务时输出的。可以看出，在第一次点击时，因为Service还未创建，所以调用了onCreate方法，紧接着调用了onStartCommand和onStart方法。当再次点击启动服务时，仍然调用了onStartCommand和onStart方法，所以，在Service中做任务处理时需要注意这点，因为一个Service可以被重复启动。<br><img src="http://static.oschina.net/uploads/space/2015/0730/161711_V5xw_1175007.png" alt="此处输入图片的描述"><br>当点停止服务的时，Service只是执行onDestroy方法，跟绑定还是有点小区别。<br>这里说一下，平常使用多的是startService方法，可以把一些耗时的任务放到后台去处理，当处理完成后，可以通过广播来通知前台。<br>而onBind方法更多的是结合AIDL来使用，这样一个应用可以通过绑定服务获得的IBinder来拿到后台的接口，进而调用AIDL中定义的方法，进行数据交换等。</p>
<blockquote>
<p>三、Local 与 Remote 服务绑定</p>
</blockquote>
<p>1) Local 服务绑定：Local 服务的绑定较简单，首先在 Service 中我们需要实现 Service 的抽象方法 onBind，并返回一个实现 IBinder 接口的对象。</p>
<p>Service 中的代码：</p>
<pre><code>    public class LocalService extends Service{

    public static final String TAG = &quot;LocalService&quot; ;
    public static final String ACTION = &quot;com.demo.LOCAL_SERVICE&quot;;
    public SimpleBinder sBinder;

    public class SimpleBinder extends Binder{

        public LocalService getService(){
            return LocalService.this;
        }

        public int add(int a, int b){
            return a + b;
        }
    }

    @Override
    public void onCreate() {
    super.onCreate();
    // 创建 SimpleBinder
        sBinder = new SimpleBinder();
    }

    @Override
    public IBinder onBind(Intent intent) {
    // 返回 SimpleBinder 对象
    Log.i(TAG, &quot;LocalService onBind&quot;);
        return sBinder;
    }

    @Override
    public boolean onUnbind(Intent intent) {
    Log.i(TAG, &quot;LocalService onUnbind&quot;);
    return super.onUnbind(intent);
    }

}
&lt;service android:name=&quot;.LocalService&quot; android:exported=&quot;false&quot;&gt;
    &lt;intent-filter&gt;
    &lt;action android:name=&quot;com.demo.LOCAL_SERVICE&quot; /&gt;
    &lt;category android:name=&quot;android.intent.category.default&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/service&gt;
public class LocalActivity extends ActionBarActivity {

    private ServiceConnection sc;
    private boolean isBind;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_local);

    sc = new ServiceConnection() {

            @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            Log.i(LocalService.TAG, &quot;onServiceConnected&quot;);
        LocalService.SimpleBinder sBinder = (LocalService.SimpleBinder)service;
                Log.i(LocalService.TAG, &quot;3 + 5 = &quot; + sBinder.add(3, 5));
        }

            @Override
            public void onServiceDisconnected(ComponentName name) {
                Log.i(LocalService.TAG, &quot; onServiceDisconnected&quot;);
            }
        };

        findViewById(R.id.btn_bindService).setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                bindService(new Intent(LocalService.ACTION), sc, Context.BIND_AUTO_CREATE);
                isBind = true;
            }
        });
        findViewById(R.id.btn_unbindService).setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                if(isBind){
                    unbindService(sc);
                    isBind = false;
                }
            }
        });
    }
}
</code></pre><p>在 Activity 中，我们通过 ServiceConnection 接口来取得建立连接 与 连接意外丢失的回调。bindService有三个参数，第一个是用于区分 Service 的Intent 与 startService 中的 Intent 一致，第二个是实现了 ServiceConnection 接口的对象，最后一个是 flag 标志位。有两个flag，BIND_DEBUG_UNBIND 与 BIND_AUTO_CREATE，前者用于调试（详细内容可以查看javadoc 上面描述的很清楚），后者默认使用。unbindService 解除绑定，参数则为之前创建的 ServiceConnection 接口对象。另外，多次调用 unbindService 来释放相同的连接会抛出异常，因此我创建了一个 boolean 变量来判断是否 unbindService 已经被调用过。</p>
<p>运行结果：<br><img src="http://static.oschina.net/uploads/space/2015/0730/173329_fLfe_1175007.png" alt="此处输入图片的描述"></p>
<p>在绑定服务的时候，需要一个服务连接对象，ServiceConnection，服务一旦连接，就会调用onServiceConnected方法，我们可以在这个方法里面返回我们的本地服务对象，具体看代码；而在服务断开时候会调用onServiceDisconnected方法，我们可以清理一些服务资源。</p>
<p>2) Remote 服务绑定：之前所谈的Service属于Local Service，即Service和Client在同一进程内（即同一application内），Service的生命周期服从进程的生命周期。在实际应用上，有时希望Service作为后台服务，不仅被同一进程内的activity使用，也可被其他进程所使用。</p>
<p>通常每个应用程序都在它自己的进程内运行，但有时需要在进程之间传递对象（IPC通信），你可以通过应用程序UI的方式写个运行在一个不同的进程中的service。在android平台中，一个进程通常不能访问其它进程中的内存区域。所以，他们需要把对象拆分成操作系统能理解的简单形式，以便伪装成对象跨越边界访问。编写这种伪装代码相当的枯燥乏味，好在android为我们提供了AIDL工具可以来做这件事。</p>
<p>AIDL(android接口描述语言)是一个IDL语言，它可以生成一段代码，可以使在一个android设备上运行的两个进程使用内部通信进程进行交互。如果你需要在一个进程中(例如在一个Activity中)访问另一个进程中(例如一个Service)某个对象的方法，你就可以使用AIDL来生成这样的代码来伪装传递各种参数。</p>
<p> <img src="http://static.oschina.net/uploads/space/2015/0802/170432_x9mE_1175007.png" alt="此处输入图片的描述"><br> Android提供AIDL（Android Interface Definition Language）工具帮助IPC之间接口的建立，大大地简化了开发者视图。通过下面的步骤实现client和service之间的通信：<br>1）定义AIDL接口 ，Eclipse将自动为Service建立接口IService<br>2）Client连接Service，连接到IService暴露给Client的Stub，获得stub对象；换句话，Service通过接口中的Stub向client提供服务，在IService中对抽象IService.Stub具体实现。<br>3）Client和Service连接后，Client可向使用本地方法那样，简单地直接调用IService.Stub里面的方法。<br>下面的例子给出client从提供定时计数的Remote Service，称为TestRemoteService，中获得服务的例子。</p>
<p><strong>步骤1：通过AIDL文件定义Service向client提供的接口，ITestRemoteService.aidl文件如下</strong></p>
<pre><code>interface ITestRemoteService {
    int getCounter();
}

我们在src的目录下添加一个ITestRemoteService.aidl文件，语法和java的相同。在这个例子中Service很简单，只提供计数器的值，故在接口中我们定义了int getCounter( )。
</code></pre><p>AIDL文件很简单，Eclipse会根据文件自动生成相关的一个java interface文件，不过没有显示出来，如果直接使用命令行工具会帮助生成java文件。</p>
<p><strong>步骤2：Remote Service的编写，通过onBind()，在client连接时，传递stub对象。 TestRemoteService.java文件如下</strong>：</p>
<pre><code>//Service提供一个定时计数器，采用Runnable的方式实现。
public class TestRemoteService extends Service{
    private Handler serviceHandler = null;
    private int counter = 0;
    private TestCounterTask myTask = new TestCounterTask();

    public void onCreate() {
        super.onCreate();
        showInfo(&quot;remote service onCreate()&quot;);
    }

    public void onDestroy() {
        super.onDestroy();
        serviceHandler.removeCallbacks(myTask); //停止计数器
        serviceHandler = null;
        showInfo(&quot;remote service onDestroy()&quot;);
    }

    public void onStart(Intent intent, int startId) {
       // 开启计数器
        super.onStart(intent, startId);
        serviceHandler=new Handler();
        serviceHandler.postDelayed(myTask, 1000);
        showInfo(&quot;remote service onStart()&quot;);
    }

   //步骤2.1：具体实现接口中暴露给client的Stub，提供一个stub inner class来具体实现。
    private ITestRemoteService.Stub stub= new ITestRemoteService.Stub() {
       //步骤2.1：具体实现AIDL文件中接口的定义的各个方法。
        public int getCounter() throws RemoteException {
            showInfo(&quot;getCounter()&quot;);
            return counter;
        }
    };

//步骤2.2：当client连接时，将触发onBind()，Service向client返回一个stub对象，
//由此client可以通过stub对象来访问Service，本例中通过stub.getCounter()就可以获得计时器的当前计数。
//在这个例子中，我们向所有的client传递同一stub对象。
   public IBinder onBind(Intent arg0) {
   //我们特别跟踪了stub对象的地址，可以在client连接service中看看通过ServiceConnection传递给client
        showInfo(&quot;onBind() &quot; + stub);
        return stub;
   }

    //用Runnable使用定时计数器，每10秒计数器加1。
    private class TestCounterTask implements Runnable{
        public void run() {
            ++ counter;
            serviceHandler.postDelayed(myTask,10000);
            showInfo(&quot;running &quot; + counter);
        }
    }
    //showInfo() 帮助我们进行信息跟踪，更好了解Service的运行情况
    private void showInfo(String s){
        System.out.println(&quot;[&quot; +getClass().getSimpleName()+&quot;@&quot; + Thread.currentThread().getName()+ &quot;] &quot; + s);
    }
}
</code></pre><p><img src="http://static.oschina.net/uploads/space/2015/0802/171454_Lix4_1175007.png" alt="此处输入图片的描述"></p>
<p><strong>步骤3：Client和Service建立连接，获得stub，ServiceTest4.java代码如下</strong></p>
<pre><code>public class ServiceTest4 extends Activity{

    //步骤3.1 定义接口变量
    private ITestRemoteService remoteService = null;
    private boolean isStarted = false;
    //步骤3.1 定义连接变量，实现ServiceConnection接口
    private CounterServiceConnection conn = null;

    protected void onCreate(Bundle savedInstanceState) {
        //5个button分别触发startService( )，stopService( ) ,
        //bindService( ), releaseService( )和invokeService( )，
        //下面两行，一行是显示从Service中获得的计数值，一行显示状态。
    }

    private void startService(){
        Intent i = new Intent();
        //我的这个包里面还有层次，如*.part1、*.part2,etc
        i.setClassName(&quot;com.wei.android.learning&quot;, &quot;com.wei.android.learning.part5.TestRemoteService&quot;);
//和之前的local service一样，通过intent开启Service，触发onCreate()[if Service没有开启]-&gt;onStart()
        startService(i);
        isStarted = true;
        updateServiceStatus();
    }
    private void stopService(){
        Intent i = new Intent();
        i.setClassName(&quot;com.wei.android.learning&quot;,&quot;com.wei.android.learning.part5.TestRemoteService&quot;);
        stopService(i); //触发Service的 onDestroy()[if Service存在]
        isStarted = false;
        updateServiceStatus();
    }
   //步骤3.3：bindService( )通过一个实现ServiceConnection接口的类于Service之间建立连接，
   //注意到里面的参数Context.BIND_AUTO_CREATE，触发onCreate()[if Service不存在] –&gt; onBind().
    private void bindService(){
        if(conn == null){
            conn = new CounterServiceConnection();
            Intent i = new Intent();
            i.setClassName(&quot;com.wei.android.learning&quot;,&quot;com.wei.android.learning.part5.TestRemoteService&quot;);
           bindService(i, conn,Context.BIND_AUTO_CREATE);
            updateServiceStatus();
        }
    }

    private void releaseService(){
        if(conn !=null){
            unbindService(conn); //断开连接，解除绑定
            conn = null;
            updateServiceStatus();
        }
    }
    private void invokeService(){
        if(conn != null){
            try{
            //一旦client成功绑定到Service，就可以直接使用stub中的方法。
                Integer counter =remoteService.getCounter();
                TextView t = (TextView)findViewById(R.id.st4_notApplicable);
                t.setText(&quot;Counter value : &quot; + Integer.toString(counter));
            }catch(RemoteException e){
                Log.e(getClass().getSimpleName(),e.toString());
            }
        }
    }
    //步骤3.2 class CounterServiceConnection实现ServiceConnection接口，
    //需要具体实现里面两个触发onServiceConnected()和onServiceDisconnected()
    private class CounterServiceConnection implements ServiceConnection{
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            // 从连接中获得stub对象，根据我们的跟踪，remoteService就是service中的stub对象
            remoteService = ITestRemoteService.Stub.asInterface(service);
            showInfo(&quot;onServiceConnected()&quot; + remoteService);
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
            remoteService = null;
            updateServiceStatus();
            showInfo(&quot;onServiceDisconnected&quot;);
        }
    }

    private void updateServiceStatus() {
        TextView t = (TextView)findViewById( R.id.st4_serviceStatus);
        t.setText( &quot;Service status: &quot;+(conn == null ? &quot;unbound&quot; : &quot;bound&quot;)+ &quot;,&quot;+ (isStarted ? &quot;started&quot; : &quot;not started&quot;; ));
      }

    private void showInfo(String s){
        System.out.println(&quot;[&quot; +getClass().getSimpleName()+&quot;@&quot; + Thread.currentThread().getName()+ &quot;] &quot; + s);
    }
}
</code></pre><p> <img src="http://static.oschina.net/uploads/space/2015/0802/171402_Rt1I_1175007.png" alt="此处输入图片的描述"></p>
<p> 注意：</p>
<p>Service.onBind如果返回null，则调用 bindService 会启动 Service，但不会连接上 Service，因此 ServiceConnection.onServiceConnected 不会被调用，但你任然需要使用 unbindService 函数断开它，这样 Service 才会停止。</p>
<p>其它：</p>
<p>1、在什么情况下使用 startService 或 bindService 或 同时使用startService 和 bindService</p>
<p>如果你只是想要启动一个后台服务长期进行某项任务那么使用 startService 便可以了。如果你想要与正在运行的 Service 取得联系，那么有两种方法，一种是使用 broadcast ，另外是使用 bindService ，前者的缺点是如果交流较为频繁，容易造成性能上的问题，并且 BroadcastReceiver 本身执行代码的时间是很短的（也许执行到一半，后面的代码便不会执行），而后者则没有这些问题，因此我们肯定选择使用 bindService（这个时候你便同时在使用 startService 和 bindService 了，这在 Activity 中更新 Service 的某些运行状态是相当有用的）。另外如果你的服务只是公开一个远程接口，供连接上的客服端（android 的 Service 是C/S架构）远程调用执行方法。这个时候你可以不让服务一开始就运行，而只用 bindService ，这样在第一次 bindService 的时候才会创建服务的实例运行它，这会节约很多系统资源，特别是如果你的服务是Remote Service，那么该效果会越明显（当然在 Service 创建的时候会花去一定时间，你应当注意到这点）。</p>
<p>2、在 AndroidManifest.xml 里 Service 元素的常见选项</p>
<p>android:name，服务类名</p>
<p>android:label，服务的名字，如果此项不设置，那么默认显示的服务名则为类名</p>
<p>android:icon，服务的图标</p>
<p>android:permission，申明此服务的权限，这意味着只有提供了该权限的应用才能控制或连接此服务</p>
<p>android:process，表示该服务是否运行在另外一个进程，如果设置了此项，那么将会在包名后面加上这段字符串表示另一进程的名字</p>
<p>android:enabled，如果此项设置为 true，那么 Service 将会默认被系统启动，不设置默认此项为 false</p>
<p>android:exported，表示该服务是否能够被其他应用程序所控制或连接，不设置默认此项为 false</p>
<p>3、Service 与 Thread 的区别</p>
<p>很多时候，你可能会问，为什么要用 Service，而不用 Thread 呢，因为用 Thread 是很方便的，比起 Service 也方便多了，下面我详细的来解释一下。</p>
<p>1). Thread：Thread 是程序执行的最小单元，它是分配CPU的基本单位。可以用 Thread 来执行一些异步的操作。</p>
<p>2). Service：Service 是android的一种机制，当它运行的时候如果是Local Service，那么对应的 Service 是运行在主进程的 main 线程上的。如：onCreate，onStart 这些函数在被系统调用的时候都是在主进程的 main 线程上运行的。如果是Remote Service，那么对应的 Service 则是运行在独立进程的 main 线程上。因此请不要把 Service 理解成线程，它跟线程半毛钱的关系都没有！</p>
<p>既然这样，那么我们为什么要用 Service 呢？其实这跟 android 的系统机制有关，我们先拿 Thread 来说。Thread 的运行是独立于 Activity 的，也就是说当一个 Activity 被 finish 之后，如果你没有主动停止 Thread 或者 Thread 里的 run 方法没有执行完毕的话，Thread 也会一直执行。因此这里会出现一个问题：当 Activity 被 finish 之后，你不再持有该 Thread 的引用。另一方面，你没有办法在不同的 Activity 中对同一 Thread 进行控制。</p>
<p>举个例子：如果你的 Thread 需要不停地隔一段时间就要连接服务器做某种同步的话，该 Thread 需要在 Activity 没有start的时候也在运行。这个时候当你 start 一个 Activity 就没有办法在该 Activity 里面控制之前创建的 Thread。因此你便需要创建并启动一个 Service ，在 Service 里面创建、运行并控制该 Thread，这样便解决了该问题（因为任何 Activity 都可以控制同一 Service，而系统也只会创建一个对应 Service 的实例）。</p>
<p>因此你可以把 Service 想象成一种消息服务，而你可以在任何有 Context 的地方调用 Context.startService、Context.stopService、Context.bindService，Context.unbindService，来控制它，你也可以在 Service 里注册 BroadcastReceiver，在其他地方通过发送 broadcast 来控制它，当然这些都是 Thread 做不到的。</p>
<p>4、拥有service的进程具有较高的优先级</p>
<p>官方文档告诉我们，Android系统会尽量保持拥有service的进程运行，只要在该service已经被启动(start)或者客户端连接(bindService)到它。当内存不足时，需要保持，拥有service的进程具有较高的优先级。</p>
<p>1). 如果service正在调用onCreate,onStartCommand或者onDestory方法，那么用于当前service的进程则变为前台进程以避免被killed。</p>
<p>2). 如果当前service已经被启动(start)，拥有它的进程则比那些用户可见的进程优先级低一些，但是比那些不可见的进程更重要，这就意味着service一般不会被killed.</p>
<p>3). 如果客户端已经连接到service (bindService),那么拥有Service的进程则拥有最高的优先级，可以认为service是可见的。</p>
<p>4). 如果service可以使用startForeground(int, Notification)方法来将service设置为前台状态，那么系统就认为是对用户可见的，并不会在内存不足时killed。</p>
<p>如果有其他的应用组件作为Service,Activity等运行在相同的进程中，那么将会增加该进程的重要性。</p>
<p>5、注意事项</p>
<p>Service的onCreate的方法只会被调用一次，就是你无论多少次的startService又 bindService，Service只被创建一次。如果先是bind了，那么start的时候就直接运行Service的onStart方法，如果先是start，那么bind的时候就直接运行onBind方法。如果你先bind上了，就stop不掉了，只能先UnbindService, 再StopService,所以是先start还是先bind行为是有区别的。</p>
<p>Android中的服务和windows中的服务是类似的东西，服务一般没有用户操作界面，它运行于系统中不容易被用户发觉，可以使用它开发如监控之类的 程序。</p>
<p>服务不能自己运行，需要通过调用Context.startService()或Context.bindService()方法启动服务。</p>
<p>这两个方法都可以启动Service，但是它们的使用场合有所不同。使用startService()方法启用服务，调用者与服务之间没有关连，即使调用者退出了，服务仍然运行。使用bindService()方法启用服务，调用者与服务绑定在了一起，调用者一旦退出，服务也就终止，大有“不求同 时生，必须同时死”的特点。</p>
<p>如果打算采用Context.startService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onStart()方法。如果调用startService()方法前服务已经被创建，多次调用startService()方法并不会导致多次 创建服务，但会导致多次调用onStart()方法。采用startService()方法启动的服务，只能调用Context.stopService()方法结 束服务，服务结束时会调用onDestroy()方法。</p>
<p>如果打算采用Context.bindService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onBind()方法。这个时候调用者和服务绑定在一起，调用者退出了，系统就会先调用服务的onUnbind()方法，接着调用onDestroy()方法。如果调用bindService()方法前服务已经被绑定，多次调用bindService()方法并不会导致多次创建服务及绑定(也就是说onCreate()和onBind()方法并不会被多次调用)。</p>
<p>如果调用者希望与正在绑定的服务解除绑定，可以调用unbindService()方法，调用该方法也会导致系统调用服务的 onUnbind()–&gt;onDestroy()方法.</p>
<p>原文地址：<a href="http://aswang.iteye.com/blog/1424309" target="_blank" rel="noopener">http://aswang.iteye.com/blog/1424309</a></p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

            
    
        <a href="http://b.nearby.ren/2016/01/18/service详解/#comments" class="article-comment-link">评论</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-淘汰" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2015/12/17/淘汰/">淘汰</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2015/12/17/淘汰/">
            <time datetime="2015-12-17T01:24:27.000Z" itemprop="datePublished">2015-12-17</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/文字/">文字</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/歌曲/">歌曲</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>陈奕迅 - 淘汰<br>曲 : 周杰伦 词：周杰伦</p>
<p>我说了 所有的谎<br>你全都相信<br>简单的 我爱你<br>你却老不信<br>你书里的剧情<br>我不想上演<br>因为我喜欢 喜剧收尾</p>
<p>我试过 完美放弃<br>的确很踏实<br>醒来了<br>梦散了<br>你我都走散了<br>情歌歌词何必押韵<br>就算我是K歌之王<br>也不见得把 爱情唱得完美</p>
<p>只能说我输了<br>也许是你怕了<br>我们的回忆 没有皱褶<br>你却用离开烫下句点<br>只能说我认了<br>你的不安赢得你信任<br>我却得到你 安慰的淘汰</p>
<p>我试过完美放弃<br>的确很踏实<br>醒来了<br>梦散了<br>你我都走散了<br>情歌歌词何必押韵<br>就算我是K歌之王<br>也不见得把 爱情唱得完美</p>
<p>只能说我输了<br>也许是你怕了<br>我们的回忆 没有皱褶<br>你却用离开烫下句点<br>只能说我认了<br>你的不安赢得你信任<br>我却得到你 安慰的淘汰</p>
<p>只能说我输了<br>也许是你怕了<br>我们的回忆 没有皱褶<br>你却用离开烫下句点<br>只能说我认了<br>你的不安赢得你信任<br>我却得到你 安慰的淘汰</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

            
    
        <a href="http://b.nearby.ren/2015/12/17/淘汰/#comments" class="article-comment-link">评论</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-offce001" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2015/12/14/offce001/">offce 001</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2015/12/14/offce001/">
            <time datetime="2015-12-14T04:12:55.000Z" itemprop="datePublished">2015-12-14</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/offce/">offce</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/offce/">offce</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>View的绘制流程、Activity、Window、View的关系<br>Activity启动时创建Window、ViewRoot并建立关联，流程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class ActivityThread &#123;</span><br><span class="line">  // startActivity最终会调用到这里</span><br><span class="line">  fun handleLaunchActivity()&#123;</span><br><span class="line">	// 1. performLaunchActivity() 创建activity</span><br><span class="line">    // 2. activity.attach() 内部创建了PhoneWindow</span><br><span class="line">    // 3. activity.onCreate() -&gt; setContentView，实际调用window的对应方法，创建DecorView </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  fun handleResumeActivity()&#123;</span><br><span class="line">    // 1. activity.onResume()</span><br><span class="line">    // 2. 获取activity的window对象，添加DecorView到WindowManagerGlobal中</span><br><span class="line">    // 3. WindowManagerGlobal.addView(DecorView)时，创建了ViewRootImpl，所有view绘制的工作都是</span><br><span class="line">    //		ViewRootImpl来调度，在这里才建立了ViewRootImpl和View的关联</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ViewRoot &#123;</span><br><span class="line">// ViewRoot添加view后，会执行ViewRoot.requestLayout</span><br><span class="line">// scheduleTraversals -&gt; 在消息队列中插入一个同步消息屏障,保证UI优先绘制 </span><br><span class="line">//  -&gt; 通过choreographer提交绘制任务，同时向底层请求sync信号，</span><br><span class="line">//  -&gt; 在下一次信号到来时JNI回调doTraversal，并移除屏障消息</span><br><span class="line">//  -&gt; doTraversal中调用了performMeasure、performLayout和performDraw进行测量、布局和绘制流程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>MeasureSpec是一个32位int值，高2位表示测量模式，后30位表示在该模式下的测量值，一个view的MeasureSpec由自己的LayoutParams和父View的MeasureSpec共同决定。测量过程实际是递归的测量子view后再设置自己的尺寸。</p>
<h1 id="onCreate、onResume中能否获取到View的宽高，为什么？"><a href="#onCreate、onResume中能否获取到View的宽高，为什么？" class="headerlink" title="onCreate、onResume中能否获取到View的宽高，为什么？"></a>onCreate、onResume中能否获取到View的宽高，为什么？</h1><p>由于View的measure过程和Activity的生命周期方法不是同步执行的，如果View还没有测量完毕，那么获得的宽/高就是0。所以在onCreate、onStart、onResume中均无法正确得到某个View的宽高信息。<br>解决方式如下：</p>
<p>1.view.post(runnable)，注意这里handler.post(runnable)是不行的，View.post会先判断attachInfo是否为空，如果为空就放到一个等待执行的队列中，等待View被添加（dispatchAttachedToWindow）之后才执行，这时测量已经完毕了，如果不为空，表示View已经被添加，就调用attachInfo中的Handler来post任务，所以是一定能获取到的。注意api23以下和以上的逻辑不一样：</p>
<p>Api23以下：调用的ViewRootImpl.getRunQueue().post()，执行时机是doTraversa()中，这个方法又是在下一个同步信号来的时候调用的，参考屏幕刷新机制。</p>
<p>Api23以上：调用的是getRunQueue().post() ，它的执行时机是View被添加之后执行，如果View只是创建出来没有被添加，那将一直得不到执行。</p>
<p>2.使用ViewTreeObserver</p>
<h1 id="卡顿原理、屏幕刷新机制、卡顿监控"><a href="#卡顿原理、屏幕刷新机制、卡顿监控" class="headerlink" title="卡顿原理、屏幕刷新机制、卡顿监控"></a>卡顿原理、屏幕刷新机制、卡顿监控</h1><h1 id="卡顿的根本原因：view在16ms内不能完成绘制造成掉帧，常见造成掉帧的原因又有："><a href="#卡顿的根本原因：view在16ms内不能完成绘制造成掉帧，常见造成掉帧的原因又有：" class="headerlink" title="卡顿的根本原因：view在16ms内不能完成绘制造成掉帧，常见造成掉帧的原因又有："></a>卡顿的根本原因：view在16ms内不能完成绘制造成掉帧，常见造成掉帧的原因又有：</h1><p>1.主线程有耗时操作（合理使用线程来执行耗时任务）<br>2.View本身太复杂、嵌套过多导致绘制超过16ms（优化View的层级、合理使用include、ViewStub标签）<br>3.内存抖动造成频繁GC，例如循环内部创建对象，onDraw中创建对象等。（优化内存泄漏、对一些需要频繁创建的对象采用对象池技术）</p>
<h1 id="屏幕刷新机制："><a href="#屏幕刷新机制：" class="headerlink" title="屏幕刷新机制："></a>屏幕刷新机制：</h1><p>1.基于handler消息队列，如BlockCanary，handler分发消息前后都会打印日志，可以自定义Printer，计算Looper两次获取消息的时间差，如果时间太长就说明Handler处理时间过长，直接把堆栈信息打印出来，就可以定位到耗时代码<br>2.代码插桩，在方法的前后插入计时代码来监控执行时间，缺点是包增大，无法监控系统方法，并且需要过滤简单方法<br>3.循环插入空消息到消息队列，监控这个消息的处理时间，例如每隔1秒插入一条空消息，如果这条消息处理时间间隔大于一定时间，则认为发生了卡顿</p>
<h1 id="RxJava的原理"><a href="#RxJava的原理" class="headerlink" title="RxJava的原理"></a>RxJava的原理</h1><p>Rxjava每个操作符会生成一个新的Observable,同时持有上游事件源和下游Observer，最终在subscribeActual中实现自己的操作逻辑，并连接上下游。<br>Rxjava有点像观察者模式和责任链模式的结合，普通的观察者模式一般是被观察者通知多个观察者，而Rxjava则是被观察者通知第一个Obsever,接下来Observer依次通知下一个节点的Observer，形成一个“观察链”，将观察者模式进行了一种类似链式的变换，每个节点又会执行它不同的“职责”。</p>
<p>1.SubscribeOn节点在订阅的时候，将它的上游节点的subscribe操作，以runnable的形式交给调度器在执行，在io调度器就是一个线程池，他影响的是事件源的发射行为，如果多次subscribeOn相当后一次subscribeOn把上一次subscribeOn行为在线程池里执行了一次，最终就只有最上边的一个起作用；<br>2.observeOn会将它下游的Observer放到切换的线程中执行，因此observeOn影响的是它的下游，多次调用影响的是这次到下一次observeOn之间的代码；</p>
<h1 id="Rxjava中调度器"><a href="#Rxjava中调度器" class="headerlink" title="Rxjava中调度器"></a>Rxjava中调度器</h1><p>Schedulers.io()：无边界线程池作为支撑的一个Scheduler，线程可以无限增长，它适用于非CPU密集的I/O工作，比如访问文件系统、执行网络调用、访问数据库等<br>Schedulers.computation()：用于执行CPU密集的工作，比如处理大规模的数据集、图像处理等等。它由一个有界的线程池作为支撑，线程的最大数量就是可用的处理器数量<br>Schedulers.newThread()：这个Scheduler 每次都会创建一个全新的线程来完成一组工作<br><strong>Schedulers.single()：</strong>只有一个线程作为支撑，只能按照有序的方式执行任务<br><strong>Schedulers.from(Executor executor)</strong>我们可以使用它创建自定义的Scheduler<br>AndroidSchedulers.mainThread()：Android主线程调度器</p>
<h1 id="事件分发机制"><a href="#事件分发机制" class="headerlink" title="事件分发机制"></a>事件分发机制</h1><p>事件传递的顺序：Activity-&gt;Window-&gt;DecorView</p>
<p>dispatchTouchEvent中：</p>
<p>1.判断是否需要拦截事件的标记intercepted<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 如果是down事件或者mFirstTouchTarget不为空</span><br><span class="line">if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123;</span><br><span class="line">  final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;</span><br><span class="line">  if (!disallowIntercept) &#123;</span><br><span class="line">    // 判断disallowIntercept标记</span><br><span class="line">    // 如果允许拦截则调用onInterceptTouchEvent</span><br><span class="line">    intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 有disallowIntercept标记，不拦截</span><br><span class="line">    intercepted = false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // 已有mFirstTouchTarget或者不是down时间，直接拦截</span><br><span class="line">  intercepted = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.尝试分发事件：如果第一步不需要拦截，并且不是cancel状态，分发给子view</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">	// 遍历子view，判断坐标是否在view范围内并且view没有处于动画状态</span><br><span class="line">  // 满足条件则交给子view的dispatchTouchEvent来处理</span><br><span class="line">  // 如果子view处理了事件，则把子view赋值给mFirstTouchTarget</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.再次分发事件：判断firstTouchTarget是否为空，如果为空表示没有子view处理事件，则间接的交给自己的onTouchEvent来处理，为空则直接交给firstTouchTarget处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (mFirstTouchTarget == null) &#123;</span><br><span class="line">  // 没有子view处理事件，交给自己的onTouchEvent处理</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // 直接交给mFirstTouchTarget处理后续事件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.<strong>onTouchListener ：</strong>如果有onTouchListener则优先交给onTouchListener处理，onTouchListener返回true则onTouchEvent将不会调用<br>5.cancel事件：父视图先不拦截，然后在 MOVE 事件中重新拦截，此时子 View 会接收到一个 CANCEL 事件，例如move出子view范围，或者scrollView中事件首先传递给子view，如果滑动则会被拦截。</p>
<h1 id="LeakCanary原理"><a href="#LeakCanary原理" class="headerlink" title="LeakCanary原理"></a>LeakCanary原理</h1><p>首先java的四种引用，强、软、弱、虚四种引用，配合ReferenceQueue使用，在构造弱引用时传入ReferenceQueue，在垃圾回收之前，会将引用放入队列中，可以通过队列中是否有对象的引用来判断对象是否被回收；</p>
<p>具体就是在Application中注册ActivityLifecycleCallbacks监听activity的生命周期，在onDestory的时候，新建一个弱引用传入队列，在线程空闲的时候，会尝试清除队列的弱引用，如果成功则没有发生泄漏，如果失败，则尝试GC，GC之后再<br>次尝试清除弱引用，如果失败则发生了内存泄漏</p>
<p>Fragment也类似，在Activity创建时获取到FragmentManager注册一个fragmentLifecycleCallbacks，然后观察fragment；</p>
<h1 id="Retrofit原理"><a href="#Retrofit原理" class="headerlink" title="Retrofit原理"></a>Retrofit原理</h1><p>核心原理：在createService时，创建一个Api接口的动态代理，在loadServiceMethod方法先查找缓存，没有找到则解析Api接口，解析包括两部分，一个是方法上的注解，包括url、Header、请求参数等，第二个是方法的返回类型和参数类型，也就是CallAdapter和ConverAdapter</p>
<p>CallAdapter用于把结果适配成Rxjava、kotlin协程等返回类型</p>
<p>ConverAdapter用于把参数转化为json或者其他格式传输。</p>
<p>loadServiceMethod完毕后，实际上是把请求组装成一个OkHttpCall，用okhttp来进行具体的请求。</p>
<h1 id="OkHttp原理"><a href="#OkHttp原理" class="headerlink" title="OkHttp原理"></a>OkHttp原理</h1><p>优点：连接池技术复用连接，可以降低延迟，无缝支持gzip减少数据量，支持http2以及SPDY多路复用技术</p>
<p>责任链设计模式：用来处理相关事务责任的一条执行链，执行链上有多个节点，每个节点都有机会（条件匹配）处理请求事务，如果某个节点处理完了就可以根据实际业务需求传递给下一个节点继续处理或者返回处理完毕</p>
<h1 id="请求流程："><a href="#请求流程：" class="headerlink" title="请求流程："></a>请求流程：</h1><p>1.构建request<br>2.通过dispatcher执行请求，dispatcher内部包含三个队列：同步请求队列、异步等待队列和异步执行队列，对于同步请求，直接添加到同步请求队列执行，异步请求则添加到等待队列中，然后判断请求数是否大于最大请求数、以及同一个主机的最大请求数，如果可以执行，则提升到执行队列进行执行<br>3.无论是同步请求还是异步请求，最终都调用到getResponseWithInterceptorChain方法，核心就是拦截器链，包含了7大拦截器，分别负责不同的功能，每一个拦截器都可以自己处理请求，然后直接返回或者交给下一节点来处理。</p>
<pre><code>自定义拦截器
RetryAndFollowUpInterceptor：重试和重定向拦截器
BridgeInterceptor：用来设置一些必要的header
CacheInterceptor：处理缓存
ConnectInterceptor：负责建立服务器连接，优先从连接池中找到可用连接(soket连接是否可用，是否超时等，如不可用则会从连接池中移除)，否则打开一个新的连接
自定义网络拦截器
CallServerInterceptor：最后一个拦截器，用于真正发送网络请求，返回response
</code></pre><h1 id="为什么要组件化，怎么实现？了解的路由框架"><a href="#为什么要组件化，怎么实现？了解的路由框架" class="headerlink" title="为什么要组件化，怎么实现？了解的路由框架"></a>为什么要组件化，怎么实现？了解的路由框架</h1><p>痛点：在业务开发中，各个业务模块依赖关系复杂，耦合严重，造成app编译缓慢、不能并行开发、组件复用性不高的问题。通过组件化改造，可以对各个模块进行了业务隔离，使模块可以单独编译运行，降低耦合度，提高了开发和调试效率。</p>
<h2 id="组件拆分："><a href="#组件拆分：" class="headerlink" title="组件拆分："></a>组件拆分：</h2><p>应用入口：一个空壳app，提供应用的启动页面</p>
<p>支撑业务组件：网络请求、图片加载等一些支撑服务</p>
<p>通用业务模块：例如支付、推送、地图等sdk，封装后对外提供调用接口</p>
<p>应用业务组件：具体的业务，可以提出来作为一个单独应用的功能模块，两两之间不互相依赖</p>
<h2 id="模块间的通信，需要引入路由框架，主流路由框架大概分为两种"><a href="#模块间的通信，需要引入路由框架，主流路由框架大概分为两种" class="headerlink" title="模块间的通信，需要引入路由框架，主流路由框架大概分为两种"></a>模块间的通信，需要引入路由框架，主流路由框架大概分为两种</h2><p>ARouter：路由表+接口下沉的方式，在编译期间通过注解处理器扫描目标类，然后解析参数生成路由表，<br>模块服务通过接口下沉的方式，把接口定义在公共库中，具体实现类在业务模块中，在编译时通过扫描字节码发现实现类，然后通过ASM等字节码修改技术完成服务的注册；</p>
<p>CC：组件总线的方式，类似于EventBus发送消息一样，直接找到目标组件，发送一条指令执行对应操作，<br>通过gradle的Transform API:在编译时(dex/proguard之前)扫描当前要打包到apk中的所有类 ，然后通过ASM技术修改字节码，生成代码完成组件的注册；</p>
<h1 id="android优化的数据结构：SparseArray、ArrayMap"><a href="#android优化的数据结构：SparseArray、ArrayMap" class="headerlink" title="android优化的数据结构：SparseArray、ArrayMap"></a>android优化的数据结构：SparseArray、ArrayMap</h1><p>SparseArray的key只能为int，双列数组结构，优化了自动装箱的过程，并且会自动排序，查找采用二分查找，在数据量不大的情况下效率高</p>
<p>ArrayMap和SparseArray类似，但是key可以是对象，存储的时候存储通过key的hash值排序，也采用二分查找；</p>
<h1 id="进程间通信的方式"><a href="#进程间通信的方式" class="headerlink" title="进程间通信的方式"></a>进程间通信的方式</h1><p>1.广播</p>
<p>2.Messenger，封装的Binder，可以执行简单的串行通信。</p>
<p>3.ContentProvider，适用于进程间的数据共享，可以进行操作权限的控制，如数据库的读写等。</p>
<p>4.Socket，适用于网络通信，用于传输原始的字节流，两次拷贝、效率低于binder</p>
<p>5.Binder，适用于复杂的进程通信，功能强大，CS架构，底层基于内存映射，只进行一次拷贝，所以效率高，可以验证通信的进程id，所以比socket更安全。</p>
<h1 id="AIDL和Binder机制"><a href="#AIDL和Binder机制" class="headerlink" title="AIDL和Binder机制"></a>AIDL和Binder机制</h1><p>AIDL实际上是一套快速实现Binder通信的工具，通过定义AIDL接口，系统会自动生成一个类实现IInterface接口，内部包含Stub和Proxy两个内部类。服务端继承Stub提供服务。</p>
<h2 id="关键类和方法"><a href="#关键类和方法" class="headerlink" title="关键类和方法"></a>关键类和方法</h2><p>Stub：服务端通过继承Stub，实现定义的接口来提供服务</p>
<p>Proxy：服务端对象的本地代理，客户端通过它来间接调用服务端接口的方法</p>
<p>asInterface：客户端调用，将binder对象转化为AIDL接口类型对象，如果和服务端在同一进程，返回Stub对象本身，否则返回Stub.proxy代理对象</p>
<p>asBinder：返回binder对象</p>
<p>onTransact：运行在服务端binder线程池，客户端请求时，远程请求会被系统封装后交给此方法处理</p>
<p>transact：运行在客户端，客户端发起请求时线程挂起，调用到服务端onTransact，等待其返回后才继续执行</p>
<h1 id="Binder机制"><a href="#Binder机制" class="headerlink" title="Binder机制"></a>Binder机制</h1><p>基于C/S架构，包括Server、Client、ServiceManager和Binder驱动，其中Binder驱动运行在内核空间，其他的运行在用户空间</p>
<p>ServiceManager负责服务管理，服务端向ServiceManager注册后，客户端可以向ServiceManager查询获取到目标服务的引用</p>
<p>Binder驱动：负责进程之间的Binder通信的建立，基于内存映射技术，传统的通信方式需要将数据从用户空间拷贝到内核空间，然后从内核空间拷贝到目标进程的用户空间，需要两次拷贝，Binder驱动可以建立用户空间内存和内核空间内存的一个映射，</p>
<p>只需要一次拷贝，非常高效。</p>
<h1 id="kotlin的扩展方法是怎么实现的，inline关键字的作用"><a href="#kotlin的扩展方法是怎么实现的，inline关键字的作用" class="headerlink" title="kotlin的扩展方法是怎么实现的，inline关键字的作用"></a>kotlin的扩展方法是怎么实现的，inline关键字的作用</h1><p>扩展方法编译成java后，实际上是一个 public static的静态方法，传入了对象实例和参数<br>Inline关键字修饰的函数是内联函数，用于优化函数调用的压栈操作，相当于在编译期间把内联函数的代码拷贝到函数调用处，可以提升性能，但是增加了代码量</p>
<h1 id="Handler机制"><a href="#Handler机制" class="headerlink" title="Handler机制"></a>Handler机制</h1><h2 id="关键类："><a href="#关键类：" class="headerlink" title="关键类："></a>关键类：</h2><p>Handler：用于发送消息和处理消息，发送消息就是将消息对象放入当前线程的MessageQueue中，然后Looper轮询到消息后交给自己处理，构造时需要传入Looper或者自动获取当前线程的Looper</p>
<p>Looper：轮询器，一个线程只能有一个Looper，用于从消息队列中轮询消息，然后交给对应的Handler处理</p>
<p>MessageQueue：消息队列，是一个阻塞队列，当没有消息是线程会被阻塞，等待有消息时唤醒线程</p>
<p>Message：消息对象，采用了对象池技术，可以避免对象的频繁创建开销</p>
<h1 id="消息的发送和轮询"><a href="#消息的发送和轮询" class="headerlink" title="消息的发送和轮询"></a>消息的发送和轮询</h1><p>发送消息：最终都会调用MessageQueue的enqueueMessage中，如果队列中没有消息或者消息的发送时间小于第一个消息，则直接放入队列头部，否则则根据时间插入到队列中的合适位置，同时会刷新needWeak标记，然后判断needWeak，如果需要唤醒，调用naviteWeak唤醒Looper。</p>
<p>获取消息：核心方法为MessageQueue的next，首先调用nativePollOnce，这个方法是一个native阻塞方法（通过监控文件描述符的io操作来实现），新消息放入队列时，会调用naviteWeak来唤醒。唤醒之后，如果是消息屏障就先处理异步消息，否则判断消息执行时间是否到达来返回消息或者进入下一个循环继续阻塞。</p>
<p>IdleHandler：在消息队列空闲的时候，会尝试执行IdleHandler的任务</p>
<p>消息屏障机制：当messageQueue取出屏障消息时，会开启循环，找到下一个异步消息执行，相当于阻塞了同步消息而优先执行异步消息，Android中所有UI绘制都是异步消息，可以保证UI绘制任务优先执行。</p>
<h1 id="postDelay怎么保证消息的顺序"><a href="#postDelay怎么保证消息的顺序" class="headerlink" title="postDelay怎么保证消息的顺序"></a>postDelay怎么保证消息的顺序</h1><p>发送消息时会对消息队列按执行时间进行排序，如果没有消息或者当前消息执行时间小于队列的第一条消息，则直接插入到表头，否则会插入到合适的位置，保证delay时间长的不会阻塞住时间短的。</p>
<h1 id="Activity启动流程"><a href="#Activity启动流程" class="headerlink" title="Activity启动流程"></a>Activity启动流程</h1><p>1.Luancher 进程通过binder向AMS发起startActivity请求<br>2.AMS收到请求， ActivityStarter解析flag，启动模式等，ActivityStack处理activity栈<br>3.然后AMS通过socket调用到Zygote，fork新的app进程<br>4.app进程创建后，再通过binder向AMS发起attachApplication请求<br>5.AMS通过binder调用发送scheduleLaunchActivity到app进程<br>6.APP进程的binder线程ApplicationThread接收到请求，通过handler发送LAUNCH_ACTIVITY消息到主线程<br>7.ActivityThread接收到消息，执行到handleLaunchActivity，开始Activity的生命周期<br><img src="/2015/12/14/offce001/../../../../images/a3aed8572f104535a3b0e679ea8c4cd9_tplv-k3u1fbpfcp-zoom-1.png" alt="Alt text"><br>应用第一次启动时，zygote进程fork出应用进程后，AMS会保存一个ProcessRecord信息（包名+进程uid），下一次启动判断这个ProcessRecord已经存在的话，就不会再新建进程，这就属于应用内打开Activity的过程了</p>
<h1 id="APK打包流程"><a href="#APK打包流程" class="headerlink" title="APK打包流程"></a>APK打包流程</h1><p><img src="/2015/12/14/offce001/../../../../images/4689f854f716495ea598a49d6ddac2b0_tplv-k3u1fbpfcp-zoom-1.png" alt="Alt text"></p>
<p>1.打包资源文件，生成R.java文件<br>2.处理aidl文件，生成相应的Java文件<br>3.编译项目源代码，生成class文件（所有的Java代码，包括R.java和.aidl文件）<br>4.转换所有的class文件，生成classes.dex文件<br>5.打包生成APK文件<br>6.对APK文件进行签名<br>7.对签名后的APK文件进行对齐处理。对齐的主要过程是将APK包中所有的资源文件距离文件起始偏移为4字节整数倍，这样通过内存映射访问apk文件时的速度会更快。对齐的作用就是减少运行时内存的使用</p>
<h1 id="APK安装流程："><a href="#APK安装流程：" class="headerlink" title="APK安装流程："></a>APK安装流程：</h1><p>1.拷贝阶段：通过PMS通过handler发送一个安装消息，包含一些安装的参数，PackageHandler收到消息后通过隐式intent绑定到拷贝的service。检查apk安装路径，包的状态，然后拷贝至/data/app包名下<br>2.装载阶段：installPackageLI，PackageParser解析AndroidManifest文件，解析四大组件等信息<br>3.验证apk的签名信息<br>4.执行 dex 优化，实际为 dex2oat 操作，用来将 apk 中的 dex 文件转换为 oat 文件<br>5.安装apk，创建data目录，安装成功则更新权限等信息<br>6.发送成功广播，安装失败则删除安装包和缓存</p>
<h1 id="Android系统启动流程"><a href="#Android系统启动流程" class="headerlink" title="Android系统启动流程"></a>Android系统启动流程</h1><p>1.开机加载BootLoader，加载Linux内核<br>2.启动Init进程<br>3.读取init.rc配置文件，启动几个关键进程，包括Zygote、ServiceManager、SurfaceFlinger和MediaServer<br>4.zygote进程启动java runntime，然后fork出sytem_server进程<br>5.sytem_server启动AMS、WMS、电源管理、等等系统服务，并通过Binder注册到ServiceManager。<br>6.启动Launcher显示桌面<br><img src="/2015/12/14/offce001/../../../../images/96bd5c17c1374385971a2ad840d964bc_tplv-k3u1fbpfcp-zoom-1.png" alt="Alt text"></p>
<h1 id="Webview的漏洞"><a href="#Webview的漏洞" class="headerlink" title="Webview的漏洞"></a>Webview的漏洞</h1><p>1.4.2版本的addJavascriptInterface 造成的远程代码执行漏洞，当JS拿到Android这个对象后，就可以调用Android对象中所有的方法，包括系统类（java.lang.Runtime 类），从而执行任意代码</p>
<pre><code>4.2版本以上通过对调用的方法添加JavascriptInterface注解避免漏洞
4.2以下采用url拦截或者js弹窗拦截的方式进行交互，不能采用对象映射
</code></pre><p>2.密码明文存储<br>3.域控制不严问题，允许导出的WebActivity未关闭file协议，可以外部启动并加载恶意file协议的文件，从而访问私有文件，所以不需要使用file协议的，需要关闭</p>
<h1 id="Dalvik与ART的区别"><a href="#Dalvik与ART的区别" class="headerlink" title="Dalvik与ART的区别"></a>Dalvik与ART的区别</h1><p>1.Dalvik：即时编译，应用每次运行都需要通过即时编译器（JIT）将字节码转换为机器码，所以运行效率相对ART较低。由于不需要预编译，所以安装过程较快<br>2.ART ：应用在第一次安装的时候，字节码就会预编译（AOT）成机器码，这样的话，虽然设备和应用的首次启动（安装慢了）会变慢，但是以后每次启动执行的时候，都可以直接运行，因此运行效率会提高<br>3.ART占用空间比Dalvik大（字节码变为机器码之后，可能会增加10%-20%）<br>4.预编译也可以明显改善电池续航，从而减少了 CPU 的使用频率，降低了能耗。</p>
<h1 id="热修复和插件化原理"><a href="#热修复和插件化原理" class="headerlink" title="热修复和插件化原理"></a>热修复和插件化原理</h1><p>java类加载机制</p>
<p>双亲委托机制：如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载</p>
<p>Java的类加载器分为：根加载器（加载java核心类）、扩展类加载器（加载jre扩展目录）、应用类加载器（加载classPath指定目录的类，自定义类加载器一般继承此加载器）</p>
<p>Android的类加载器：根加载器、BaseDexClassLoader、PathClassLoader（加载安装到系统的APK）、DexClassLoader（加载指定目录的dex和apk）</p>
<h1 id="热修复和插件化的区别"><a href="#热修复和插件化的区别" class="headerlink" title="热修复和插件化的区别"></a>热修复和插件化的区别</h1><p>热修复：替换bug的类，需要把修复类抢先于bug类进行加载，让bug类得不到加载。通过反射修改DexClassLoader中DexPathList的dexElements数组，将需要加载的dex添加到数组前面。</p>
<p>插件化：运行未安装的插件apk的代码，不涉及到抢先加载，只需要将dex加载到dexElements中</p>
<h1 id="热修复的CLASS-ISPREVERIFIED问题"><a href="#热修复的CLASS-ISPREVERIFIED问题" class="headerlink" title="热修复的CLASS_ISPREVERIFIED问题"></a>热修复的CLASS_ISPREVERIFIED问题</h1><p>热修复是需要修复有bug的类，所以需要把dex放在数组的前端抢先加载补丁类，在虚拟机启动的时候，在verify选项被打开的时候，如果static方法、private方法、构造函数等，其中直接引用到的类都在同一个dex文件中，那么该类就会被打上CLASS_ISPREVERIFIED标志，且一旦类被打上CLASS_ISPREVERIFIED标志其他dex就不能再去替换这个类。<br>​        为了阻止类被打上CLASS_ISPREVERIFIED标志，先将一个预备好的hack.dex加入到dexElements的第一项，让后面的dex的所有类都引用hack.dex其中的一个类。</p>
<h1 id="常见热修复框架"><a href="#常见热修复框架" class="headerlink" title="常见热修复框架"></a>常见热修复框架</h1><p>Tinker实际上是类加载方案的升级，它增加了dex的差分算法，再将差分dex与apk中的classex.dex做合并，在运行bug类之前抢先加载补丁。</p>
<p>tinker差分算法：dexDiff , 新旧dex先排序，然后定义两个指针依次往下挪，如果old&gt;new，则一定是新增，如果old&lt;\new，则是删除，如果相等，则索引可能不同，需要记录索引的变化，最后如果相同的索引既有删除又有新增，则优化为replace操作。资源差分则采用BSDiff。</p>
<p>美团Robust，Instant Run方案，用代码插桩的方式，在每个方法中插入一段开关代码，如果需要修复，则走入if判断，执行补丁中的同名类的同名方法</p>
<h1 id="插件化方案"><a href="#插件化方案" class="headerlink" title="插件化方案"></a>插件化方案</h1><p>插件化主要是加载新的功能模块，最主要的功能除了加载类，还需要加载资源和生命周期的管理。</p>
<p>资源加载：通过反射AssetManager ，将资源所在路径添加到AssetManager的path中，然后创建一个Resource，hook住activity替换mResources实现资源的访问。具体分为两种：</p>
<p>1.合并式：插件资源合并到主工程，插件和主工程可以直接访问资源，合并资源会造成资源id冲突，所以需要修改aapt源码，id格式为0xPPTTNNNN，在编译期修改高两位PP段，不同插件使用不同的PP段标识。<br>修改resources.arsc文件，该文件列出了资源id到具体资源路径的映射，相当于一个索引。</p>
<p>2.独立式：插件只访问插件内部的资源，不能共享，也不会冲突。</p>
<p><strong>生命周期的管理：</strong>没有在清单文件中注册过的Activity不能启动，现在的主流做法是预留各种启动模式的代理Activity占坑，然后通过hook住mInstrumentation对象，在启动插件Activity时替换intent为代理的Activity，从而绕过AMS的验证，系统以为是启动的代理Activity，然后真正启动时，需要还原原先的Intent，启动插件Activity，同时hook替换mResources，这样就实现了生命周期管理</p>
<p>#VirtualApk原理<br>如何加载插件类：（类加载机制）<br>插件创建ClassLoader，父类加载器是宿主的classloader，这样插件可以反射访问到宿主的类。</p>
<p>然后判断COMBINE_CLASSLOADER标记，如果COMBINE_CLASSLOADER为true，则会把dex插入到父类加载器的elements后边，使宿主可以访问插件的类。如果为false表示宿主与插件隔离，宿主不能访问插件。不论true或false，插件都可以访问宿主。</p>
<p>DroidPlugin是采用隔离模式，插件的classloader的父类加载器是BootClassLoader，所以相互都不能访问。</p>
<h1 id="如何加载资源："><a href="#如何加载资源：" class="headerlink" title="如何加载资源："></a>如何加载资源：</h1><p>1.COMBINE_CLASSLOADER为true：把插件资源添加到宿主Resources的AssetsManager的资源路径中去。<br>编译时过滤宿主和插件中的重复资源，然后修改R和资源表文件，让插件中只保留新的资源。<br>存在的问题：</p>
<p>2.宿主和插件开发可能是并行的，过滤资源时候如果依赖的是1.0的宿主，在1.1中资源发生了变化，插件就会找不到资源，滴滴是让public.xml让宿主资源id不可变来实现。<br>如果宿主和插件有相同名字的资源，例如都有一个about字符串，由于资源过滤，插件的会被过滤掉。</p>
<h1 id="activity的启动："><a href="#activity的启动：" class="headerlink" title="activity的启动："></a>activity的启动：</h1><p>hook系统instrumentation，判断如果启动的是插件的类，则通过预埋的activity绕过ams对activity的验证，然后在真正启动activity的时候，还原intent来启动目标类，这样目标类就有正常的生命周期了</p>
<h1 id="service的启动："><a href="#service的启动：" class="headerlink" title="service的启动："></a>service的启动：</h1><p>hook系统ActivityManager，创建一个动态代理来替换系统中的单例对象，实际上启动LocalService来代理目标服务的生命周期。</p>
<h1 id="广播："><a href="#广播：" class="headerlink" title="广播："></a>广播：</h1><p>解析清单文件，把注册的静态广播转换为动态广播。</p>
<p>启动activity时的问题</p>
<p>在创建插件的ClassLoader时，有一个COMBINE_CLASSLOADER标记用来设置是否要讲插件的dex插入到宿主的dex数组中，让宿主可以访问插件的类。COMBINE_CLASSLOADER标记为false时，宿主不能访问到插件类<br>源码instrumentation中handleMessage处理启动activity时，给intent的extras设置了宿主的类加载器，如果extra中有一个插件中才有的序列化对象，读取extra时反序列化会出错，就会抛出找不到类异常。到现在版本仍未解决。<br>解决方案：直接用一个新的intent包装原始的intent来替换，intent是parcelable的。</p>
<h1 id="RecyclerView缓存"><a href="#RecyclerView缓存" class="headerlink" title="RecyclerView缓存"></a>RecyclerView缓存</h1><p>1.mAttachedScrap和mChangedScrap，用于缓存屏幕内的ViewHolder，例如下拉刷新后，屏幕内的ViewHolder需要刷新数据<br>2.mCachedViews，移除屏幕之外的，默认缓存两个，因为接下来可能马上往回滑动，再次使用到<br>3.ViewCacheExtension，预留的一个缓存扩展，暂时没有用到<br>4.RecycledViewPool，缓存屏幕外的 ViewHolder，需要重新绑定数据</p>
<h1 id="RecyclerView-缓存结构，RecyclerView预取，RecyclerView局部刷新"><a href="#RecyclerView-缓存结构，RecyclerView预取，RecyclerView局部刷新" class="headerlink" title="RecyclerView 缓存结构，RecyclerView预取，RecyclerView局部刷新"></a>RecyclerView 缓存结构，RecyclerView预取，RecyclerView局部刷新</h1><ul>
<li>Scrap：对应ListView 的Active View，就是屏幕内的缓存数据，就是相当于换了个名字，可以直接拿来复用</li>
<li>Cache ： 刚刚移出屏幕的缓存数据</li>
<li>ViewCacheExtension：是google留给开发者自己来自定义缓存的</li>
<li>RecycledViewPool：回收池，最重要<h1 id="答：四级缓存，有一个自定义的不用"><a href="#答：四级缓存，有一个自定义的不用" class="headerlink" title="答：四级缓存，有一个自定义的不用"></a>答：四级缓存，有一个自定义的不用</h1></li>
<li>局部刷新：notifyPositon或者nofiyview实现，可以执行动画</li>
</ul>
<h1 id="AsyncTask原理和缺陷"><a href="#AsyncTask原理和缺陷" class="headerlink" title="AsyncTask原理和缺陷"></a>AsyncTask原理和缺陷</h1><p>实际是通过Handler+线程池实现，内部含有两个线程池，一个用于排队，一个用于真正执行任务</p>
<h1 id="缺陷："><a href="#缺陷：" class="headerlink" title="缺陷："></a>缺陷：</h1><p>执行任务的线程池是个静态的全局线程池，最大线程数为128，如果任务队列满了，然后最大线程数也满了，再提交任务会出现崩溃；解决方案为自定义线程池<br>必须主线程初始化，内部handler获取主线程looper，否则不能正确切换到主线程。<br>结果丢失问题：如果activity重建，例如切横竖屏，因为持有的引用是重建之前的，新的Activity无法接收到结果。<br>内存泄漏，退出页面需要正确取消</p>
<h1 id="性能优化相关"><a href="#性能优化相关" class="headerlink" title="性能优化相关"></a>性能优化相关</h1><p>卡顿优化</p>
<p>1.View本身绘制时间过长超过16ms造成掉帧，所以需要减少View嵌套层级，使用ViewStub和merge标签，优化过度绘制等</p>
<p>2.主线程执行耗时任务，合理使用线程，将耗时任务放到后台进行</p>
<p>3.内存抖动，会频繁触发GC，造成卡顿。使用内存分析工具优化内存使用，减少不必要对象的创建</p>
<h1 id="耗电优化"><a href="#耗电优化" class="headerlink" title="耗电优化"></a>耗电优化</h1><p>合理使用后台服务，合并网络请求，使用protobuf替换json进行服务端请求，cpu休眠锁等</p>
<h1 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h1><p>内存泄露优化（包括常见的内存泄漏、分析方法、LeakCanrary等）、使用优化的数据结构（ArrayMap和SparseArray），对频繁创建的对象使用对象池技术，减少不必要的内存开销，</p>
<h1 id="启动优化"><a href="#启动优化" class="headerlink" title="启动优化"></a>启动优化</h1><p>Application的attachBaseContext和onCreate，三方sdk采用线程池异步初始化，activity的onCreate中，设置布局的优化（xml的io操作、反射创建view的操作，通过异步inflater和自定义inflater.factory来优化）</p>
<p>1.延迟初始化非必要的库，拓展到异步启动器的设计和实现，有向无环图来解决库依赖的问题。<br>2.给闪屏页设置图片背景避免冷启动白屏，其实不能加快启动，只是避免白屏给用户的体验不佳</p>
<h1 id="apk大小优化"><a href="#apk大小优化" class="headerlink" title="apk大小优化"></a>apk大小优化</h1><p>1，开启混淆压缩代码<br>2，压缩和混淆资源，图片压缩采用webP格式，整理Raw、assets资源<br>3，减少非必要so库，目前主流的机型都是支持armeabi-v7a的，并且armeabi-v7a兼容armeabi<br>4，移除未使用的资源，如图标，字符串，字体等<br>5，一些小图像可以使用矢量图，大矢量图渲染时间很长，不适用<br>6，减少三方库使用，避免枚举的使用<br>7，动态下发一些资源，如换肤包，so，字体等</p>
<h1 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h1><p>1.HttpDNS优化，传统DNS解析一般是用UDP的方式与DNS服务器交互，HttpDNS采用Http协议交互，绕过运营商的 LocalDNS 服务器，有效的防止了域名劫持，提高域名解析的效率<br>2.使用缓存，需要服务端支持，或者通过OkHttp拦截器添加统一的缓存策略<br>3.HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。在HTTP1.1中默认开启keep-alive<br>4.数据压缩，gzip压缩，http2.0也支持header的压缩<br>5.根据网络质量来下载不同质量的图片</p>
<h1 id="View-inflate流程"><a href="#View-inflate流程" class="headerlink" title="View inflate流程"></a>View inflate流程</h1><p>1.先从resource中获取一个xml parser用于加载布局<br>2.读取layout文件，调用createViewFromTag创建View<br>3.tryCreateView中，依次判断有没有设置Factory2和Factory，如果有则调用它的createView来创建view<br>4.如果没有factory则调用自己的createView来创建，内部是使用反射创建对象<br>5.注意，Factory2继承Factory增加了一个创建view的方法，相当于是一个扩展，它们可以对view创建的过程进行拦截，在创建view的时候做一些事情，例如换肤功能就用到这里。</p>
<h1 id="换肤的原理"><a href="#换肤的原理" class="headerlink" title="换肤的原理"></a>换肤的原理</h1><p>1.制作皮肤包apk，只包含颜色、图片等，通过网络下载到sd卡；<br>2.通过反射构造皮肤包的AssetManager，再用此AssetManager创建Resource。<br>3.原apk和资源包中资源名称一样，提供一个资源映射的方法，通过原来的资源id找到资源名称，然后在皮肤包中查找皮肤资源具体的值；<br>4.通过自定义LayoutInflater传入自定义的Factory2拦截view的创建过程，查找到需要换肤的view和对应的可替换属性名(background、color、textcolor等)、属性值的类型（color\drawable\mipmap…）、属性值在原apk中的资源名(如color1)和资源的id，保存起来；<br>5.点击换肤时，遍历需要换肤的view集合，调用对应的方法（setColor等等）设置新的值。</p>
<h1 id="Android的startActivityForResult的实现为什么不使用回调。"><a href="#Android的startActivityForResult的实现为什么不使用回调。" class="headerlink" title="Android的startActivityForResult的实现为什么不使用回调。"></a>Android的startActivityForResult的实现为什么不使用回调。</h1><p>因为匿名内部类会持有外部类的引用，使用回调时，例如A启动B去获取result，由于某些原因原A已经被销毁了，当B设置结果返回A时，实际上A已经被系统重建，和原先的A不是同一个对象了，所以就不能正确的获取结果。</p>
<h1 id="如何跨app启动activity？"><a href="#如何跨app启动activity？" class="headerlink" title="如何跨app启动activity？"></a>如何跨app启动activity？</h1><p>1.shareUserId，设置同一个shareUserId的应用可以直接启动。<br>2.Exported 设置为true，向外部暴露activity，允许外部启动。<br>注意：为了安全需要添加自定义权限控制，注意被暴露的有权限的app需要先被安装，否则会获取不到权限。<br>会导致拒绝服务漏洞，例如：A启动B中的activity，往intent中添加一个序列化对象，这个对象只在A中有，B中没有这个类，如果在B中访问intent的extra，就会触发反序列化对象，由于找不到这个对象的类，造成B崩溃。处理方法：获取extra要捕获异常。<br>3.隐式启动activity，只要intentFilter匹配成功就可以启动。</p>
<h1 id="高性能日志采集"><a href="#高性能日志采集" class="headerlink" title="高性能日志采集"></a>高性能日志采集</h1><h2 id="传统直接读写文件的方式的缺点"><a href="#传统直接读写文件的方式的缺点" class="headerlink" title="传统直接读写文件的方式的缺点"></a>传统直接读写文件的方式的缺点</h2><p>读写文件的IO操作，需要两次拷贝，用户空间到内核空间，内核空间再到硬盘。为了避免频繁IO，采用缓存日志到内存，达到一定量时再统一写入文件，虽然避免了频繁IO，但是可能造成crash时日志丢失。多进程也无法保证写入顺序</p>
<h1 id="mmap方案："><a href="#mmap方案：" class="headerlink" title="mmap方案："></a>mmap方案：</h1><p>mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。mmap操作提供了一种机制，让用户程序直接访问设备内存，这种机制，相比较在用户空间和内核空间互相拷贝数据，效率更高。</p>
<h1 id="mmap的回写时机："><a href="#mmap的回写时机：" class="headerlink" title="mmap的回写时机："></a>mmap的回写时机：</h1><p>1.内存不足<br>2.进程退出<br>3.调用 msync 或者 munmap<br>4.不设置 MAP_NOSYNC 情况下 30s-60s(仅限FreeBSD)</p>
<p>多进程写入映射同一个内存也会造成写入顺序无法保证，所以可以选择多进程映射不同的文件，每隔一段时间合并一次来解决</p>
<h1 id="性能优化工具："><a href="#性能优化工具：" class="headerlink" title="性能优化工具："></a>性能优化工具：</h1><p>查看方法执行时间：</p>
<h1 id="TraceView（影响性能）"><a href="#TraceView（影响性能）" class="headerlink" title="TraceView（影响性能）"></a>TraceView（影响性能）</h1><p>1.用Debug.startMethodTrace来打点，生成trace文件，然后用adb导出分析<br>2.使用profiler工具，选择cpu，输出trace文件</p>
<h1 id="Systrace（轻量级）"><a href="#Systrace（轻量级）" class="headerlink" title="Systrace（轻量级）"></a>Systrace（轻量级）</h1><p>1.TraceCompat.beginSection<br>2.使用python命令导出html，查看wall time和 cpu time</p>
<h1 id="MAT分析内存泄露："><a href="#MAT分析内存泄露：" class="headerlink" title="MAT分析内存泄露："></a>MAT分析内存泄露：</h1><p>profiler分析内存，手动触发gc，然后输出堆转储hporf文件，然后用mat分析引用链</p>
<h1 id="内存抖动："><a href="#内存抖动：" class="headerlink" title="内存抖动："></a>内存抖动：</h1><p>使用profiler工具排查</p>
<h1 id="你们项目的稳定性如何？有做过什么稳定性优化的工作？"><a href="#你们项目的稳定性如何？有做过什么稳定性优化的工作？" class="headerlink" title="你们项目的稳定性如何？有做过什么稳定性优化的工作？"></a>你们项目的稳定性如何？有做过什么稳定性优化的工作？</h1><p>答： 我们主要优化了三项：<br>Crash专项优化<br>性能稳定性优化<br>业务稳定性优化<br>性能：全面的性能优化：启动速度、内存优化、绘制优化<br>线下发现问题、优化为主<br>线上监控为主<br>Crash专项优化<br>我们针对启动速度，内存、布局加载、卡顿、瘦身、流量、电量等多个方面做了多维的优化。</p>
<p>我们的优化主要分为了两个层次，即线上和线下，针对于线下呢，我们侧重于发现问题，直接解决，将问题尽可能在上线之前解决为目的。而真正到了线上呢，我们最主要的目的就是为了监控，对于各个性能纬度的监控呢，可以让我们尽可能早地获取到异常情况的报警。</p>
<p>同时呢，对于线上最严重的性能问题性问题：Crash，我们做了专项的优化，不仅优化了Crash的具体指标，而且也尽可能地获取了Crash发生时的详细信息，结合后端的聚合、报警等功能，便于我们快速地定位问题。</p>
<h1 id="PathClassLoader与DexClassLoader有什么区别"><a href="#PathClassLoader与DexClassLoader有什么区别" class="headerlink" title="PathClassLoader与DexClassLoader有什么区别"></a>PathClassLoader与DexClassLoader有什么区别</h1><p>答： PathClassLoader 和 DexClassLoader 类加载器都是继承自 BaseDexClassLoade<br>DexClassLoader 和 PathClassLoader 构造函数<br>DexClassLoader 和 PathClassLoader 的差异在于构造 ClassLoader 对象时，是否给父类 (<br>BaseDexClassLoader<br>) 传递 optimizedDirectory 参数 </p>
<h1 id="跨进程通信了解多少？管道了解吗？"><a href="#跨进程通信了解多少？管道了解吗？" class="headerlink" title="跨进程通信了解多少？管道了解吗？"></a>跨进程通信了解多少？管道了解吗？</h1><ul>
<li>答：四大组件可以跨进程<br>主要是binder机制。Android都是，平时用AIDL<br>管道：2次拷贝？？？？？？？缓冲区有大小限制。管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。在创建时分配一个page大小的内存，缓存区大小比较有限。</li>
</ul>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

            
    
        <a href="http://b.nearby.ren/2015/12/14/offce001/#comments" class="article-comment-link">评论</a>
    

        </footer>
    </div>
    
</article>



    <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/page/18/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="page-number" href="/page/18/">18</a><span class="page-number current">19</span><a class="page-number" href="/page/20/">20</a><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/20/">下一页 &raquo;</a>
    </nav>
</section>
            
                <aside id="sidebar">
   
        
    <div class="widget-wrap">
        <h3 class="widget-title">最新文章</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2023/11/30/kotlin data class 和 class 区别/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/kotlin/">kotlin</a></p>
                            <p class="item-title"><a href="/2023/11/30/kotlin data class 和 class 区别/" class="title">kotlin data class 和 class 区别</a></p>
                            <p class="item-date"><time datetime="2023-11-30T04:13:18.000Z" itemprop="datePublished">2023-11-30</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2023/09/30/kotlin集合/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/kotlin/">kotlin</a></p>
                            <p class="item-title"><a href="/2023/09/30/kotlin集合/" class="title">Kotlin 集合</a></p>
                            <p class="item-date"><time datetime="2023-09-30T04:20:20.000Z" itemprop="datePublished">2023-09-30</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2021/06/08/组件化架构图/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2021/06/08/组件化架构图/" class="title">组件化架构图</a></p>
                            <p class="item-date"><time datetime="2021-06-08T08:03:12.000Z" itemprop="datePublished">2021-06-08</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2021/05/31/mac flutter 支持多个版本配置/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/android/">android</a></p>
                            <p class="item-title"><a href="/2021/05/31/mac flutter 支持多个版本配置/" class="title">mac flutter 支持多个版本配置</a></p>
                            <p class="item-date"><time datetime="2021-05-31T01:47:42.000Z" itemprop="datePublished">2021-05-31</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2021/05/17/Fragment的FragmentTransaction/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Fragment/">Fragment</a></p>
                            <p class="item-title"><a href="/2021/05/17/Fragment的FragmentTransaction/" class="title">Android 7.0以上 charles OpenSSLhttps抓包</a></p>
                            <p class="item-date"><time datetime="2021-05-17T01:12:11.000Z" itemprop="datePublished">2021-05-17</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">分类</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/EventBus/">EventBus</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Fragment/">Fragment</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RecyclerView/">RecyclerView</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a><span class="category-list-count">30</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/android-studio/">android studio</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/apk/">apk</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/bug/">bug</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/charles/">charles</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/dagger2/">dagger2</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/flutter/">flutter</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/go/">go</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/gradle/">gradle</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/kotlin/">kotlin</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linxu/">linxu</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mac/">mac</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/markdown/">markdown</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mvp/">mvp</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/offce/">offce</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/resume/">resume</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/rxjava/">rxjava</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tinker/">tinker</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/vuforia/">vuforia</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/延迟搜索/">延迟搜索</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/文字/">文字</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/软件/">软件</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/适配/">适配</a><span class="category-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">归档</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">十一月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">九月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">十一月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">六月 2015</a><span class="archive-list-count">2</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">标签</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Leakcanary/">Leakcanary</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mac-Linux/">Mac/Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a><span class="tag-list-count">46</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-studio/">android studio</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bug/">bug</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/charles/">charles</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dagger2/">dagger2</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flutter/">flutter</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/glide/">glide</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/">go</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/">golang</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gradle/">gradle</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/h5/">h5</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/https/">https</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ios/">ios</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kotlin/">kotlin</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linxu/">linxu</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mac/">mac</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/">markdown</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mvp/">mvp</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/offce/">offce</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/resume/">resume</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rxandroid/">rxandroid</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rxjava/">rxjava</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/service/">service</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springboot/">springboot</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/view/">view</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vuforia/">vuforia</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/">web</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/延迟/">延迟</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/性能优化/">性能优化</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/文字/">文字</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/歌曲/">歌曲</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/直播/">直播</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/笔录/">笔录</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/软件名词/">软件名词</a><span class="tag-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">标签云</h3>
        <div class="widget tagcloud">
            <a href="/tags/Android/" style="font-size: 16.67px;">Android</a> <a href="/tags/Leakcanary/" style="font-size: 10px;">Leakcanary</a> <a href="/tags/Mac-Linux/" style="font-size: 10px;">Mac/Linux</a> <a href="/tags/android/" style="font-size: 20px;">android</a> <a href="/tags/android-studio/" style="font-size: 10px;">android studio</a> <a href="/tags/bug/" style="font-size: 10px;">bug</a> <a href="/tags/charles/" style="font-size: 10px;">charles</a> <a href="/tags/dagger2/" style="font-size: 11.67px;">dagger2</a> <a href="/tags/flutter/" style="font-size: 10px;">flutter</a> <a href="/tags/git/" style="font-size: 16.67px;">git</a> <a href="/tags/glide/" style="font-size: 15px;">glide</a> <a href="/tags/go/" style="font-size: 18.33px;">go</a> <a href="/tags/golang/" style="font-size: 10px;">golang</a> <a href="/tags/gradle/" style="font-size: 16.67px;">gradle</a> <a href="/tags/h5/" style="font-size: 10px;">h5</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/https/" style="font-size: 11.67px;">https</a> <a href="/tags/ios/" style="font-size: 11.67px;">ios</a> <a href="/tags/java/" style="font-size: 11.67px;">java</a> <a href="/tags/kotlin/" style="font-size: 13.33px;">kotlin</a> <a href="/tags/linxu/" style="font-size: 11.67px;">linxu</a> <a href="/tags/mac/" style="font-size: 11.67px;">mac</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/mvp/" style="font-size: 13.33px;">mvp</a> <a href="/tags/offce/" style="font-size: 11.67px;">offce</a> <a href="/tags/resume/" style="font-size: 11.67px;">resume</a> <a href="/tags/rxandroid/" style="font-size: 11.67px;">rxandroid</a> <a href="/tags/rxjava/" style="font-size: 11.67px;">rxjava</a> <a href="/tags/service/" style="font-size: 10px;">service</a> <a href="/tags/springboot/" style="font-size: 10px;">springboot</a> <a href="/tags/view/" style="font-size: 11.67px;">view</a> <a href="/tags/vuforia/" style="font-size: 10px;">vuforia</a> <a href="/tags/web/" style="font-size: 13.33px;">web</a> <a href="/tags/延迟/" style="font-size: 10px;">延迟</a> <a href="/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/tags/文字/" style="font-size: 11.67px;">文字</a> <a href="/tags/歌曲/" style="font-size: 11.67px;">歌曲</a> <a href="/tags/直播/" style="font-size: 10px;">直播</a> <a href="/tags/笔录/" style="font-size: 13.33px;">笔录</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/设计模式/" style="font-size: 13.33px;">设计模式</a> <a href="/tags/软件名词/" style="font-size: 10px;">软件名词</a>
        </div>
    </div>

    
        
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">链接</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="http://hexo.io">Hexo</a>
                    </li>
                
            </ul>
        </div>
    </div>


    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2023 阿荣<br>
            <!-- <a href="http://github.com/ppoffice">ppoffice</a>     
            主题 - <a href="http://hexo.io/" target="_blank">Hexo</a> -->  
             <a href="#" target="_blank">人生如逆旅  &phi; 我亦是行人 </a>
             <div class="copyright" style="margin-top: 10px;">
 			ICP备案号： <a href="https://beian.miit.gov.cn/" target="_blank">粤ICP备16067940号</a><br>
		</div>	
        </div>
    </div>
</footer>
        
    
    <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2119666"></script>



    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>